<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tutorial of rgeoda • rgeoda</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Tutorial of rgeoda">
<meta property="og:description" content="rgeoda">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rgeoda</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.8-3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/rgeoda_tutorial.html">Tutorial of rgeoda</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/geodacenter/rgeoda/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="rgeoda_tutorial_files/header-attrs-2.9/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Tutorial of rgeoda</h1>
                        <h4 class="author">Xun Li</h4>
            
            <h4 class="date">1/6/2021</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/geodacenter/rgeoda/blob/master/vignettes/rgeoda_tutorial.Rmd"><code>vignettes/rgeoda_tutorial.Rmd</code></a></small>
      <div class="hidden name"><code>rgeoda_tutorial.Rmd</code></div>

    </div>

    
    
<p><code>rgeoda</code> is an R library for spatial data analysis. It is an R wrapper of the libgeoda C++ library, which is built based on the <code>GeoDa</code> software. The version used in this tutorial is version 0.0.8.</p>
<div id="install-rgeoda" class="section level2">
<h2 class="hasAnchor">
<a href="#install-rgeoda" class="anchor"></a>1. Install <code>rgeoda</code>
</h2>
<p>The rgeoda package can be installed using “install.packages()” command:</p>
<pre><code><a href="https://rdrr.io/r/utils/install.packages.html">install.packages("rgeoda")</a></code></pre>
<p>, and then can be loaded using the customary “library()” command:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/geodacenter/rgeoda/">rgeoda</a></span><span class="op">)</span></code></pre></div>
<pre><code>## Loading required package: digest</code></pre>
<p>In addition, the package sf needs to be loaded, since it is a dependency:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span></code></pre></div>
<pre><code>## Linking to GEOS 3.9.1, GDAL 3.2.3, PROJ 7.2.1</code></pre>
</div>
<div id="load-spatial-data" class="section level2">
<h2 class="hasAnchor">
<a href="#load-spatial-data" class="anchor"></a>2. Load Spatial Data</h2>
<p>The rgeoda package for R relies on the sf (simple features) package for basic spatial data handling functions. In a typical R workflow, one first reads a shape file or other GIS format file with the data using the sf st_read(file path) command. For example, to load the ESRI Shapefile <code>Guerry.shp</code> comes with the package:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">guerry_path</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"extdata"</span>, <span class="st">"Guerry.shp"</span>, package <span class="op">=</span> <span class="st">"rgeoda"</span><span class="op">)</span>
<span class="va">guerry</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">st_read</a></span><span class="op">(</span><span class="va">guerry_path</span><span class="op">)</span></code></pre></div>
<pre><code>## Reading layer `Guerry' from data source `/private/var/folders/z1/5l2c5r6d41bfkrlq6s66s2gh0000gn/T/RtmptBWOYi/temp_libpath5cee2933d8ef/rgeoda/extdata/Guerry.shp' using driver `ESRI Shapefile'
## Simple feature collection with 85 features and 29 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: 47680 ymin: 1703258 xmax: 1031401 ymax: 2677441
## Projected CRS: NTF (Paris) / Lambert zone II</code></pre>
<p>Once the spatial object has been created, it can be used to compute a spatial weights matrix using one of the several weights functions in rgeoda.</p>
</div>
<div id="spatial-weights" class="section level2">
<h2 class="hasAnchor">
<a href="#spatial-weights" class="anchor"></a>3. Spatial Weights</h2>
<p>Spatial weights are central components in spatial data analysis. The spatial weights represent the possible spatial interactions between observations in space. <code>rgeoda</code> provides 6 functions to create 4 different types of spatial weights:</p>
<ul>
<li>Contiguity Based Weights: <code><a href="../reference/queen_weights.html">queen_weights()</a></code>, <code><a href="../reference/rook_weights.html">rook_weights()</a></code>
</li>
<li>Distance Based Weights: <code><a href="../reference/distance_weights.html">distance_weights()</a></code>
</li>
<li>K-Nearest Neighbor Weights: <code><a href="../reference/knn_weights.html">knn_weights()</a></code>
</li>
<li>Kernel Weights: <code><a href="../reference/distance_weights.html">distance_weights()</a></code> and <code><a href="../reference/knn_weights.html">knn_weights()</a></code> with kernel parameters</li>
</ul>
<div id="queen-contiguity-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#queen-contiguity-weights" class="anchor"></a>3.1 Queen Contiguity Weights</h3>
<p>Contiguity means that two spatial units share a common border of non-zero length. Operationally, we can further distinguish between a rook and a queen criterion of contiguity, in analogy to the moves allowed for the such-named pieces on a chess board. The queen criterion is somewhat more encompassing and defines neighbors as spatial units sharing a common edge or a common vertex.</p>
<p>To create a Queen contiguity weights, one can call the function</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/queen_weights.html">queen_weights</a></span><span class="op">(</span><span class="va">sf_obj</span>, order<span class="op">=</span><span class="fl">1</span>, include_lower_order <span class="op">=</span> <span class="va">False</span>, precision_threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></code></pre></div>
<p>For example, to create a Queen contiguity weights using the sf object <code>guerry</code>:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">queen_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/queen_weights.html">queen_weights</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></code></pre></div>
<pre><code>##                      name              value
## 1 number of observations:                 85
## 2          is symmetric:                TRUE
## 3               sparsity: 0.0581314878892734
## 4        # min neighbors:                  2
## 5        # max neighbors:                  8
## 6       # mean neighbors:   4.94117647058824
## 7     # median neighbors:                  5
## 8           has isolates:              FALSE</code></pre>
<p>The function <code><a href="../reference/queen_weights.html">queen_weights()</a></code> returns an instance of <code>Weight</code> object. One can access the meta data of the spatial weights by accessing the attributes of <code>GeoDaWeight</code> object:</p>
<div id="attributes-of-weight-object" class="section level4">
<h4 class="hasAnchor">
<a href="#attributes-of-weight-object" class="anchor"></a>Attributes of <code>Weight</code> object</h4>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/is_symmetric.html">is_symmetric</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/has_isolates.html">has_isolates</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/weights_sparsity.html">weights_sparsity</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 0.05813149</code></pre>
<p>To access the details of the weights: e.g. list the neighbors of a specified observation:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">nbrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_neighbors.html">get_neighbors</a></span><span class="op">(</span><span class="va">queen_w</span>, idx <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"\nNeighbors of the 1-st observation are:"</span>, <span class="va">nbrs</span><span class="op">)</span></code></pre></div>
<pre><code>## 
## Neighbors of the 1-st observation are: 36 37 67 69</code></pre>
<p>To compute the spatial lag of a specified observation by passing the values of the selected variable:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spatial_lag.html">spatial_lag</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="st">'Crm_prs'</span><span class="op">]</span><span class="op">)</span>
<span class="va">lag</span></code></pre></div>
<pre><code>##    Spatial.Lag
## 1     23047.50
## 2     26919.67
## 3     26195.50
## 4     14401.25
## 5     15038.67
## 6     15749.00
## 7     22111.67
## 8     13672.33
## 9     22859.20
## 10    11475.20
## 11    12200.14
## 12    13278.67
## 13    24734.00
## 14    11752.83
## 15    17992.60
## 16    21974.40
## 17    26711.00
## 18    19344.00
## 19    23696.71
## 20    25108.67
## 21    21643.17
## 22    18306.00
## 23    24280.00
## 24    14451.60
## 25    21047.67
## 26    21421.33
## 27    25961.50
## 28    10869.83
## 29    13415.67
## 30    17172.17
## 31    20238.25
## 32    12504.25
## 33    26723.00
## 34    21772.83
## 35    26462.20
## 36    19252.00
## 37    24683.20
## 38    20607.25
## 39    24412.00
## 40    19373.71
## 41    16000.20
## 42    23993.25
## 43    20337.86
## 44    16818.67
## 45    17113.83
## 46    13013.00
## 47    22133.00
## 48    24093.75
## 49    25661.67
## 50    22190.17
## 51    29030.00
## 52    16951.00
## 53    24509.00
## 54    24982.75
## 55    19491.50
## 56    24176.00
## 57    27639.67
## 58    21274.33
## 59    24510.33
## 60    30166.00
## 61    23459.00
## 62    16184.00
## 63    18002.00
## 64    10910.00
## 65    16251.25
## 66    15572.00
## 67    25884.25
## 68    23020.60
## 69    26495.00
## 70    24690.50
## 71    17339.00
## 72    25522.33
## 73    18970.00
## 74    19701.83
## 75    21841.00
## 76    24520.40
## 77    14025.80
## 78    14565.17
## 79    13306.67
## 80    12579.00
## 81    21529.50
## 82    23474.50
## 83    24373.17
## 84    19900.50
## 85    23373.60</code></pre>
</div>
</div>
<div id="rook-contiguity-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#rook-contiguity-weights" class="anchor"></a>3.2 Rook Contiguity Weights</h3>
<p>The rook criterion defines neighbors by the existence of a common edge between two spatial units. To create a Rook contiguity weights, one can call function:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/rook_weights.html">rook_weights</a></span><span class="op">(</span><span class="va">sf_obj</span>, order<span class="op">=</span><span class="fl">1</span>,include_lower_order<span class="op">=</span><span class="va">False</span>, precision_threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></code></pre></div>
<p>For example, to create a Rook contiguity weights using the sf object <code>guerry</code>:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">rook_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rook_weights.html">rook_weights</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">rook_w</span><span class="op">)</span></code></pre></div>
<pre><code>##                      name              value
## 1 number of observations:                 85
## 2          is symmetric:                TRUE
## 3               sparsity: 0.0581314878892734
## 4        # min neighbors:                  2
## 5        # max neighbors:                  8
## 6       # mean neighbors:   4.94117647058824
## 7     # median neighbors:                  5
## 8           has isolates:              FALSE</code></pre>
<p>The weights we created are in memory. To save the weights to a file, one can call the function:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/save_weights.html">save_weights</a></span><span class="op">(</span><span class="va">gda_w</span>, <span class="va">id_variable</span>, <span class="va">out_path</span>, layer_name <span class="op">=</span> <span class="st">""</span><span class="op">)</span></code></pre></div>
<p>The <code>id_variable</code> defines the unique value of each observation when saving a weights file</p>
<p>The <code>layer_name</code> is the layer name of loaded dataset. For a ESRI shapefile, the layer name is the file name without the suffix (e.g. Guerry).</p>
<p>For example, using Guerry dataset, the column “CODE_DE” can be used as a key to save a weights file:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/save_weights.html">save_weights</a></span><span class="op">(</span><span class="va">rook_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="st">'CODE_DE'</span><span class="op">]</span>, out_path <span class="op">=</span> <span class="st">'/Users/xun/Downloads/Guerry_r.gal'</span>, 
             layer_name <span class="op">=</span> <span class="st">'Guerry'</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="distance-based-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#distance-based-weights" class="anchor"></a>3.3 Distance Based Weights</h3>
<p>The most straightforward spatial weights matrix constructed from a distance measure is obtained when i and j are considered neighbors whenever j falls within a critical distance band from i. In order to start the distance based neighbors, we first need to compute a threshold value. <code>rgeoda</code> provides a function <code>min_distthreshold</code> to help you find a optimized distance threshold that guarantees that every observation has at least one neighbor:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">min_distthreshold</span>(GeoDa gda, bool <span class="at">is_arc =</span> False, <span class="at">is_mile =</span> True)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>To create a Distance based weights, one can call the <span class="cf">function</span> <span class="st">`</span><span class="at">distance_weights</span><span class="st">`</span><span class="sc">:</span></span></code></pre></div>
<p>Then, with this distance threshold, we can create a distance-band weights using the function:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/distance_weights.html">distance_weights</a></span><span class="op">(</span><span class="va">geoda_obj</span>, <span class="va">dist_thres</span>, power<span class="op">=</span><span class="fl">1.0</span>,  is_inverse<span class="op">=</span><span class="va">False</span>, is_arc<span class="op">=</span><span class="va">False</span>, is_mile<span class="op">=</span><span class="va">True</span><span class="op">)</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">dist_thres</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/min_distthreshold.html">min_distthreshold</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>
<span class="va">dist_thres</span></code></pre></div>
<pre><code>## [1] 96726.14</code></pre>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">dist_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/distance_weights.html">distance_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="va">dist_thres</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">dist_w</span><span class="op">)</span></code></pre></div>
<pre><code>##                      name              value
## 1 number of observations:                 85
## 2          is symmetric:                TRUE
## 3               sparsity: 0.0434602076124567
## 4        # min neighbors:                  1
## 5        # max neighbors:                  7
## 6       # mean neighbors:   3.69411764705882
## 7     # median neighbors:                  4
## 8           has isolates:              FALSE</code></pre>
</div>
<div id="k-nearest-neighbor-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#k-nearest-neighbor-weights" class="anchor"></a>3.4 K-Nearest Neighbor Weights</h3>
<p>A special case of distance based weights is K-Nearest neighbor weights, in which every obersvation will have exactly k neighbors. It can be used to avoid the problem of isolate in distance-band weights when a smaller cut-off distance is used. To create a KNN weights, we can call the function <code>knn_weights</code>:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/knn_weights.html">knn_weights</a></span><span class="op">(</span><span class="va">gda</span>, <span class="va">k</span>, power <span class="op">=</span> <span class="fl">1.0</span>,is_inverse <span class="op">=</span> <span class="va">False</span>, is_arc <span class="op">=</span> <span class="va">False</span>, is_mile <span class="op">=</span> <span class="va">True</span><span class="op">)</span></code></pre></div>
<p>For example, to create a 6-nearest neighbor weights using Guerry:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">knn6_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/knn_weights.html">knn_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="fl">6</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">knn6_w</span><span class="op">)</span></code></pre></div>
<pre><code>##                      name              value
## 1 number of observations:                 85
## 2          is symmetric:               FALSE
## 3               sparsity: 0.0705882352941176
## 4        # min neighbors:                  6
## 5        # max neighbors:                  6
## 6       # mean neighbors:                  6
## 7     # median neighbors:                  6
## 8           has isolates:              FALSE</code></pre>
</div>
<div id="kernel-weights" class="section level3">
<h3 class="hasAnchor">
<a href="#kernel-weights" class="anchor"></a>3.5 Kernel Weights</h3>
<p>Kernel weights apply kernel function to determine the distance decay in the derived continuous weights kernel. The kernel weights are defined as a function K(z) of the ratio between the distance dij from i to j, and the bandwidth hi, with z=dij/hi.</p>
<p>The kernel functions include</p>
<ul>
<li>triangular</li>
<li>uniform</li>
<li>quadratic</li>
<li>epanechnikov</li>
<li>quartic</li>
<li>gaussian</li>
</ul>
<p>Two functions are provided in <code>rgeoda</code> to create kernel weights.</p>
<div id="use-kernel_weights-for-kernel-weights-with-adaptive-bandwidth" class="section level4">
<h4 class="hasAnchor">
<a href="#use-kernel_weights-for-kernel-weights-with-adaptive-bandwidth" class="anchor"></a>Use <code>kernel_weights</code> for Kernel Weights with adaptive bandwidth</h4>
<p>To create a kernel weights with fixed bandwith:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">bandwidth</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/min_distthreshold.html">min_distthreshold</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>
<span class="va">kernel_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/kernel_weights.html">kernel_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="va">bandwidth</span>, kernel_method <span class="op">=</span> <span class="st">"uniform"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">kernel_w</span><span class="op">)</span></code></pre></div>
<pre><code>##                      name              value
## 1 number of observations:                 85
## 2          is symmetric:               FALSE
## 3               sparsity: 0.0434602076124567
## 4        # min neighbors:                  1
## 5        # max neighbors:                  7
## 6       # mean neighbors:   3.69411764705882
## 7     # median neighbors:                  4
## 8           has isolates:              FALSE</code></pre>
<p>The arguments <code>is_inverse</code>, <code>power</code>, <code>is_arc</code> and <code>is_mile</code> are the same with the distance based weights. Additionally, <code>kernel_weights</code> has another argument that user can specify:</p>
<pre><code>use_kernel_diagonals    
(optional) FALSE (default) or TRUE, apply kernel on the diagonal of weights matrix</code></pre>
</div>
<div id="use-kernel_knn_weights-for-kernel-weights-with-adaptive-bandwidth" class="section level4">
<h4 class="hasAnchor">
<a href="#use-kernel_knn_weights-for-kernel-weights-with-adaptive-bandwidth" class="anchor"></a>Use <code>kernel_knn_weights</code> for Kernel Weights with adaptive bandwidth</h4>
<p>To create a kernel weights with adaptive bandwidth or using max Knn distance as bandwidth:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">adptkernel_w</span> <span class="op">=</span> <span class="fu"><a href="../reference/kernel_knn_weights.html">kernel_knn_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="fl">6</span>, <span class="st">"uniform"</span><span class="op">)</span>

<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">adptkernel_w</span><span class="op">)</span></code></pre></div>
<pre><code>##                      name              value
## 1 number of observations:                 85
## 2          is symmetric:               FALSE
## 3               sparsity: 0.0588235294117647
## 4        # min neighbors:                  5
## 5        # max neighbors:                  5
## 6       # mean neighbors:                  5
## 7     # median neighbors:                  5
## 8           has isolates:              FALSE</code></pre>
<p>This kernel weights function two more arguments that user can specify:</p>
<pre><code>adaptive_bandwidth  
(optional) TRUE (default) or FALSE: TRUE use adaptive bandwidth calculated using distance of k-nearest neithbors, FALSE use max distance of all observation to their k-nearest neighbors

use_kernel_diagonals    
(optional) FALSE (default) or TRUE, apply kernel on the diagonal of weights matrix</code></pre>
</div>
</div>
</div>
<div id="local-indicators-of-spatial-associationlisa" class="section level2">
<h2 class="hasAnchor">
<a href="#local-indicators-of-spatial-associationlisa" class="anchor"></a>4 Local Indicators of Spatial Association–LISA</h2>
<p><code>rgeoda</code> provides following methods for local spatial autocorrelation statistics:</p>
<ul>
<li>Local Moran: local_moran(), local_moran_eb()</li>
<li>Local Geary: local_geary(), local_multigeary()</li>
<li>Local Getis-Ord statistics: local_g() and local_gstar()</li>
<li>Local Join Count: local_joincount(), local_bijoincount(), local_multijoincount()</li>
<li>Quantile LISA: local_quantilelisa(), local_multiquantilelisa()</li>
<li>Local Neighbor Match Test: neighbor_match_test()</li>
</ul>
<p>For more information about the local spatial autocorrelation statisticis, please read Dr. Luc Anselin’s lab notes: <a href="http://geodacenter.github.io/workbook/6a_local_auto/lab6a.html" class="uri">http://geodacenter.github.io/workbook/6a_local_auto/lab6a.html</a>.</p>
<div id="local-moran" class="section level3">
<h3 class="hasAnchor">
<a href="#local-moran" class="anchor"></a>4.1 Local Moran</h3>
<p>The Local Moran statistic is a method to identify local clusters and local spatial outliers. For example, we can call the function <code><a href="../reference/local_moran.html">local_moran()</a></code> with the created Queen weights and the data “crm_prp = guerry[‘Crm_prp’]” as input parameters:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">crm_prp</span> <span class="op">=</span> <span class="va">guerry</span><span class="op">[</span><span class="st">"Crm_prp"</span><span class="op">]</span>
<span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span></code></pre></div>
<p>The <code><a href="../reference/local_moran.html">local_moran()</a></code> function will return a <code>lisa</code> object, and we can access its values/results of lisa computation using the following functions:</p>
<ul>
<li>lisa_clusters(): Get the local cluster indicators returned from LISA computation.</li>
<li>lisa_colors(): Get the cluster colors of LISA computation.</li>
<li>lisa_labels(): Get the cluster labels of LISA computation.</li>
<li>lisa_values(): Get the local spatial autocorrelation values returned from LISA computation.</li>
<li>lisa_num_nbrs(): Get the number of neighbors of every observations in LISA computation.</li>
<li>lisa_pvalues(): Get the local pseudo-p values of significance returned from LISA computation.</li>
<li>lisa_fdr(): Get the False Discovery Rate (FDR) in LISA.</li>
<li>lisa_bo(): Get the False Discovery Rate (FDR) in LISA.</li>
</ul>
<p>For example, we can call the function <code><a href="../reference/lisa_values.html">lisa_values()</a></code> to get the values of the local Moran:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lms</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_values.html">lisa_values</a></span><span class="op">(</span>gda_lisa <span class="op">=</span> <span class="va">lisa</span><span class="op">)</span>
<span class="va">lms</span></code></pre></div>
<pre><code>##  [1]  0.0154319783  0.3270633224  0.0212952962  0.0046105448 -0.0028342407
##  [6]  0.4149377158 -0.1379463091  0.0998657692  0.2823176310  0.1218745112
## [11] -0.0951205417  0.0326111938  0.3878324535  1.1888723840 -0.6452792226
## [16] -0.3096492740  0.3662775143  2.0375343539 -0.0050154800  0.0697110572
## [21]  2.2720355722  0.2886391551 -0.0070189726 -0.0009906605  0.9517469793
## [26]  0.7648322095  0.0432039929 -0.0045362842 -0.0964911860  0.0952360887
## [31]  0.0100895206 -0.0109401003 -0.0544245927 -0.0345553975  0.0887531916
## [36]  0.0954232056  0.0383617454 -0.1776714441  0.1638208393  1.2309154898
## [41]  2.9077203402 -0.0396340261  0.4458735227  0.2491123240  0.0905643622
## [46] -0.6212977834 -0.0308773407  0.0375870399  0.2270376112 -0.0918254739
## [51] -0.0112400086  0.1085584763 -0.0055113129 -0.0027097589  0.7235016208
## [56]  0.0163129939  0.4246564560  0.3787307767 -0.0597158189  0.5050011802
## [61]  2.7632125275  0.0656510809  0.1771899330 -0.0572150317  0.4943795537
## [66]  0.2870386197 -1.4593300774 -0.0055305930  0.4895990016 -0.0324125662
## [71]  2.1366499813  0.9041683235  0.7053678641  1.4098290925  0.0051652159
## [76]  0.2238144189 -0.1621373954  0.0195632289 -0.3233724187 -0.0337778226
## [81]  0.0118189869 -0.1164679533 -0.5699624657 -0.0859634996  0.2085373916</code></pre>
<p>To get the pseudo-p values of significance of local Moran computation:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pvals</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span>
<span class="va">pvals</span></code></pre></div>
<pre><code>##  [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 0.461
## [13] 0.248 0.015 0.178 0.166 0.124 0.003 0.456 0.346 0.053 0.145 0.431 0.425
## [25] 0.005 0.037 0.464 0.395 0.138 0.316 0.495 0.431 0.359 0.129 0.295 0.058
## [37] 0.090 0.231 0.258 0.018 0.026 0.455 0.073 0.057 0.222 0.023 0.369 0.338
## [49] 0.282 0.359 0.483 0.252 0.450 0.434 0.138 0.327 0.063 0.005 0.097 0.292
## [61] 0.001 0.217 0.237 0.126 0.145 0.344 0.008 0.340 0.079 0.300 0.033 0.142
## [73] 0.001 0.001 0.460 0.005 0.212 0.384 0.110 0.409 0.455 0.353 0.006 0.287
## [85] 0.128</code></pre>
<p>To get the cluster indicators of local Moran computation:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">cats</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">lisa</span>, cutoff <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span>
<span class="va">cats</span></code></pre></div>
<pre><code>##  [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
## [39] 0 1 1 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 0 0 0 0 0 3 0 0 0 2 0 2 2 0 2
## [77] 0 0 0 0 0 0 3 0 0</code></pre>
<p>The predefined values of the indicators of LISA cluster are:</p>
<pre><code>0 Not significant
1 High-High
2 Low-Low
3 High-Low
4 Low-High
5 Undefined
6 Isolated</code></pre>
<p>which can be accessed via the function <code><a href="../reference/lisa_labels.html">lisa_labels()</a></code>:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lbls</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_labels.html">lisa_labels</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span>
<span class="va">lbls</span></code></pre></div>
<pre><code>## [1] "Not significant" "High-High"       "Low-Low"         "Low-High"       
## [5] "High-Low"        "Undefined"       "Isolated"</code></pre>
<p>By default, the <code><a href="../reference/local_moran.html">local_moran()</a></code> function will run with some default parameters, e.g.:</p>
<pre><code>significance_cutoff: 0.05
permutation: 999
permutation_method: 'complete'
cpu_threads: 6
seed (for random number generator): 123456789</code></pre>
<p>, which are identical to GeoDa desktop software so to replicate the results in GeoDa software. You can set different values when calling the lisa functions.</p>
<p>For example, re-run the above local Moran example using 9,999 permutations.</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span>, permutations <span class="op">=</span> <span class="fl">9999</span><span class="op">)</span></code></pre></div>
<p>Then, we can use the same <code>lisa</code> object to get the new results after 9,999 permutations:</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">pvals</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span>
<span class="va">pvals</span></code></pre></div>
<pre><code>##  [1] 0.4187 0.1265 0.0004 0.4679 0.4545 0.0728 0.2312 0.3071 0.3115 0.3088
## [11] 0.2187 0.4834 0.2686 0.0102 0.2024 0.1789 0.1320 0.0020 0.4558 0.3519
## [21] 0.0479 0.1376 0.4441 0.4195 0.0032 0.0388 0.4733 0.4187 0.1278 0.3300
## [31] 0.4939 0.4427 0.3393 0.1419 0.2714 0.0606 0.0724 0.2247 0.2628 0.0185
## [41] 0.0214 0.4899 0.0719 0.0589 0.2288 0.0189 0.3759 0.3217 0.2812 0.3735
## [51] 0.4695 0.2743 0.4518 0.4286 0.1471 0.3222 0.0647 0.0025 0.0917 0.2812
## [61] 0.0001 0.2419 0.2462 0.1266 0.1270 0.3553 0.0094 0.3123 0.0724 0.2975
## [71] 0.0307 0.1320 0.0001 0.0002 0.4633 0.0056 0.2162 0.3681 0.1335 0.4069
## [81] 0.4536 0.3547 0.0035 0.3096 0.1277</code></pre>
<p><code>rgeoda</code> uses <code>GeoDa</code> C++ code, in which multi-threading is used to accelerate the computation of LISA. We can use the argument <code>ncpu</code> to specify how many threads to run the computation:</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span>, cpu_threads <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></code></pre></div>
<p>Get the False Discovery Rate value based on current pseudo-p values:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fdr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_fdr.html">lisa_fdr</a></span><span class="op">(</span><span class="va">lisa</span>, <span class="fl">0.05</span><span class="op">)</span>
<span class="va">fdr</span></code></pre></div>
<pre><code>## [1] 0.0005882353</code></pre>
<p>Then, one can set the FDR value as the cutoff p-value to filter the cluster results:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">cat_fdr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">lisa</span>, cutoff <span class="op">=</span> <span class="va">fdr</span><span class="op">)</span>
<span class="va">cat_fdr</span></code></pre></div>
<pre><code>##  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [77] 0 0 0 0 0 0 0 0 0</code></pre>
</div>
<div id="local-geary" class="section level3">
<h3 class="hasAnchor">
<a href="#local-geary" class="anchor"></a>4.2 Local Geary</h3>
<p>Local Geary is a type of LISA that focuses on squared differences/dissimilarity. A small value of the local geary statistics suggest positive spatial autocorrelation, whereas large values suggest negative spatial autocorrelation. For more details, please read: <a href="http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#local-geary" class="uri">http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#local-geary</a></p>
<p>For example, we can call the function local_geary() with the created Queen weights and the data “crm_prp” as input parameters:</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">geary_crmprp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_geary.html">local_geary</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span></code></pre></div>
<p>To get the cluster indicators of the local Geary computation:</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">geary_crmprp</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0 2 4 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 2 2 0 0 0 0 0 0 0 4 0 0 0 0
## [39] 0 0 1 0 0 0 1 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2 0 0
## [77] 0 0 0 0 0 0 4 0 0</code></pre>
<p>To get the pseudo-p values of the local Geary computation:</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">geary_crmprp</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0.398 0.027 0.025 0.126 0.017 0.314 0.610 0.141 0.284 0.110 0.559 0.456
## [13] 0.211 0.255 0.226 0.211 0.089 0.054 0.182 0.017 0.030 0.216 0.395 0.105
## [25] 0.024 0.033 0.089 0.416 0.504 0.059 0.380 0.254 0.211 0.048 0.113 0.154
## [37] 0.160 0.571 0.310 0.093 0.009 0.130 0.128 0.178 0.039 0.088 0.076 0.319
## [49] 0.291 0.438 0.043 0.464 0.177 0.099 0.100 0.232 0.141 0.317 0.615 0.208
## [61] 0.198 0.299 0.084 0.634 0.148 0.423 0.060 0.108 0.293 0.257 0.032 0.102
## [73] 0.057 0.003 0.706 0.560 0.605 0.066 0.320 0.391 0.175 0.601 0.007 0.365
## [85] 0.238</code></pre>
</div>
<div id="multivariate-local-geary" class="section level3">
<h3 class="hasAnchor">
<a href="#multivariate-local-geary" class="anchor"></a>4.3 Multivariate Local Geary:</h3>
<p>To apply multivariate local geary, we need to define a string with the variable names and use this string to extract the relevant subset from the data frame. For example, we apply multivariate local geary on variables “Crm_prs”, “Crm_prp”, “Litercy”, “Donatns”, “Infants” and “Suicids”:</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">data</span> <span class="op">&lt;-</span><span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">'Crm_prs'</span>,<span class="st">'Crm_prp'</span>,<span class="st">'Litercy'</span>,<span class="st">'Donatns'</span>,<span class="st">'Infants'</span>,<span class="st">'Suicids'</span><span class="op">)</span><span class="op">]</span>
<span class="va">multigeary</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_multigeary.html">local_multigeary</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span><span class="op">)</span></code></pre></div>
<p>To get the cluster indicators of the local Geary computation:</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">multigeary</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0 1 1 1 0 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 1 0 1 0 0 1 0 0 0 0 0
## [39] 1 0 1 2 1 1 1 0 0 0 1 1 1 0 1 1 0 0 1 1 0 1 1 0 1 0 1 1 0 1 0 1 1 0 1 1 0 1
## [77] 1 1 1 1 0 1 0 1 1</code></pre>
</div>
<div id="local-getis-ord-statistics" class="section level3">
<h3 class="hasAnchor">
<a href="#local-getis-ord-statistics" class="anchor"></a>4.4 Local Getis-Ord Statistics</h3>
<p>There are two types of local Getis-Ord statistics: one is computing a ratio of the weighted average of the values in the neighboring locations, not including the value at the location; while another type of statistic includes the value at the location in both numerator and denominator. For more details, please read: <a href="http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#getis-ord-statistics" class="uri">http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#getis-ord-statistics</a></p>
<p>A value larger than the mean suggests a high-high cluster or hot spot, a value smaller than the mean indicates a low-low cluster or cold spot.</p>
<p>For example, we can call the function <code><a href="../reference/local_g.html">local_g()</a></code> with the created Queen weights and the data “crm_prp” as input parameters:</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">localg_crmprp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_g.html">local_g</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span></code></pre></div>
<p>To get the cluster indicators of the local G computation:</p>
<div class="sourceCode" id="cb70"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">localg_crmprp</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0
## [39] 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 0 0 0 0 0 1 0 0 0 2 0 2 2 0 2
## [77] 0 0 0 0 0 0 1 0 0</code></pre>
<p>To get the pseudo-p values of the local G computation:</p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">localg_crmprp</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 0.461
## [13] 0.248 0.015 0.178 0.166 0.124 0.003 0.456 0.346 0.053 0.145 0.432 0.425
## [25] 0.005 0.037 0.464 0.395 0.138 0.316 0.495 0.431 0.359 0.129 0.295 0.058
## [37] 0.090 0.231 0.258 0.018 0.026 0.455 0.073 0.057 0.222 0.023 0.369 0.338
## [49] 0.282 0.359 0.483 0.252 0.450 0.434 0.138 0.327 0.063 0.005 0.097 0.292
## [61] 0.001 0.217 0.237 0.127 0.145 0.344 0.008 0.340 0.079 0.300 0.033 0.142
## [73] 0.001 0.001 0.461 0.005 0.212 0.384 0.110 0.409 0.455 0.353 0.006 0.287
## [85] 0.128</code></pre>
<p>For the second type of local Getis-Ord statistics, we can call the function <code><a href="../reference/local_gstar.html">local_gstar()</a></code> with the created Queen weights and the data “crm_prp” as input parameters:</p>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">localgstar_crmprs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_gstar.html">local_gstar</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span>
<span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">localgstar_crmprs</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 0.461
## [13] 0.248 0.015 0.178 0.166 0.124 0.003 0.456 0.346 0.053 0.145 0.432 0.425
## [25] 0.005 0.037 0.464 0.395 0.138 0.316 0.495 0.431 0.359 0.129 0.295 0.058
## [37] 0.090 0.231 0.258 0.018 0.026 0.455 0.073 0.057 0.222 0.023 0.369 0.338
## [49] 0.282 0.359 0.483 0.252 0.450 0.434 0.138 0.327 0.063 0.005 0.097 0.292
## [61] 0.001 0.217 0.237 0.127 0.145 0.344 0.008 0.340 0.079 0.300 0.033 0.142
## [73] 0.001 0.001 0.461 0.005 0.212 0.384 0.110 0.409 0.455 0.353 0.006 0.287
## [85] 0.128</code></pre>
</div>
<div id="local-join-count" class="section level3">
<h3 class="hasAnchor">
<a href="#local-join-count" class="anchor"></a>4.5 Local Join Count</h3>
<p>Local Join Count is a method to identify local clusters for binary data by using a local version of the so-called BB join count statistic. The statistic is only meaningful for those observations with value 1. For more details, please read <a href="http://geodacenter.github.io/workbook/6d_local_discrete/lab6d.html" class="uri">http://geodacenter.github.io/workbook/6d_local_discrete/lab6d.html</a></p>
<p>For example, we can call the function <code><a href="../reference/local_joincount.html">local_joincount()</a></code> with a Queen weights and the data “TopCrm”, which is a set of binary (0,1) values, as input parameters:</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">top_crm</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="st">'TopCrm'</span><span class="op">]</span>
<span class="va">localjc_crm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_joincount.html">local_joincount</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">top_crm</span><span class="op">)</span></code></pre></div>
<p>To get the pseudo-p values of the local Join Count computation:</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">localjc_crm</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0.395 0.085 0.094    NA    NA    NA 0.255    NA    NA    NA    NA    NA
## [13]    NA    NA    NA    NA    NA    NA 0.170 0.242 0.394    NA    NA    NA
## [25]    NA    NA 0.111    NA    NA    NA    NA    NA    NA 0.095    NA    NA
## [37] 0.189    NA    NA 0.284    NA    NA    NA    NA    NA    NA 0.218 0.378
## [49]    NA 0.367 0.037 0.233 0.174 0.392    NA 0.282 0.028 0.370 0.298 0.106
## [61]    NA    NA    NA    NA    NA    NA    NA    NA 0.009 0.325    NA    NA
## [73]    NA    NA    NA 0.041    NA    NA    NA    NA    NA    NA    NA    NA
## [85]    NA</code></pre>
<p>To get the cluster indicators of the local Join Count computation:</p>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">localjc_crm</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [39] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1
## [77] 0 0 0 0 0 0 0 0 0</code></pre>
<p>To get the number of neighbors of the local Join Count computation:</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_num_nbrs.html">lisa_num_nbrs</a></span><span class="op">(</span><span class="va">localjc_crm</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 4 6 6 4 3 7 3 3 5 5 7 3 3 6 5 5 6 6 7 3 6 7 2 5 6 6 2 6 6 6 4 4 6 6 5 6 5 4
## [39] 6 7 5 4 7 6 6 5 8 4 6 6 5 4 5 4 2 6 3 6 6 2 6 3 3 2 4 2 4 5 7 6 2 3 8 6 5 5
## [77] 5 6 3 6 4 6 6 6 5</code></pre>
<div id="bivariate-and-multivariate-local-join-count" class="section level4">
<h4 class="hasAnchor">
<a href="#bivariate-and-multivariate-local-join-count" class="anchor"></a>4.6 Bivariate and Multivariate Local Join Count:</h4>
<p>Bivariate Local Join Count means, in a bivariate local join count, the two events cannot happen in the same location. It is also called “no-colocation” join count. To demonstrate this function, we manually create a new variable:</p>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">inv_crm</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">[</span>,<span class="st">"TopCrm"</span><span class="op">]</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="co"># create no-location case</span>
<span class="va">guerry</span><span class="op">[</span><span class="st">'Inv_Crm'</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">inv_crm</span></code></pre></div>
<p>Now, top_crm and inv_crm are no-colocation bivariate cases. Then, we apply the local_bijoicount():</p>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">jc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_bijoincount.html">local_bijoincount</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">'TopCrm'</span>, <span class="st">'Inv_Crm'</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></code></pre></div>
<p>In case of co-location, a warning message will be raised “The bivariate local join count only applies on two variables with no-colocation.” , and one can use pygeoda.local_multijoincount() for co-location case.</p>
<p>To get the cluster indicators of the multivariate local join count computation:</p>
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">jc</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0.106 0.013 0.017    NA    NA    NA 0.035    NA    NA    NA    NA    NA
## [13]    NA    NA 0.135    NA    NA    NA 0.040 0.024 0.296    NA    NA    NA
## [25]    NA    NA    NA    NA    NA    NA 0.208    NA    NA 0.398    NA    NA
## [37] 0.047    NA    NA 0.407    NA    NA    NA    NA    NA    NA 0.487 0.098
## [49]    NA 0.292 0.007 0.416 0.035 0.101    NA 0.076    NA 0.305 0.086    NA
## [61]    NA    NA    NA    NA    NA    NA    NA    NA 0.001 0.100    NA    NA
## [73]    NA    NA    NA 0.005    NA    NA    NA    NA    NA    NA    NA    NA
## [85]    NA</code></pre>
<p>To get the cluster indicators of the local Join Count computation:</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">jc</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
## [39] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1
## [77] 0 0 0 0 0 0 0 0 0</code></pre>
<p>Co-location Local Join Count is for where two or more events happen in the same location. Therefore, the function local_multijoincount takes a list of variables with 0/1 values as the input parameter:</p>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">bin_data</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">'TopWealth'</span>,<span class="st">'TopWealth'</span>, <span class="st">'TopLit'</span><span class="op">)</span><span class="op">]</span> 
<span class="va">jc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_multijoincount.html">local_multijoincount</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">bin_data</span><span class="op">)</span></code></pre></div>
<p>To get the cluster indicators of the multivariate local join count computation:</p>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">jc</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1]    NA    NA    NA 0.256 0.205    NA    NA    NA    NA    NA    NA    NA
## [13]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [25]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [37] 0.319    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [49]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [61]    NA 0.175 0.192    NA    NA    NA    NA 0.051    NA    NA    NA    NA
## [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA 0.348
## [85]    NA</code></pre>
</div>
</div>
<div id="quantile-lisa" class="section level3">
<h3 class="hasAnchor">
<a href="#quantile-lisa" class="anchor"></a>4.7 Quantile LISA</h3>
<p>The quantile local spatial autocorrelation converte the continuous variable to a binary variable that takes the value of 1 for a specific quantile. Then appaly a local join count to the data converted. Two input parameters, k and q, need to be specified in the function pygeoda.quantile_lisa(): k is the number of quantiles (k &gt; 2), and the q is the index of selected quantile lisa ranging from 1 to k.</p>
<p>For example, the examples in section 4.1.5 can be simply implemented as</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">qsa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_quantilelisa.html">local_quantilelisa</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span>, <span class="fl">5</span>, <span class="fl">5</span><span class="op">)</span></code></pre></div>
<p>To get the p-values and cluster indicators of the quantile LISA computation:</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0.419    NA    NA    NA    NA 0.376    NA 0.442    NA 0.257    NA    NA
## [13]    NA 0.082 0.348    NA 0.277 0.010    NA    NA 0.090 0.387    NA    NA
## [25]    NA    NA    NA    NA    NA 0.271    NA 0.447    NA    NA    NA    NA
## [37]    NA    NA    NA 0.026 0.003    NA    NA    NA    NA    NA    NA    NA
## [49]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [61] 0.001    NA 0.465    NA    NA    NA    NA    NA 0.378    NA    NA    NA
## [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [85]    NA</code></pre>
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [39] 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [77] 0 0 0 0 0 0 0 0 0</code></pre>
<p>Multivariate Quantile LISA</p>
<p>For multiple variables, the Quantile LISA can automatiaclly detect if it is the case of no-colocation, in which local_bijoincount() will be called internally, or the case of co-location, in which local_multijoincount() will be called internally.</p>
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">qsa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_multiquantilelisa.html">local_multiquantilelisa</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"TopCrm"</span>, <span class="st">"TopLit"</span><span class="op">)</span><span class="op">]</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>To get the p-values and cluster indicators of the quantile LISA computation:</p>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1]    NA 0.122    NA    NA    NA    NA 0.023    NA    NA    NA    NA    NA
## [13]    NA    NA    NA    NA    NA    NA 0.137    NA    NA    NA    NA    NA
## [25]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [37] 0.412    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [49]    NA 0.111    NA 0.323 0.012    NA    NA    NA    NA 0.465    NA    NA
## [61]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA
## [85]    NA</code></pre>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></code></pre></div>
<pre><code>##  [1] 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
## [77] 0 0 0 0 0 0 0 0 0</code></pre>
</div>
</div>
<div id="spatial-clustering" class="section level2">
<h2 class="hasAnchor">
<a href="#spatial-clustering" class="anchor"></a>5 Spatial Clustering</h2>
<p>Spatial clustering aims to group of a large number of geographic areas or points into a smaller number of regions based on similiarities in one or more variables. Spatially constrained clustering is needed when clusters are required to be spatially contiguous.</p>
<p>There are three different approaches explicitly incorporate the contiguity constraint in the optimization process: SKATER, Redcap and Max-p. For more details, please read: * <a href="http://geodacenter.github.io/workbook/9c_spatial3/lab9c.html" class="uri">http://geodacenter.github.io/workbook/9c_spatial3/lab9c.html</a> * <a href="http://geodacenter.github.io/workbook/9d_spatial4/lab9d.html" class="uri">http://geodacenter.github.io/workbook/9d_spatial4/lab9d.html</a></p>
<p>For example, to apply spatial clustering on the Guerry dataset, we use the queen weights to define the spatial contiguity and select 6 variables for similarity measure: “Crm_prs”, “Crm_prp”, “Litercy”, “Donatns”, “Infants”, “Suicids”.</p>
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">data</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">'Crm_prs'</span>,<span class="st">'Crm_prp'</span>,<span class="st">'Litercy'</span>,<span class="st">'Donatns'</span>,<span class="st">'Infants'</span>,<span class="st">'Suicids'</span><span class="op">)</span><span class="op">]</span></code></pre></div>
<div id="skater" class="section level3">
<h3 class="hasAnchor">
<a href="#skater" class="anchor"></a>5.1 SKATER</h3>
<p>The Spatial C(K)luster Analysis by Tree Edge Removal(SKATER) algorithm introduced by Assuncao et al. (2006) is based on the optimal pruning of a minimum spanning tree that reflects the contiguity structure among the observations. It provides an optimized algorithm to prune to tree into several clusters that their values of selected variables are as similar as possible.</p>
<p>The <code>rgeoda</code>’s SKATER function is:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="fu">skater</span>(k, w, data, <span class="at">distance_method=</span><span class="st">'euclidean'</span>, <span class="at">bound_vals =</span> [],  <span class="at">min_bound =</span> <span class="dv">0</span>, <span class="at">random_seed=</span><span class="dv">123456789</span>)</span></code></pre></div>
<p>For example, to create 4 spatially contiguous clusters using Guerry dataset, the queen weights and the values of the 6 selected variables:</p>
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">guerry_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/skater.html">skater</a></span><span class="op">(</span><span class="fl">4</span>, <span class="va">queen_w</span>, <span class="va">data</span><span class="op">)</span>
<span class="va">guerry_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 3 2 3 1 1 1 2 1 2 1 1 1 2 1 1 3 3 3 2 4 3 1 2 1 2 2 4 1 1 1 1 1 4 3 4 1 2 1
## [39] 4 3 3 4 2 1 1 1 4 4 2 2 4 2 2 4 2 3 2 2 4 2 3 1 1 1 2 2 1 2 3 4 2 2 2 2 3 2
## [77] 1 1 1 1 3 3 3 2 2
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 57.89077 59.95242 28.72571 69.38030 62.30781 66.65809
## 
## $`Total within-cluster sum of squares`
## [1] 159.0849
## 
## $`The ratio of between to total sum of squares`
## [1] 0.3156447</code></pre>
<p>This skater() function returns a names list with names “Clusters”, “Total sum of squares”, “Within-cluster sum of squares”, “Total within-cluster sum of squares”, and “The ratio of between to total sum of squares”.</p>
</div>
<div id="redcap" class="section level3">
<h3 class="hasAnchor">
<a href="#redcap" class="anchor"></a>5.2 REDCAP</h3>
<p>REDCAP (Regionalization with dynamically constrained agglomerative clustering and partitioning) is developed by D. Guo (2008). Like SKATER, REDCAP starts from building a spanning tree in 3 different ways (single-linkage, average-linkage, and the complete-linkage). The single-linkage way leads to build a minimum spanning tree. Then, REDCAP provides 2 different ways (first-order and full-order constraining) to prune the tree to find clusters. The first-order approach with a minimum spanning tree is the same as SKATER. In <code>GeoDa</code> and <code>rgeoda</code>, the following methods are provided:</p>
<ul>
<li>First-order and Single-linkage</li>
<li>Full-order and Complete-linkage</li>
<li>Full-order and Average-linkage</li>
<li>Full-order and Single-linkage</li>
<li>Full-order and Wards-linkage</li>
</ul>
<p>For example, to find 4 clusters using the same dataset and weights as above using REDCAP with Full-order and Complete-linkage method:</p>
<div class="sourceCode" id="cb106"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">redcap_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/redcap.html">redcap</a></span><span class="op">(</span><span class="fl">4</span>, <span class="va">queen_w</span>, <span class="va">data</span>, <span class="st">"fullorder-completelinkage"</span><span class="op">)</span>
<span class="va">redcap_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 1 2 1 3 3 1 2 3 2 3 3 3 2 1 1 1 1 1 2 1 1 1 2 3 2 2 1 3 3 3 3 3 1 1 1 3 2 3
## [39] 1 1 4 1 2 3 3 3 1 1 2 2 1 2 2 1 2 1 2 2 1 2 1 3 3 3 2 2 3 2 1 1 2 2 2 2 1 2
## [77] 3 3 3 3 1 1 1 2 2
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 59.33033 55.01580 28.20272 68.58974 61.27232 54.63519
## 
## $`Total within-cluster sum of squares`
## [1] 176.9539
## 
## $`The ratio of between to total sum of squares`
## [1] 0.351099</code></pre>
</div>
<div id="spatially-constrained-hierarchical-clucstering" class="section level3">
<h3 class="hasAnchor">
<a href="#spatially-constrained-hierarchical-clucstering" class="anchor"></a>5.3 Spatially Constrained Hierarchical Clucstering</h3>
<p>Spatially constrained hierarchical clustering is a special form of constrained clustering, where the constraint is based on contiguity (common borders). The method builds up the clusters using agglomerative hierarchical clustering methods: single linkage, complete linkage, average linkage and Ward’s method (a special form of centroid linkage). Meanwhile, it also maintains the spatial contiguity when merging two clusters.</p>
<p>For example, to find 4 spatially constrained clusters using the same dataset and weights as above using Complete-linkage method:</p>
<div class="sourceCode" id="cb108"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">schc_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/schc.html">schc</a></span><span class="op">(</span><span class="fl">4</span>, <span class="va">queen_w</span>, <span class="va">data</span>, <span class="st">"complete"</span><span class="op">)</span>
<span class="va">schc_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 4 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [39] 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [77] 1 1 1 1 1 1 1 1 1
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 78.13831 54.75868 81.49771 63.48675 80.60111 65.74389
## 
## $`Total within-cluster sum of squares`
## [1] 79.77355
## 
## $`The ratio of between to total sum of squares`
## [1] 0.1582809</code></pre>
</div>
<div id="azp" class="section level3">
<h3 class="hasAnchor">
<a href="#azp" class="anchor"></a>5.4 AZP</h3>
<p>The automatic zoning procedure (AZP) was initially outlined in Openshaw (1977) as a way to address some of the consequences of the modifiable areal unit problem (MAUP). In essence, it consists of a heuristic to find the best set of combinations of contiguous spatial units into p regions, minimizing the within-sum of squares as a criterion of homogeneity. The number of regions needs to be specified beforehand, as in most other clustering methods considered so far.</p>
<p><code>rgeoda</code> provides three different heuristic algorithms to find an optimal solution for AZP:</p>
<ul>
<li>greedy</li>
<li>Tabu Search</li>
<li>Simulated Annealing</li>
</ul>
<div id="azp-greedy" class="section level4">
<h4 class="hasAnchor">
<a href="#azp-greedy" class="anchor"></a>5.4.1 AZP greedy</h4>
<p>The original AZP heuristic is a local optimization procedure that cycles through a series of possible swaps between spatial units at the boundary of a set of regions. The process starts with an initial feasible solution, i.e., a grouping of n spatial units into p contiguous regions. This initial solution can be constructed in several different ways. The initial solution must satisfy the contiguity constraints. For example, this can be accomplished by growing a set of contiguous regions from p randomly selected seed units by adding neighboring locations until the contiguity constraint can no longer be met.</p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">azp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/azp_greedy.html">azp_greedy</a></span><span class="op">(</span><span class="fl">5</span>, <span class="va">queen_w</span>, <span class="va">data</span><span class="op">)</span>
<span class="va">azp_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 5 2 3 1 1 1 2 1 2 1 1 1 2 1 4 4 3 4 2 3 3 1 2 1 2 2 3 1 1 1 1 1 3 3 3 1 2 1
## [39] 2 3 1 3 2 1 1 1 3 3 2 2 3 2 2 3 2 3 2 2 3 2 1 1 1 1 2 2 1 2 3 3 2 2 2 2 4 2
## [77] 1 1 1 1 4 4 4 2 2
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 47.20703 60.10165 32.71213 57.69760 59.41673 65.49840
## 
## $`Total within-cluster sum of squares`
## [1] 181.3665
## 
## $`The ratio of between to total sum of squares`
## [1] 0.3598541</code></pre>
</div>
<div id="azp-simulated-annealing" class="section level4">
<h4 class="hasAnchor">
<a href="#azp-simulated-annealing" class="anchor"></a>5.4.2 AZP Simulated Annealing</h4>
<p>To call AZP simulate annealing algorithm, one needs to specify cooling_rate (default: 0.85):</p>
<div class="sourceCode" id="cb112"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">azp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/azp_sa.html">azp_sa</a></span><span class="op">(</span><span class="fl">5</span>, <span class="va">queen_w</span>, <span class="va">data</span>, cooling_rate <span class="op">=</span> <span class="fl">0.85</span><span class="op">)</span>
<span class="va">azp_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 5 2 5 1 1 1 2 1 2 1 1 1 3 5 3 3 4 3 2 3 5 1 2 1 2 2 3 1 1 1 1 1 3 4 4 1 2 1
## [39] 4 5 5 3 2 1 1 1 4 3 2 2 4 2 2 3 2 4 2 2 4 2 5 1 1 1 2 2 1 2 5 4 2 2 2 2 3 2
## [77] 1 1 1 1 3 3 3 2 2
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 55.44537 44.49166 31.26639 44.79846 61.49413 54.25130
## 
## $`Total within-cluster sum of squares`
## [1] 212.2527
## 
## $`The ratio of between to total sum of squares`
## [1] 0.4211363</code></pre>
</div>
<div id="azp-tabu-search" class="section level4">
<h4 class="hasAnchor">
<a href="#azp-tabu-search" class="anchor"></a>5.4.3 AZP Tabu Search</h4>
<p>To call AZP Tabu search algorithm, one needs to specify tabu_length (deafult: 10) , or conv_tabu (default: 10):</p>
<div class="sourceCode" id="cb114"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">azp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/azp_tabu.html">azp_tabu</a></span><span class="op">(</span><span class="fl">5</span>, <span class="va">queen_w</span>, <span class="va">data</span>, tabu_length <span class="op">=</span> <span class="fl">10</span>, conv_tabu <span class="op">=</span> <span class="fl">10</span><span class="op">)</span>
<span class="va">azp_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 4 1 2 3 3 3 1 3 1 3 3 3 2 4 2 2 2 2 1 2 4 2 1 3 1 1 2 3 3 3 2 3 2 2 2 3 1 2
## [39] 2 4 4 2 1 3 2 3 2 2 1 1 2 1 1 2 1 2 1 1 2 1 4 3 3 3 1 1 3 1 4 2 1 1 1 1 5 1
## [77] 3 3 3 3 5 5 2 1 1
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 52.20796 39.86439 30.75532 54.95106 54.00440 59.41931
## 
## $`Total within-cluster sum of squares`
## [1] 212.7976
## 
## $`The ratio of between to total sum of squares`
## [1] 0.4222174</code></pre>
<p>NOTE: the AZP algorithm is very sensitive to the initial positions for constructing final solutions. Therefore, the random seed, which is used to determine the initial positions, could be used to execute several rounds of max-p algorithms for sensitive analysis.</p>
</div>
</div>
<div id="max-p" class="section level3">
<h3 class="hasAnchor">
<a href="#max-p" class="anchor"></a>5.5 Max-p</h3>
<p>The so-called max-p regions model (outlined in Duque, Anselin, and Rey 2012) uses a different approach and considers the regionalization problem as an application of integer programming. Besides, the number of regions is determined endogenously.</p>
<p>The algorithm itself consists of a search process that starts with an initial feasible solution and iteratively improves upon it while maintaining contiguity among the elements of each cluster. <code>rgeoda</code> provides three different heuristic algorithms to find an optimal solution for max-p:</p>
<ul>
<li>greedy</li>
<li>Tabu Search</li>
<li>Simulated Annealing</li>
</ul>
<p>Unlike SKATER and REDCAP that one can specify the number of clusters as an input parameter, max-p doesn’t allow to specify the number of clusters explicitly, but a constrained variable and the minimum bounding value that each cluster should reach that are used to find an optimized number of clusters.</p>
</div>
<div id="max-p-greedy" class="section level3">
<h3 class="hasAnchor">
<a href="#max-p-greedy" class="anchor"></a>5.5.1 Max-p greedy</h3>
<p>For example, to use the <code>greedy</code> algorithm in maxp function with the same dataset and weights as above to find optimal clusters using max-p:</p>
<p>First, we need to specify, for example, every cluster must have population &gt;= 3236.67 thousand people:</p>
<div class="sourceCode" id="cb116"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">bound_vals</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="st">'Pop1831'</span><span class="op">]</span>
<span class="va">min_bound</span> <span class="op">&lt;-</span> <span class="fl">3236.67</span> <span class="co"># 10% of Pop1831</span></code></pre></div>
<p>Then, we can call the max-p function with the “greedy” algorithm, the bound values, and minimum bound value:</p>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">maxp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_greedy.html">maxp_greedy</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span><span class="op">)</span>
<span class="va">maxp_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 4 8 6 3 4 3 8 1 2 1 1 3 7 1 6 5 6 6 4 5 6 6 4 3 2 2 5 3 1 1 1 3 5 7 7 4 4 1
## [39] 7 3 6 5 2 1 6 3 7 7 2 4 7 8 8 5 8 6 2 8 7 2 6 1 1 1 8 8 4 4 3 7 2 2 2 2 5 2
## [77] 1 1 3 3 5 5 5 4 2
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 58.53340 44.29870 26.78835 50.67614 50.07543 46.84457
## 
## $`Total within-cluster sum of squares`
## [1] 226.7834
## 
## $`The ratio of between to total sum of squares`
## [1] 0.4499671</code></pre>
<pre><code>Note: the results of max-p may be different with GeoDa desktop software, it is caused by the different implementation of boost::unordered_map in version 1.58 (used in GeoDa) and version 1.75 (used in rgeoda via BH package). The keys in boost::unordered_map are not ordered and have different orders in the two Boost versions we used. This involves a different mechanism of randomness in max-p algorithm when picking which area or region to process. Therefore, the results might be slightly different. This is normal and shows the sensitiveness of the max-p algorithm: see https://geodacenter.github.io/workbook/9d_spatial4/lab9d.html#max-p-region-problem for more about sensitivy study of max-p algorithm.

If you want to replicate the identical results as in GeoDa software v1.18.0, please install BH == 1.58.0-1 and build/install rgeoda from source using: devtools::install_github("lixun910/rgeoda")</code></pre>
</div>
<div id="max-p-tabu-search" class="section level3">
<h3 class="hasAnchor">
<a href="#max-p-tabu-search" class="anchor"></a>5.5.2 Max-p Tabu Search</h3>
<p>To use <code>tabu search</code> algorithm in maxp function, we can specify the parameters of tabu_length and conv_tabu:</p>
<div class="sourceCode" id="cb120"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">maxp_tabu_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_tabu.html">maxp_tabu</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span>, tabu_length<span class="op">=</span><span class="fl">10</span>, conv_tabu<span class="op">=</span><span class="fl">10</span><span class="op">)</span>
<span class="va">maxp_tabu_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 6 2 6 1 1 6 2 1 3 1 1 1 8 6 4 4 5 4 2 7 6 4 3 1 8 8 7 1 1 1 4 1 7 4 5 1 2 4
## [39] 5 6 6 7 8 1 4 1 5 5 3 2 5 3 3 7 3 5 2 2 5 2 6 1 1 1 3 3 1 3 6 5 8 8 2 8 7 2
## [77] 1 1 1 1 7 7 4 3 2
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 41.67030 38.07925 26.22669 52.73867 44.51344 54.13078
## 
## $`Total within-cluster sum of squares`
## [1] 246.6409
## 
## $`The ratio of between to total sum of squares`
## [1] 0.4893668</code></pre>
</div>
<div id="max-p-simulated-annealing" class="section level3">
<h3 class="hasAnchor">
<a href="#max-p-simulated-annealing" class="anchor"></a>5.5.3 Max-p Simulated Annealing</h3>
<p>To apply <code>simulated annealing</code> algorithm in maxp function with the parameter of cooling rate:</p>
<div class="sourceCode" id="cb122"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">maxp_sa_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_sa.html">maxp_sa</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span>, cooling_rate<span class="op">=</span><span class="fl">0.85</span>, sa_maxit<span class="op">=</span><span class="fl">1</span><span class="op">)</span>
<span class="va">maxp_sa_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 2 8 5 2 2 4 8 3 1 3 4 2 1 3 5 6 5 5 2 6 5 5 1 2 1 7 6 4 3 3 5 4 6 7 7 2 2 5
## [39] 7 4 3 6 1 3 3 4 7 7 1 2 7 1 1 6 1 5 8 8 7 8 5 3 3 3 1 1 2 1 4 7 1 1 1 1 6 8
## [77] 4 4 2 4 6 6 6 1 2
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 49.54630 52.71528 31.38930 47.57064 44.96762 46.70911
## 
## $`Total within-cluster sum of squares`
## [1] 231.1018
## 
## $`The ratio of between to total sum of squares`
## [1] 0.4585352</code></pre>
<p>We can also increase the number of iterations for local search process by specifying the parameter <code>iterations</code> (default value is 99):</p>
<div class="sourceCode" id="cb124"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">maxp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_greedy.html">maxp_greedy</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span>, iterations<span class="op">=</span><span class="fl">199</span><span class="op">)</span>
<span class="va">maxp_clusters</span></code></pre></div>
<pre><code>## $Clusters
##  [1] 2 7 4 2 2 2 7 1 5 1 1 2 8 1 4 6 4 4 7 6 4 4 5 2 8 8 6 2 1 1 1 2 6 4 3 2 7 1
## [39] 3 4 4 6 3 1 1 2 3 3 5 5 3 5 7 6 5 3 7 7 3 8 4 1 1 1 5 5 3 5 3 3 8 8 7 8 6 8
## [77] 1 1 2 2 6 6 6 5 7
## 
## $`Total sum of squares`
## [1] 504
## 
## $`Within-cluster sum of squares`
## [1] 50.45471 42.41705 23.35407 52.46201 47.80935 46.88761
## 
## $`Total within-cluster sum of squares`
## [1] 240.6152
## 
## $`The ratio of between to total sum of squares`
## [1] 0.4774111</code></pre>
<p>NOTE: the max-p algorithm is very sensitive to the initial positions for constructing final solutions. Therefore, the random seed, which is used to determine the initial positions, could be used to execute several rounds of max-p algorithms for sensitive analysis.</p>
</div>
</div>
<div id="exploratory-spatial-data-analysis" class="section level2">
<h2 class="hasAnchor">
<a href="#exploratory-spatial-data-analysis" class="anchor"></a>6 Exploratory Spatial Data Analysis</h2>
<p>For exploratory spatial data analysis (ESDA), rgeoa provides some utility functions to allow users to easily work with sf to visualize the results and do exploratory spatial data analysis.</p>
<div id="start-from-sf-package" class="section level3">
<h3 class="hasAnchor">
<a href="#start-from-sf-package" class="anchor"></a>6.1 Start from <code>sf</code> package</h3>
<p>The sf package has been popular tool to handle geospatial data. It is a good substitue of sp package which will be deprecated soon.</p>
<p>For example, we can simply call plot() function to render the first 9 chorepleth maps using the frist 9 variables in the dataset:</p>
<div class="sourceCode" id="cb126"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span></code></pre></div>
<pre><code>## Warning: plotting the first 9 out of 30 attributes; use max.plot = 30 to plot
## all</code></pre>
<p><img src="rgeoda_tutorial_files/figure-html/unnamed-chunk-61-1.png" width="576"></p>
</div>
<div id="esda-with-rgeoda" class="section level3">
<h3 class="hasAnchor">
<a href="#esda-with-rgeoda" class="anchor"></a>6.2 ESDA with rgeoda</h3>
<p>Now, with the sf object <code>guerry</code>, you can call rgeoda’s spatial analysis functions. For example, to examine the local Moran statistics of variable “crm_prs” (Population per Crime against persons):</p>
<div class="sourceCode" id="cb128"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">queen_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/queen_weights.html">queen_weights</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>
<span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>,  <span class="va">guerry</span><span class="op">[</span><span class="st">'Crm_prs'</span><span class="op">]</span><span class="op">)</span></code></pre></div>
<p>Note: rgeoda uses wkb, which is a binary representation of geometries, to exchange data between sf and libgeoda in memory.</p>
</div>
<div id="create-local-moran-map" class="section level3">
<h3 class="hasAnchor">
<a href="#create-local-moran-map" class="anchor"></a>6.3 Create Local Moran Map</h3>
<p>With the LISA results, we can make a local moran cluster map:</p>
<div class="sourceCode" id="cb129"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lisa_colors</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_colors.html">lisa_colors</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span>
<span class="va">lisa_labels</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_labels.html">lisa_labels</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span>
<span class="va">lisa_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span>

<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_geometry</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>, 
     col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">lisa_clusters</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span><span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">lisa_colors</span><span class="op">[[</span><span class="va">x</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">}</span><span class="op">)</span>, 
     border <span class="op">=</span> <span class="st">"#333333"</span>, lwd<span class="op">=</span><span class="fl">0.2</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/title.html">title</a></span><span class="op">(</span>main <span class="op">=</span> <span class="st">"Local Moran Map of Crm_prs"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">'bottomleft'</span>, legend <span class="op">=</span> <span class="va">lisa_labels</span>, fill <span class="op">=</span> <span class="va">lisa_colors</span>, border <span class="op">=</span> <span class="st">"#eeeeee"</span><span class="op">)</span></code></pre></div>
<p><img src="rgeoda_tutorial_files/figure-html/unnamed-chunk-63-1.png" width="576"></p>
<p>In the above code, we use th values of cluster indicators from <code>rgeoda</code>’s <code>LISA</code> object are used to make the LISA map. We can save the clusters back to the original <code>sf</code> data.frame:</p>
<div class="sourceCode" id="cb130"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">guerry</span><span class="op">[</span><span class="st">'moran_cluster'</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lisa_clusters</span></code></pre></div>
<p>Checking the values of the cluster indicators, we will see they are integer numbers 0 (not significant), 1 (high-high cluster), 2 (low-low cluster), 3 (low-high cluster), 4 (high-low cluster), 5 (neighborless/island), 6 (undefined):</p>
<div class="sourceCode" id="cb131"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lisa_clusters</span></code></pre></div>
<pre><code>##  [1] 0 1 1 0 0 2 0 2 0 2 2 0 0 2 0 0 1 0 0 0 0 0 0 2 0 0 0 2 2 0 0 2 1 0 3 0 0 0
## [39] 0 0 0 0 0 0 0 2 0 0 3 0 1 0 0 0 0 0 1 0 0 1 0 0 0 2 0 0 0 0 1 1 0 0 0 0 0 0
## [77] 2 2 0 2 0 0 0 0 0</code></pre>
<p>To create a significance map that is associated with the local Moran map, we can do the same as making the local moran cluster map using the results from lisa_pvalues():</p>
<div class="sourceCode" id="cb133"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lisa_p</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span>
<span class="va">p_labels</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Not significant"</span>, <span class="st">"p &lt;= 0.05"</span>, <span class="st">"p &lt;= 0.01"</span>, <span class="st">"p &lt;= 0.001"</span><span class="op">)</span>
<span class="va">p_colors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"#eeeeee"</span>, <span class="st">"#84f576"</span>, <span class="st">"#53c53c"</span>, <span class="st">"#348124"</span><span class="op">)</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_geometry</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>, 
     col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">sapply</a></span><span class="op">(</span><span class="va">lisa_p</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span>
       <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">&lt;=</span> <span class="fl">0.001</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span>
       <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">&lt;=</span> <span class="fl">0.01</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>
       <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">&lt;=</span> <span class="fl">0.05</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span> <span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>
       <span class="kw">else</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>
       <span class="op">}</span><span class="op">)</span>, 
     border <span class="op">=</span> <span class="st">"#333333"</span>, lwd<span class="op">=</span><span class="fl">0.2</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/title.html">title</a></span><span class="op">(</span>main <span class="op">=</span> <span class="st">"Local Moran Map of Crm_prs"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">'bottomleft'</span>, legend <span class="op">=</span> <span class="va">p_labels</span>, fill <span class="op">=</span> <span class="va">p_colors</span>, border <span class="op">=</span> <span class="st">"#eeeeee"</span><span class="op">)</span></code></pre></div>
<p><img src="rgeoda_tutorial_files/figure-html/unnamed-chunk-66-1.png" width="576"></p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Xun Li, Luc Anselin.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
