<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tutorial of rgeoda • rgeoda</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Tutorial of rgeoda">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rgeoda</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.0.11-1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/rgeoda_tutorial.html">Tutorial of rgeoda</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/geodacenter/rgeoda/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Tutorial of rgeoda</h1>
                        <h4 data-toc-skip class="author">Xun Li</h4>
            
            <h4 data-toc-skip class="date">1/6/2021</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/geodacenter/rgeoda/blob/master/vignettes/rgeoda_tutorial.Rmd" class="external-link"><code>vignettes/rgeoda_tutorial.Rmd</code></a></small>
      <div class="hidden name"><code>rgeoda_tutorial.Rmd</code></div>

    </div>

    
    
<p><code>rgeoda</code> is an R library for spatial data analysis. It is
an R wrapper of the libgeoda C++ library, which is built based on the
<code>GeoDa</code> software. The version used in this tutorial is
version 0.0.8.</p>
<div class="section level2">
<h2 id="install-rgeoda">1. Install <code>rgeoda</code><a class="anchor" aria-label="anchor" href="#install-rgeoda"></a>
</h2>
<p>The rgeoda package can be installed using “install.packages()”
command:</p>
<pre><code><span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html" class="external-link">install.packages</a></span><span class="op">(</span><span class="st">"rgeoda"</span><span class="op">)</span></span></code></pre>
<p>, and then can be loaded using the customary “library()” command:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/geodacenter/rgeoda/" class="external-link">rgeoda</a></span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Loading required package: digest</span></span></code></pre>
<p>In addition, the package sf needs to be loaded, since it is a
dependency:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/" class="external-link">sf</a></span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="load-spatial-data">2. Load Spatial Data<a class="anchor" aria-label="anchor" href="#load-spatial-data"></a>
</h2>
<p>The rgeoda package for R relies on the sf (simple features) package
for basic spatial data handling functions. In a typical R workflow, one
first reads a shape file or other GIS format file with the data using
the sf st_read(file path) command. For example, to load the ESRI
Shapefile <code>Guerry.shp</code> comes with the package:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">guerry_path</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"extdata"</span>, <span class="st">"Guerry.shp"</span>, package <span class="op">=</span> <span class="st">"rgeoda"</span><span class="op">)</span></span>
<span><span class="va">guerry</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html" class="external-link">st_read</a></span><span class="op">(</span><span class="va">guerry_path</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Reading layer `Guerry' from data source </span></span>
<span><span class="co">##   `/Users/runner/work/_temp/Library/rgeoda/extdata/Guerry.shp' </span></span>
<span><span class="co">##   using driver `ESRI Shapefile'</span></span>
<span><span class="co">## Simple feature collection with 85 features and 29 fields</span></span>
<span><span class="co">## Geometry type: MULTIPOLYGON</span></span>
<span><span class="co">## Dimension:     XY</span></span>
<span><span class="co">## Bounding box:  xmin: 47680 ymin: 1703258 xmax: 1031401 ymax: 2677441</span></span>
<span><span class="co">## Projected CRS: NTF (Paris) / Lambert zone II</span></span></code></pre>
<p>Once the spatial object has been created, it can be used to compute a
spatial weights matrix using one of the several weights functions in
rgeoda.</p>
</div>
<div class="section level2">
<h2 id="spatial-weights">3. Spatial Weights<a class="anchor" aria-label="anchor" href="#spatial-weights"></a>
</h2>
<p>Spatial weights are central components in spatial data analysis. The
spatial weights represent the possible spatial interactions between
observations in space. <code>rgeoda</code> provides 6 functions to
create 4 different types of spatial weights:</p>
<ul>
<li>Contiguity Based Weights: <code><a href="../reference/queen_weights.html">queen_weights()</a></code>,
<code><a href="../reference/rook_weights.html">rook_weights()</a></code>
</li>
<li>Distance Based Weights: <code><a href="../reference/distance_weights.html">distance_weights()</a></code>
</li>
<li>K-Nearest Neighbor Weights: <code><a href="../reference/knn_weights.html">knn_weights()</a></code>
</li>
<li>Kernel Weights: <code><a href="../reference/distance_weights.html">distance_weights()</a></code> and
<code><a href="../reference/knn_weights.html">knn_weights()</a></code> with kernel parameters</li>
</ul>
<div class="section level3">
<h3 id="queen-contiguity-weights">3.1 Queen Contiguity Weights<a class="anchor" aria-label="anchor" href="#queen-contiguity-weights"></a>
</h3>
<p>Contiguity means that two spatial units share a common border of
non-zero length. Operationally, we can further distinguish between a
rook and a queen criterion of contiguity, in analogy to the moves
allowed for the such-named pieces on a chess board. The queen criterion
is somewhat more encompassing and defines neighbors as spatial units
sharing a common edge or a common vertex.</p>
<p>To create a Queen contiguity weights, one can call the function</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/queen_weights.html">queen_weights</a></span><span class="op">(</span><span class="va">sf_obj</span>, order<span class="op">=</span><span class="fl">1</span>, include_lower_order <span class="op">=</span> <span class="va">False</span>, precision_threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>For example, to create a Queen contiguity weights using the sf object
<code>guerry</code>:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">queen_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/queen_weights.html">queen_weights</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                      name              value</span></span>
<span><span class="co">## 1 number of observations:                 85</span></span>
<span><span class="co">## 2          is symmetric:                TRUE</span></span>
<span><span class="co">## 3               sparsity: 0.0581314878892734</span></span>
<span><span class="co">## 4        # min neighbors:                  2</span></span>
<span><span class="co">## 5        # max neighbors:                  8</span></span>
<span><span class="co">## 6       # mean neighbors:   4.94117647058824</span></span>
<span><span class="co">## 7     # median neighbors:                  5</span></span>
<span><span class="co">## 8           has isolates:              FALSE</span></span></code></pre>
<p>The function <code><a href="../reference/queen_weights.html">queen_weights()</a></code> returns an instance of
<code>Weight</code> object. One can access the meta data of the spatial
weights by accessing the attributes of <code>GeoDaWeight</code>
object:</p>
<div class="section level4">
<h4 id="attributes-of-weight-object">Attributes of <code>Weight</code> object<a class="anchor" aria-label="anchor" href="#attributes-of-weight-object"></a>
</h4>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/is_symmetric.html">is_symmetric</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] TRUE</span></span></code></pre>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/has_isolates.html">has_isolates</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] FALSE</span></span></code></pre>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/weights_sparsity.html">weights_sparsity</a></span><span class="op">(</span><span class="va">queen_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.05813149</span></span></code></pre>
<p>To access the details of the weights: e.g. list the neighbors of a
specified observation:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nbrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_neighbors.html">get_neighbors</a></span><span class="op">(</span><span class="va">queen_w</span>, idx <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="st">"\nNeighbors of the 1-st observation are:"</span>, <span class="va">nbrs</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Neighbors of the 1-st observation are: 36 37 67 69</span></span></code></pre>
<p>To compute the spatial lag of a specified observation by passing the
values of the selected variable:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lag</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spatial_lag.html">spatial_lag</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="st">'Crm_prs'</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">lag</span></span></code></pre></div>
<pre><code><span><span class="co">##    Spatial.Lag</span></span>
<span><span class="co">## 1     23047.50</span></span>
<span><span class="co">## 2     26919.67</span></span>
<span><span class="co">## 3     26195.50</span></span>
<span><span class="co">## 4     14401.25</span></span>
<span><span class="co">## 5     15038.67</span></span>
<span><span class="co">## 6     15749.00</span></span>
<span><span class="co">## 7     22111.67</span></span>
<span><span class="co">## 8     13672.33</span></span>
<span><span class="co">## 9     22859.20</span></span>
<span><span class="co">## 10    11475.20</span></span>
<span><span class="co">## 11    12200.14</span></span>
<span><span class="co">## 12    13278.67</span></span>
<span><span class="co">## 13    24734.00</span></span>
<span><span class="co">## 14    11752.83</span></span>
<span><span class="co">## 15    17992.60</span></span>
<span><span class="co">## 16    21974.40</span></span>
<span><span class="co">## 17    26711.00</span></span>
<span><span class="co">## 18    19344.00</span></span>
<span><span class="co">## 19    23696.71</span></span>
<span><span class="co">## 20    25108.67</span></span>
<span><span class="co">## 21    21643.17</span></span>
<span><span class="co">## 22    18306.00</span></span>
<span><span class="co">## 23    24280.00</span></span>
<span><span class="co">## 24    14451.60</span></span>
<span><span class="co">## 25    21047.67</span></span>
<span><span class="co">## 26    21421.33</span></span>
<span><span class="co">## 27    25961.50</span></span>
<span><span class="co">## 28    10869.83</span></span>
<span><span class="co">## 29    13415.67</span></span>
<span><span class="co">## 30    17172.17</span></span>
<span><span class="co">## 31    20238.25</span></span>
<span><span class="co">## 32    12504.25</span></span>
<span><span class="co">## 33    26723.00</span></span>
<span><span class="co">## 34    21772.83</span></span>
<span><span class="co">## 35    26462.20</span></span>
<span><span class="co">## 36    19252.00</span></span>
<span><span class="co">## 37    24683.20</span></span>
<span><span class="co">## 38    20607.25</span></span>
<span><span class="co">## 39    24412.00</span></span>
<span><span class="co">## 40    19373.71</span></span>
<span><span class="co">## 41    16000.20</span></span>
<span><span class="co">## 42    23993.25</span></span>
<span><span class="co">## 43    20337.86</span></span>
<span><span class="co">## 44    16818.67</span></span>
<span><span class="co">## 45    17113.83</span></span>
<span><span class="co">## 46    13013.00</span></span>
<span><span class="co">## 47    22133.00</span></span>
<span><span class="co">## 48    24093.75</span></span>
<span><span class="co">## 49    25661.67</span></span>
<span><span class="co">## 50    22190.17</span></span>
<span><span class="co">## 51    29030.00</span></span>
<span><span class="co">## 52    16951.00</span></span>
<span><span class="co">## 53    24509.00</span></span>
<span><span class="co">## 54    24982.75</span></span>
<span><span class="co">## 55    19491.50</span></span>
<span><span class="co">## 56    24176.00</span></span>
<span><span class="co">## 57    27639.67</span></span>
<span><span class="co">## 58    21274.33</span></span>
<span><span class="co">## 59    24510.33</span></span>
<span><span class="co">## 60    30166.00</span></span>
<span><span class="co">## 61    23459.00</span></span>
<span><span class="co">## 62    16184.00</span></span>
<span><span class="co">## 63    18002.00</span></span>
<span><span class="co">## 64    10910.00</span></span>
<span><span class="co">## 65    16251.25</span></span>
<span><span class="co">## 66    15572.00</span></span>
<span><span class="co">## 67    25884.25</span></span>
<span><span class="co">## 68    23020.60</span></span>
<span><span class="co">## 69    26495.00</span></span>
<span><span class="co">## 70    24690.50</span></span>
<span><span class="co">## 71    17339.00</span></span>
<span><span class="co">## 72    25522.33</span></span>
<span><span class="co">## 73    18970.00</span></span>
<span><span class="co">## 74    19701.83</span></span>
<span><span class="co">## 75    21841.00</span></span>
<span><span class="co">## 76    24520.40</span></span>
<span><span class="co">## 77    14025.80</span></span>
<span><span class="co">## 78    14565.17</span></span>
<span><span class="co">## 79    13306.67</span></span>
<span><span class="co">## 80    12579.00</span></span>
<span><span class="co">## 81    21529.50</span></span>
<span><span class="co">## 82    23474.50</span></span>
<span><span class="co">## 83    24373.17</span></span>
<span><span class="co">## 84    19900.50</span></span>
<span><span class="co">## 85    23373.60</span></span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="rook-contiguity-weights">3.2 Rook Contiguity Weights<a class="anchor" aria-label="anchor" href="#rook-contiguity-weights"></a>
</h3>
<p>The rook criterion defines neighbors by the existence of a common
edge between two spatial units. To create a Rook contiguity weights, one
can call function:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rook_weights.html">rook_weights</a></span><span class="op">(</span><span class="va">sf_obj</span>, order<span class="op">=</span><span class="fl">1</span>,include_lower_order<span class="op">=</span><span class="va">False</span>, precision_threshold <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>For example, to create a Rook contiguity weights using the sf object
<code>guerry</code>:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rook_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rook_weights.html">rook_weights</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">rook_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                      name              value</span></span>
<span><span class="co">## 1 number of observations:                 85</span></span>
<span><span class="co">## 2          is symmetric:                TRUE</span></span>
<span><span class="co">## 3               sparsity: 0.0581314878892734</span></span>
<span><span class="co">## 4        # min neighbors:                  2</span></span>
<span><span class="co">## 5        # max neighbors:                  8</span></span>
<span><span class="co">## 6       # mean neighbors:   4.94117647058824</span></span>
<span><span class="co">## 7     # median neighbors:                  5</span></span>
<span><span class="co">## 8           has isolates:              FALSE</span></span></code></pre>
<p>The weights we created are in memory. To save the weights to a file,
one can call the function:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/save_weights.html">save_weights</a></span><span class="op">(</span><span class="va">gda_w</span>, <span class="va">id_variable</span>, <span class="va">out_path</span>, layer_name <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span></code></pre></div>
<p>The <code>id_variable</code> defines the unique value of each
observation when saving a weights file</p>
<p>The <code>layer_name</code> is the layer name of loaded dataset. For
a ESRI shapefile, the layer name is the file name without the suffix
(e.g. Guerry).</p>
<p>For example, using Guerry dataset, the column “CODE_DE” can be used
as a key to save a weights file:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/save_weights.html">save_weights</a></span><span class="op">(</span><span class="va">rook_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="st">'CODE_DE'</span><span class="op">]</span>, out_path <span class="op">=</span> <span class="st">'/Users/xun/Downloads/Guerry_r.gal'</span>, </span>
<span>             layer_name <span class="op">=</span> <span class="st">'Guerry'</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] FALSE</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="distance-based-weights">3.3 Distance Based Weights<a class="anchor" aria-label="anchor" href="#distance-based-weights"></a>
</h3>
<p>The most straightforward spatial weights matrix constructed from a
distance measure is obtained when i and j are considered neighbors
whenever j falls within a critical distance band from i. In order to
start the distance based neighbors, we first need to compute a threshold
value. <code>rgeoda</code> provides a function
<code>min_distthreshold</code> to help you find a optimized distance
threshold that guarantees that every observation has at least one
neighbor:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="fu">min_distthreshold</span>(GeoDa gda, bool <span class="at">is_arc =</span> False, <span class="at">is_mile =</span> True)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>To create a Distance based weights, one can call the <span class="cf">function</span> <span class="st">`</span><span class="at">distance_weights</span><span class="st">`</span><span class="sc">:</span></span></code></pre></div>
<p>Then, with this distance threshold, we can create a distance-band
weights using the function:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/distance_weights.html">distance_weights</a></span><span class="op">(</span><span class="va">geoda_obj</span>, <span class="va">dist_thres</span>, power<span class="op">=</span><span class="fl">1.0</span>,  is_inverse<span class="op">=</span><span class="va">False</span>, is_arc<span class="op">=</span><span class="va">False</span>, is_mile<span class="op">=</span><span class="va">True</span><span class="op">)</span></span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dist_thres</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/min_distthreshold.html">min_distthreshold</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span></span>
<span><span class="va">dist_thres</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 96726.14</span></span></code></pre>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dist_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/distance_weights.html">distance_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="va">dist_thres</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">dist_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                      name              value</span></span>
<span><span class="co">## 1 number of observations:                 85</span></span>
<span><span class="co">## 2          is symmetric:                TRUE</span></span>
<span><span class="co">## 3               sparsity: 0.0434602076124567</span></span>
<span><span class="co">## 4        # min neighbors:                  1</span></span>
<span><span class="co">## 5        # max neighbors:                  7</span></span>
<span><span class="co">## 6       # mean neighbors:   3.69411764705882</span></span>
<span><span class="co">## 7     # median neighbors:                  4</span></span>
<span><span class="co">## 8           has isolates:              FALSE</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="k-nearest-neighbor-weights">3.4 K-Nearest Neighbor Weights<a class="anchor" aria-label="anchor" href="#k-nearest-neighbor-weights"></a>
</h3>
<p>A special case of distance based weights is K-Nearest neighbor
weights, in which every obersvation will have exactly k neighbors. It
can be used to avoid the problem of isolate in distance-band weights
when a smaller cut-off distance is used. To create a KNN weights, we can
call the function <code>knn_weights</code>:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/knn_weights.html">knn_weights</a></span><span class="op">(</span><span class="va">gda</span>, <span class="va">k</span>, power <span class="op">=</span> <span class="fl">1.0</span>,is_inverse <span class="op">=</span> <span class="va">False</span>, is_arc <span class="op">=</span> <span class="va">False</span>, is_mile <span class="op">=</span> <span class="va">True</span><span class="op">)</span></span></code></pre></div>
<p>For example, to create a 6-nearest neighbor weights using Guerry:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">knn6_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/knn_weights.html">knn_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="fl">6</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">knn6_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                      name              value</span></span>
<span><span class="co">## 1 number of observations:                 85</span></span>
<span><span class="co">## 2          is symmetric:               FALSE</span></span>
<span><span class="co">## 3               sparsity: 0.0705882352941176</span></span>
<span><span class="co">## 4        # min neighbors:                  6</span></span>
<span><span class="co">## 5        # max neighbors:                  6</span></span>
<span><span class="co">## 6       # mean neighbors:                  6</span></span>
<span><span class="co">## 7     # median neighbors:                  6</span></span>
<span><span class="co">## 8           has isolates:              FALSE</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="kernel-weights">3.5 Kernel Weights<a class="anchor" aria-label="anchor" href="#kernel-weights"></a>
</h3>
<p>Kernel weights apply kernel function to determine the distance decay
in the derived continuous weights kernel. The kernel weights are defined
as a function K(z) of the ratio between the distance dij from i to j,
and the bandwidth hi, with z=dij/hi.</p>
<p>The kernel functions include</p>
<ul>
<li>triangular</li>
<li>uniform</li>
<li>quadratic</li>
<li>epanechnikov</li>
<li>quartic</li>
<li>gaussian</li>
</ul>
<p>Two functions are provided in <code>rgeoda</code> to create kernel
weights.</p>
<div class="section level4">
<h4 id="use-kernel_weights-for-kernel-weights-with-adaptive-bandwidth">Use <code>kernel_weights</code> for Kernel Weights with adaptive
bandwidth<a class="anchor" aria-label="anchor" href="#use-kernel_weights-for-kernel-weights-with-adaptive-bandwidth"></a>
</h4>
<p>To create a kernel weights with fixed bandwith:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bandwidth</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/min_distthreshold.html">min_distthreshold</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span></span>
<span><span class="va">kernel_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/kernel_weights.html">kernel_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="va">bandwidth</span>, kernel_method <span class="op">=</span> <span class="st">"uniform"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">kernel_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                      name              value</span></span>
<span><span class="co">## 1 number of observations:                 85</span></span>
<span><span class="co">## 2          is symmetric:               FALSE</span></span>
<span><span class="co">## 3               sparsity: 0.0434602076124567</span></span>
<span><span class="co">## 4        # min neighbors:                  1</span></span>
<span><span class="co">## 5        # max neighbors:                  7</span></span>
<span><span class="co">## 6       # mean neighbors:   3.69411764705882</span></span>
<span><span class="co">## 7     # median neighbors:                  4</span></span>
<span><span class="co">## 8           has isolates:              FALSE</span></span></code></pre>
<p>The arguments <code>is_inverse</code>, <code>power</code>,
<code>is_arc</code> and <code>is_mile</code> are the same with the
distance based weights. Additionally, <code>kernel_weights</code> has
another argument that user can specify:</p>
<pre><code>use_kernel_diagonals    
(optional) FALSE (default) or TRUE, apply kernel on the diagonal of weights matrix</code></pre>
</div>
<div class="section level4">
<h4 id="use-kernel_knn_weights-for-kernel-weights-with-adaptive-bandwidth">Use <code>kernel_knn_weights</code> for Kernel Weights with adaptive
bandwidth<a class="anchor" aria-label="anchor" href="#use-kernel_knn_weights-for-kernel-weights-with-adaptive-bandwidth"></a>
</h4>
<p>To create a kernel weights with adaptive bandwidth or using max Knn
distance as bandwidth:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">adptkernel_w</span> <span class="op">=</span> <span class="fu"><a href="../reference/kernel_knn_weights.html">kernel_knn_weights</a></span><span class="op">(</span><span class="va">guerry</span>, <span class="fl">6</span>, <span class="st">"uniform"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">adptkernel_w</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                      name              value</span></span>
<span><span class="co">## 1 number of observations:                 85</span></span>
<span><span class="co">## 2          is symmetric:               FALSE</span></span>
<span><span class="co">## 3               sparsity: 0.0705882352941176</span></span>
<span><span class="co">## 4        # min neighbors:                  6</span></span>
<span><span class="co">## 5        # max neighbors:                  6</span></span>
<span><span class="co">## 6       # mean neighbors:                  6</span></span>
<span><span class="co">## 7     # median neighbors:                  6</span></span>
<span><span class="co">## 8           has isolates:              FALSE</span></span></code></pre>
<p>This kernel weights function two more arguments that user can
specify:</p>
<pre><code>adaptive_bandwidth  
(optional) TRUE (default) or FALSE: TRUE use adaptive bandwidth calculated using distance of k-nearest neithbors, FALSE use max distance of all observation to their k-nearest neighbors

use_kernel_diagonals    
(optional) FALSE (default) or TRUE, apply kernel on the diagonal of weights matrix</code></pre>
</div>
</div>
</div>
<div class="section level2">
<h2 id="local-indicators-of-spatial-associationlisa">4 Local Indicators of Spatial Association–LISA<a class="anchor" aria-label="anchor" href="#local-indicators-of-spatial-associationlisa"></a>
</h2>
<p><code>rgeoda</code> provides following methods for local spatial
autocorrelation statistics:</p>
<ul>
<li>Local Moran: local_moran(), local_moran_eb()</li>
<li>Local Geary: local_geary(), local_multigeary()</li>
<li>Local Getis-Ord statistics: local_g() and local_gstar()</li>
<li>Local Join Count: local_joincount(), local_bijoincount(),
local_multijoincount()</li>
<li>Quantile LISA: local_quantilelisa(), local_multiquantilelisa()</li>
<li>Local Neighbor Match Test: neighbor_match_test()</li>
</ul>
<p>For more information about the local spatial autocorrelation
statisticis, please read Dr. Luc Anselin’s lab notes: <a href="http://geodacenter.github.io/workbook/6a_local_auto/lab6a.html" class="external-link uri">http://geodacenter.github.io/workbook/6a_local_auto/lab6a.html</a>.</p>
<div class="section level3">
<h3 id="local-moran">4.1 Local Moran<a class="anchor" aria-label="anchor" href="#local-moran"></a>
</h3>
<p>The Local Moran statistic is a method to identify local clusters and
local spatial outliers. For example, we can call the function
<code><a href="../reference/local_moran.html">local_moran()</a></code> with the created Queen weights and the data
“crm_prp = guerry[‘Crm_prp’]” as input parameters:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">crm_prp</span> <span class="op">=</span> <span class="va">guerry</span><span class="op">[</span><span class="st">"Crm_prp"</span><span class="op">]</span></span>
<span><span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span></span></code></pre></div>
<p>The <code><a href="../reference/local_moran.html">local_moran()</a></code> function will return a
<code>lisa</code> object, and we can access its values/results of lisa
computation using the following functions:</p>
<ul>
<li>lisa_clusters(): Get the local cluster indicators returned from LISA
computation.</li>
<li>lisa_colors(): Get the cluster colors of LISA computation.</li>
<li>lisa_labels(): Get the cluster labels of LISA computation.</li>
<li>lisa_values(): Get the local spatial autocorrelation values returned
from LISA computation.</li>
<li>lisa_num_nbrs(): Get the number of neighbors of every observations
in LISA computation.</li>
<li>lisa_pvalues(): Get the local pseudo-p values of significance
returned from LISA computation.</li>
<li>lisa_fdr(): Get the False Discovery Rate (FDR) in LISA.</li>
<li>lisa_bo(): Get the False Discovery Rate (FDR) in LISA.</li>
</ul>
<p>For example, we can call the function <code><a href="../reference/lisa_values.html">lisa_values()</a></code> to
get the values of the local Moran:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lms</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_values.html">lisa_values</a></span><span class="op">(</span>gda_lisa <span class="op">=</span> <span class="va">lisa</span><span class="op">)</span></span>
<span><span class="va">lms</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1]  0.0154319783  0.3270633224  0.0212952962  0.0046105448 -0.0028342407</span></span>
<span><span class="co">##  [6]  0.4149377158 -0.1379463091  0.0998657692  0.2823176310  0.1218745112</span></span>
<span><span class="co">## [11] -0.0951205417  0.0326111938  0.3878324535  1.1888723840 -0.6452792226</span></span>
<span><span class="co">## [16] -0.3096492740  0.3662775143  2.0375343539 -0.0050154800  0.0697110572</span></span>
<span><span class="co">## [21]  2.2720355722  0.2886391551 -0.0070189726 -0.0009906605  0.9517469793</span></span>
<span><span class="co">## [26]  0.7648322095  0.0432039929 -0.0045362842 -0.0964911860  0.0952360887</span></span>
<span><span class="co">## [31]  0.0100895206 -0.0109401003 -0.0544245927 -0.0345553975  0.0887531916</span></span>
<span><span class="co">## [36]  0.0954232056  0.0383617454 -0.1776714441  0.1638208393  1.2309154898</span></span>
<span><span class="co">## [41]  2.9077203402 -0.0396340261  0.4458735227  0.2491123240  0.0905643622</span></span>
<span><span class="co">## [46] -0.6212977834 -0.0308773407  0.0375870399  0.2270376112 -0.0918254739</span></span>
<span><span class="co">## [51] -0.0112400086  0.1085584763 -0.0055113129 -0.0027097589  0.7235016208</span></span>
<span><span class="co">## [56]  0.0163129939  0.4246564560  0.3787307767 -0.0597158189  0.5050011802</span></span>
<span><span class="co">## [61]  2.7632125275  0.0656510809  0.1771899330 -0.0572150317  0.4943795537</span></span>
<span><span class="co">## [66]  0.2870386197 -1.4593300774 -0.0055305930  0.4895990016 -0.0324125662</span></span>
<span><span class="co">## [71]  2.1366499813  0.9041683235  0.7053678641  1.4098290925  0.0051652159</span></span>
<span><span class="co">## [76]  0.2238144189 -0.1621373954  0.0195632289 -0.3233724187 -0.0337778226</span></span>
<span><span class="co">## [81]  0.0118189869 -0.1164679533 -0.5699624657 -0.0859634996  0.2085373916</span></span></code></pre>
<p>To get the pseudo-p values of significance of local Moran
computation:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pvals</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span></span>
<span><span class="va">pvals</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 0.461</span></span>
<span><span class="co">## [13] 0.248 0.015 0.178 0.166 0.124 0.003 0.456 0.346 0.053 0.145 0.431 0.425</span></span>
<span><span class="co">## [25] 0.005 0.037 0.465 0.395 0.138 0.316 0.495 0.431 0.359 0.129 0.295 0.058</span></span>
<span><span class="co">## [37] 0.090 0.231 0.258 0.018 0.026 0.455 0.073 0.057 0.222 0.023 0.369 0.338</span></span>
<span><span class="co">## [49] 0.282 0.359 0.483 0.252 0.450 0.434 0.138 0.327 0.063 0.005 0.097 0.292</span></span>
<span><span class="co">## [61] 0.001 0.217 0.237 0.126 0.145 0.344 0.008 0.340 0.079 0.300 0.033 0.142</span></span>
<span><span class="co">## [73] 0.001 0.001 0.460 0.005 0.212 0.384 0.110 0.409 0.455 0.353 0.006 0.287</span></span>
<span><span class="co">## [85] 0.128</span></span></code></pre>
<p>To get the cluster indicators of local Moran computation:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cats</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">lisa</span>, cutoff <span class="op">=</span> <span class="fl">0.05</span><span class="op">)</span></span>
<span><span class="va">cats</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [39] 0 1 1 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 0 0 0 0 0 3 0 0 0 2 0 2 2 0 2</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 3 0 0</span></span></code></pre>
<p>The predefined values of the indicators of LISA cluster are:</p>
<pre><code>0 Not significant
1 High-High
2 Low-Low
3 High-Low
4 Low-High
5 Undefined
6 Isolated</code></pre>
<p>which can be accessed via the function
<code><a href="../reference/lisa_labels.html">lisa_labels()</a></code>:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lbls</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_labels.html">lisa_labels</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span></span>
<span><span class="va">lbls</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "Not significant" "High-High"       "Low-Low"         "Low-High"       </span></span>
<span><span class="co">## [5] "High-Low"        "Undefined"       "Isolated"</span></span></code></pre>
<p>By default, the <code><a href="../reference/local_moran.html">local_moran()</a></code> function will run with
some default parameters, e.g.:</p>
<pre><code>significance_cutoff: 0.05
permutation: 999
permutation_method: 'complete'
cpu_threads: 6
seed (for random number generator): 123456789</code></pre>
<p>, which are identical to GeoDa desktop software so to replicate the
results in GeoDa software. You can set different values when calling the
lisa functions.</p>
<p>For example, re-run the above local Moran example using 9,999
permutations.</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span>, permutations <span class="op">=</span> <span class="fl">9999</span><span class="op">)</span></span></code></pre></div>
<p>Then, we can use the same <code>lisa</code> object to get the new
results after 9,999 permutations:</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pvals</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span></span>
<span><span class="va">pvals</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.4186 0.1265 0.0004 0.4679 0.4545 0.0728 0.2313 0.3071 0.3115 0.3087</span></span>
<span><span class="co">## [11] 0.2187 0.4834 0.2686 0.0102 0.2024 0.1790 0.1320 0.0020 0.4558 0.3519</span></span>
<span><span class="co">## [21] 0.0479 0.1376 0.4441 0.4195 0.0032 0.0388 0.4736 0.4188 0.1277 0.3300</span></span>
<span><span class="co">## [31] 0.4939 0.4427 0.3393 0.1419 0.2714 0.0606 0.0724 0.2247 0.2628 0.0185</span></span>
<span><span class="co">## [41] 0.0214 0.4899 0.0719 0.0589 0.2288 0.0189 0.3759 0.3216 0.2812 0.3735</span></span>
<span><span class="co">## [51] 0.4695 0.2743 0.4518 0.4286 0.1471 0.3221 0.0647 0.0025 0.0917 0.2812</span></span>
<span><span class="co">## [61] 0.0001 0.2419 0.2462 0.1266 0.1270 0.3553 0.0094 0.3122 0.0724 0.2975</span></span>
<span><span class="co">## [71] 0.0307 0.1320 0.0001 0.0002 0.4633 0.0056 0.2162 0.3681 0.1334 0.4069</span></span>
<span><span class="co">## [81] 0.4536 0.3547 0.0035 0.3096 0.1277</span></span></code></pre>
<p><code>rgeoda</code> uses <code>GeoDa</code> C++ code, in which
multi-threading is used to accelerate the computation of LISA. We can
use the argument <code>ncpu</code> to specify how many threads to run
the computation:</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span>, cpu_threads <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span></code></pre></div>
<p>Get the False Discovery Rate value based on current pseudo-p
values:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fdr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_fdr.html">lisa_fdr</a></span><span class="op">(</span><span class="va">lisa</span>, <span class="fl">0.05</span><span class="op">)</span></span>
<span><span class="va">fdr</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.0005882353</span></span></code></pre>
<p>Then, one can set the FDR value as the cutoff p-value to filter the
cluster results:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cat_fdr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">lisa</span>, cutoff <span class="op">=</span> <span class="va">fdr</span><span class="op">)</span></span>
<span><span class="va">cat_fdr</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 0 0 0</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="local-geary">4.2 Local Geary<a class="anchor" aria-label="anchor" href="#local-geary"></a>
</h3>
<p>Local Geary is a type of LISA that focuses on squared
differences/dissimilarity. A small value of the local geary statistics
suggest positive spatial autocorrelation, whereas large values suggest
negative spatial autocorrelation. For more details, please read: <a href="http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#local-geary" class="external-link uri">http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#local-geary</a></p>
<p>For example, we can call the function local_geary() with the created
Queen weights and the data “crm_prp” as input parameters:</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">geary_crmprp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_geary.html">local_geary</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span></span></code></pre></div>
<p>To get the cluster indicators of the local Geary computation:</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">geary_crmprp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 2 4 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 2 2 0 0 0 0 0 0 0 4 0 0 0 0</span></span>
<span><span class="co">## [39] 0 0 1 0 0 0 1 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 2 0 0</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 4 0 0</span></span></code></pre>
<p>To get the pseudo-p values of the local Geary computation:</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">geary_crmprp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.398 0.027 0.025 0.126 0.017 0.314 0.610 0.141 0.284 0.110 0.559 0.456</span></span>
<span><span class="co">## [13] 0.211 0.255 0.226 0.211 0.089 0.054 0.182 0.017 0.030 0.216 0.395 0.105</span></span>
<span><span class="co">## [25] 0.024 0.033 0.089 0.416 0.504 0.059 0.380 0.254 0.211 0.048 0.113 0.154</span></span>
<span><span class="co">## [37] 0.160 0.571 0.310 0.093 0.009 0.130 0.128 0.178 0.039 0.088 0.076 0.319</span></span>
<span><span class="co">## [49] 0.291 0.438 0.043 0.464 0.177 0.099 0.100 0.232 0.141 0.317 0.615 0.208</span></span>
<span><span class="co">## [61] 0.198 0.299 0.084 0.634 0.148 0.423 0.060 0.108 0.293 0.257 0.032 0.102</span></span>
<span><span class="co">## [73] 0.057 0.003 0.706 0.560 0.605 0.066 0.320 0.391 0.175 0.601 0.007 0.365</span></span>
<span><span class="co">## [85] 0.238</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="multivariate-local-geary">4.3 Multivariate Local Geary:<a class="anchor" aria-label="anchor" href="#multivariate-local-geary"></a>
</h3>
<p>To apply multivariate local geary, we need to define a string with
the variable names and use this string to extract the relevant subset
from the data frame. For example, we apply multivariate local geary on
variables “Crm_prs”, “Crm_prp”, “Litercy”, “Donatns”, “Infants” and
“Suicids”:</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span> <span class="op">&lt;-</span><span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'Crm_prs'</span>,<span class="st">'Crm_prp'</span>,<span class="st">'Litercy'</span>,<span class="st">'Donatns'</span>,<span class="st">'Infants'</span>,<span class="st">'Suicids'</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">multigeary</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_multigeary.html">local_multigeary</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span><span class="op">)</span></span></code></pre></div>
<p>To get the cluster indicators of the local Geary computation:</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">multigeary</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 1 1 1 0 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 1 0 1 0 0 1 0 0 0 0 0</span></span>
<span><span class="co">## [39] 1 0 1 2 1 1 1 0 0 0 1 1 1 0 1 1 0 0 1 1 0 1 1 0 1 0 1 1 0 1 0 1 1 0 1 1 0 1</span></span>
<span><span class="co">## [77] 1 1 1 1 0 1 0 1 1</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="local-getis-ord-statistics">4.4 Local Getis-Ord Statistics<a class="anchor" aria-label="anchor" href="#local-getis-ord-statistics"></a>
</h3>
<p>There are two types of local Getis-Ord statistics: one is computing a
ratio of the weighted average of the values in the neighboring
locations, not including the value at the location; while another type
of statistic includes the value at the location in both numerator and
denominator. For more details, please read: <a href="http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#getis-ord-statistics" class="external-link uri">http://geodacenter.github.io/workbook/6b_local_adv/lab6b.html#getis-ord-statistics</a></p>
<p>A value larger than the mean suggests a high-high cluster or hot
spot, a value smaller than the mean indicates a low-low cluster or cold
spot.</p>
<p>For example, we can call the function <code><a href="../reference/local_g.html">local_g()</a></code> with the
created Queen weights and the data “crm_prp” as input parameters:</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">localg_crmprp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_g.html">local_g</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span></span></code></pre></div>
<p>To get the cluster indicators of the local G computation:</p>
<div class="sourceCode" id="cb70"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">localg_crmprp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [39] 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 2 0 0 1 0 0 0 0 0 1 0 0 0 2 0 2 2 0 2</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 1 0 0</span></span></code></pre>
<p>To get the pseudo-p values of the local G computation:</p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">localg_crmprp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 0.461</span></span>
<span><span class="co">## [13] 0.248 0.015 0.178 0.166 0.124 0.003 0.456 0.346 0.053 0.145 0.432 0.425</span></span>
<span><span class="co">## [25] 0.005 0.037 0.464 0.395 0.138 0.316 0.495 0.431 0.359 0.129 0.295 0.058</span></span>
<span><span class="co">## [37] 0.090 0.231 0.258 0.018 0.026 0.455 0.073 0.057 0.222 0.023 0.369 0.338</span></span>
<span><span class="co">## [49] 0.282 0.359 0.483 0.252 0.450 0.434 0.138 0.327 0.063 0.005 0.097 0.292</span></span>
<span><span class="co">## [61] 0.001 0.217 0.237 0.127 0.145 0.344 0.008 0.340 0.079 0.300 0.033 0.142</span></span>
<span><span class="co">## [73] 0.001 0.001 0.461 0.005 0.212 0.384 0.110 0.409 0.455 0.353 0.006 0.287</span></span>
<span><span class="co">## [85] 0.128</span></span></code></pre>
<p>For the second type of local Getis-Ord statistics, we can call the
function <code><a href="../reference/local_gstar.html">local_gstar()</a></code> with the created Queen weights and
the data “crm_prp” as input parameters:</p>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">localgstar_crmprs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_gstar.html">local_gstar</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">localgstar_crmprs</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 0.461</span></span>
<span><span class="co">## [13] 0.248 0.015 0.178 0.166 0.124 0.003 0.456 0.346 0.053 0.145 0.432 0.425</span></span>
<span><span class="co">## [25] 0.005 0.037 0.464 0.395 0.138 0.316 0.495 0.431 0.359 0.129 0.295 0.058</span></span>
<span><span class="co">## [37] 0.090 0.231 0.258 0.018 0.026 0.455 0.073 0.057 0.222 0.023 0.369 0.338</span></span>
<span><span class="co">## [49] 0.282 0.359 0.483 0.252 0.450 0.434 0.138 0.327 0.063 0.005 0.097 0.292</span></span>
<span><span class="co">## [61] 0.001 0.217 0.237 0.127 0.145 0.344 0.008 0.340 0.079 0.300 0.033 0.142</span></span>
<span><span class="co">## [73] 0.001 0.001 0.461 0.005 0.212 0.384 0.110 0.409 0.455 0.353 0.006 0.287</span></span>
<span><span class="co">## [85] 0.128</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="local-join-count">4.5 Local Join Count<a class="anchor" aria-label="anchor" href="#local-join-count"></a>
</h3>
<p>Local Join Count is a method to identify local clusters for binary
data by using a local version of the so-called BB join count statistic.
The statistic is only meaningful for those observations with value 1.
For more details, please read <a href="http://geodacenter.github.io/workbook/6d_local_discrete/lab6d.html" class="external-link uri">http://geodacenter.github.io/workbook/6d_local_discrete/lab6d.html</a></p>
<p>For example, we can call the function <code><a href="../reference/local_joincount.html">local_joincount()</a></code>
with a Queen weights and the data “TopCrm”, which is a set of binary
(0,1) values, as input parameters:</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">top_crm</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="st">'TopCrm'</span><span class="op">]</span></span>
<span><span class="va">localjc_crm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_joincount.html">local_joincount</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">top_crm</span><span class="op">)</span></span></code></pre></div>
<p>To get the pseudo-p values of the local Join Count computation:</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">localjc_crm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.395 0.085 0.094    NA    NA    NA 0.255    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [13]    NA    NA    NA    NA    NA    NA 0.170 0.242 0.394    NA    NA    NA</span></span>
<span><span class="co">## [25]    NA    NA 0.111    NA    NA    NA    NA    NA    NA 0.095    NA    NA</span></span>
<span><span class="co">## [37] 0.189    NA    NA 0.284    NA    NA    NA    NA    NA    NA 0.218 0.378</span></span>
<span><span class="co">## [49]    NA 0.367 0.037 0.233 0.174 0.392    NA 0.282 0.028 0.370 0.298 0.106</span></span>
<span><span class="co">## [61]    NA    NA    NA    NA    NA    NA    NA    NA 0.009 0.325    NA    NA</span></span>
<span><span class="co">## [73]    NA    NA    NA 0.041    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [85]    NA</span></span></code></pre>
<p>To get the cluster indicators of the local Join Count
computation:</p>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">localjc_crm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [39] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 0 0 0</span></span></code></pre>
<p>To get the number of neighbors of the local Join Count
computation:</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_num_nbrs.html">lisa_num_nbrs</a></span><span class="op">(</span><span class="va">localjc_crm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 4 6 6 4 3 7 3 3 5 5 7 3 3 6 5 5 6 6 7 3 6 7 2 5 6 6 2 6 6 6 4 4 6 6 5 6 5 4</span></span>
<span><span class="co">## [39] 6 7 5 4 7 6 6 5 8 4 6 6 5 4 5 4 2 6 3 6 6 2 6 3 3 2 4 2 4 5 7 6 2 3 8 6 5 5</span></span>
<span><span class="co">## [77] 5 6 3 6 4 6 6 6 5</span></span></code></pre>
<div class="section level4">
<h4 id="bivariate-and-multivariate-local-join-count">4.6 Bivariate and Multivariate Local Join Count:<a class="anchor" aria-label="anchor" href="#bivariate-and-multivariate-local-join-count"></a>
</h4>
<p>Bivariate Local Join Count means, in a bivariate local join count,
the two events cannot happen in the same location. It is also called
“no-colocation” join count. To demonstrate this function, we manually
create a new variable:</p>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">inv_crm</span> <span class="op">&lt;-</span> <span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">[</span>,<span class="st">"TopCrm"</span><span class="op">]</span><span class="op">)</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="co"># create no-location case</span></span>
<span><span class="va">guerry</span><span class="op">[</span><span class="st">'Inv_Crm'</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">inv_crm</span></span></code></pre></div>
<p>Now, top_crm and inv_crm are no-colocation bivariate cases. Then, we
apply the local_bijoicount():</p>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">jc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_bijoincount.html">local_bijoincount</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'TopCrm'</span>, <span class="st">'Inv_Crm'</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>In case of co-location, a warning message will be raised “The
bivariate local join count only applies on two variables with
no-colocation.” , and one can use pygeoda.local_multijoincount() for
co-location case.</p>
<p>To get the cluster indicators of the multivariate local join count
computation:</p>
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">jc</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.106 0.013 0.017    NA    NA    NA 0.035    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [13]    NA    NA 0.135    NA    NA    NA 0.040 0.024 0.296    NA    NA    NA</span></span>
<span><span class="co">## [25]    NA    NA    NA    NA    NA    NA 0.208    NA    NA 0.398    NA    NA</span></span>
<span><span class="co">## [37] 0.047    NA    NA 0.407    NA    NA    NA    NA    NA    NA 0.487 0.098</span></span>
<span><span class="co">## [49]    NA 0.292 0.007 0.416 0.035 0.101    NA 0.076    NA 0.305 0.086    NA</span></span>
<span><span class="co">## [61]    NA    NA    NA    NA    NA    NA    NA    NA 0.001 0.100    NA    NA</span></span>
<span><span class="co">## [73]    NA    NA    NA 0.005    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [85]    NA</span></span></code></pre>
<p>To get the cluster indicators of the local Join Count
computation:</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">jc</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0</span></span>
<span><span class="co">## [39] 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 0 0 0</span></span></code></pre>
<p>Co-location Local Join Count is for where two or more events happen
in the same location. Therefore, the function local_multijoincount takes
a list of variables with 0/1 values as the input parameter:</p>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bin_data</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'TopWealth'</span>,<span class="st">'TopWealth'</span>, <span class="st">'TopLit'</span><span class="op">)</span><span class="op">]</span> </span>
<span><span class="va">jc</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_multijoincount.html">local_multijoincount</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">bin_data</span><span class="op">)</span></span></code></pre></div>
<p>To get the cluster indicators of the multivariate local join count
computation:</p>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">jc</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1]    NA    NA    NA 0.256 0.205    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [13]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [25]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [37] 0.319    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [49]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [61]    NA 0.175 0.192    NA    NA    NA    NA 0.051    NA    NA    NA    NA</span></span>
<span><span class="co">## [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA 0.348</span></span>
<span><span class="co">## [85]    NA</span></span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="quantile-lisa">4.7 Quantile LISA<a class="anchor" aria-label="anchor" href="#quantile-lisa"></a>
</h3>
<p>The quantile local spatial autocorrelation converte the continuous
variable to a binary variable that takes the value of 1 for a specific
quantile. Then appaly a local join count to the data converted. Two
input parameters, k and q, need to be specified in the function
pygeoda.quantile_lisa(): k is the number of quantiles (k &gt; 2), and
the q is the index of selected quantile lisa ranging from 1 to k.</p>
<p>For example, the examples in section 4.1.5 can be simply implemented
as</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">qsa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_quantilelisa.html">local_quantilelisa</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">crm_prp</span>, <span class="fl">5</span>, <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<p>To get the p-values and cluster indicators of the quantile LISA
computation:</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0.419    NA    NA    NA    NA 0.376    NA 0.442    NA 0.257    NA    NA</span></span>
<span><span class="co">## [13]    NA 0.082 0.348    NA 0.277 0.010    NA    NA 0.090 0.387    NA    NA</span></span>
<span><span class="co">## [25]    NA    NA    NA    NA    NA 0.271    NA 0.447    NA    NA    NA    NA</span></span>
<span><span class="co">## [37]    NA    NA    NA 0.026 0.003    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [49]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [61] 0.001    NA 0.465    NA    NA    NA    NA    NA 0.378    NA    NA    NA</span></span>
<span><span class="co">## [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [85]    NA</span></span></code></pre>
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [39] 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 0 0 0</span></span></code></pre>
<p>Multivariate Quantile LISA</p>
<p>For multiple variables, the Quantile LISA can automatiaclly detect if
it is the case of no-colocation, in which local_bijoincount() will be
called internally, or the case of co-location, in which
local_multijoincount() will be called internally.</p>
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">qsa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_multiquantilelisa.html">local_multiquantilelisa</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"TopCrm"</span>, <span class="st">"TopLit"</span><span class="op">)</span><span class="op">]</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">5</span>,<span class="fl">5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>To get the p-values and cluster indicators of the quantile LISA
computation:</p>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1]    NA 0.122    NA    NA    NA    NA 0.023    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [13]    NA    NA    NA    NA    NA    NA 0.137    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [25]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [37] 0.412    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [49]    NA 0.111    NA 0.323 0.012    NA    NA    NA    NA 0.465    NA    NA</span></span>
<span><span class="co">## [61]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [73]    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA</span></span>
<span><span class="co">## [85]    NA</span></span></code></pre>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">qsa</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [39] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span></span>
<span><span class="co">## [77] 0 0 0 0 0 0 0 0 0</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="bivariate-local-moran">4.8 Bivariate Local Moran<a class="anchor" aria-label="anchor" href="#bivariate-local-moran"></a>
</h3>
<p>The bivariate Local Moran’s I captures the relationship between the
value for one variable at location i, and the average of the neighboring
values for another variable. Please note this statistic needs to be
interpreted with caution, since it ignores in-situ correlation between
the two variables. The most meaningful application of the bivariate
Local Moran statistic is comparing the same variable at two time
periods. See: <a href="https://geodacenter.github.io/workbook/6c_local_multi/lab6c.html#bivariate-local-moran" class="external-link uri">https://geodacenter.github.io/workbook/6c_local_multi/lab6c.html#bivariate-local-moran</a></p>
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">qsa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_bimoran.html">local_bimoran</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'Crm_prs'</span>, <span class="st">'Litercy'</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="spatial-clustering">5 Spatial Clustering<a class="anchor" aria-label="anchor" href="#spatial-clustering"></a>
</h2>
<p>Spatial clustering aims to group of a large number of geographic
areas or points into a smaller number of regions based on similiarities
in one or more variables. Spatially constrained clustering is needed
when clusters are required to be spatially contiguous.</p>
<p>There are three different approaches explicitly incorporate the
contiguity constraint in the optimization process: SKATER, Redcap and
Max-p. For more details, please read: * <a href="http://geodacenter.github.io/workbook/9c_spatial3/lab9c.html" class="external-link uri">http://geodacenter.github.io/workbook/9c_spatial3/lab9c.html</a>
* <a href="http://geodacenter.github.io/workbook/9d_spatial4/lab9d.html" class="external-link uri">http://geodacenter.github.io/workbook/9d_spatial4/lab9d.html</a></p>
<p>For example, to apply spatial clustering on the Guerry dataset, we
use the queen weights to define the spatial contiguity and select 6
variables for similarity measure: “Crm_prs”, “Crm_prp”, “Litercy”,
“Donatns”, “Infants”, “Suicids”.</p>
<div class="sourceCode" id="cb103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'Crm_prs'</span>,<span class="st">'Crm_prp'</span>,<span class="st">'Litercy'</span>,<span class="st">'Donatns'</span>,<span class="st">'Infants'</span>,<span class="st">'Suicids'</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<div class="section level3">
<h3 id="skater">5.1 SKATER<a class="anchor" aria-label="anchor" href="#skater"></a>
</h3>
<p>The Spatial C(K)luster Analysis by Tree Edge Removal(SKATER)
algorithm introduced by Assuncao et al. (2006) is based on the optimal
pruning of a minimum spanning tree that reflects the contiguity
structure among the observations. It provides an optimized algorithm to
prune to tree into several clusters that their values of selected
variables are as similar as possible.</p>
<p>The <code>rgeoda</code>’s SKATER function is:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" tabindex="-1"></a><span class="fu">skater</span>(k, w, data, <span class="at">distance_method=</span><span class="st">'euclidean'</span>, <span class="at">bound_vals =</span> [],  <span class="at">min_bound =</span> <span class="dv">0</span>, <span class="at">random_seed=</span><span class="dv">123456789</span>)</span></code></pre></div>
<p>For example, to create 4 spatially contiguous clusters using Guerry
dataset, the queen weights and the values of the 6 selected
variables:</p>
<div class="sourceCode" id="cb105"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">guerry_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/skater.html">skater</a></span><span class="op">(</span><span class="fl">4</span>, <span class="va">queen_w</span>, <span class="va">data</span><span class="op">)</span></span>
<span><span class="va">guerry_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 3 2 3 1 1 1 2 1 2 1 1 1 2 1 1 3 3 3 2 4 3 1 2 1 2 2 4 1 1 1 1 1 4 3 4 1 2 1</span></span>
<span><span class="co">## [39] 4 3 3 4 2 1 1 1 4 4 2 2 4 2 2 4 2 3 2 2 4 2 3 1 1 1 2 2 1 2 3 4 2 2 2 2 3 2</span></span>
<span><span class="co">## [77] 1 1 1 1 3 3 3 2 2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 57.89077 59.95242 28.72571 69.38030 62.30781 66.65809</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 159.0849</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.3156447</span></span></code></pre>
<p>This skater() function returns a names list with names “Clusters”,
“Total sum of squares”, “Within-cluster sum of squares”, “Total
within-cluster sum of squares”, and “The ratio of between to total sum
of squares”.</p>
</div>
<div class="section level3">
<h3 id="redcap">5.2 REDCAP<a class="anchor" aria-label="anchor" href="#redcap"></a>
</h3>
<p>REDCAP (Regionalization with dynamically constrained agglomerative
clustering and partitioning) is developed by D. Guo (2008). Like SKATER,
REDCAP starts from building a spanning tree in 3 different ways
(single-linkage, average-linkage, and the complete-linkage). The
single-linkage way leads to build a minimum spanning tree. Then, REDCAP
provides 2 different ways (first-order and full-order constraining) to
prune the tree to find clusters. The first-order approach with a minimum
spanning tree is the same as SKATER. In <code>GeoDa</code> and
<code>rgeoda</code>, the following methods are provided:</p>
<ul>
<li>First-order and Single-linkage</li>
<li>Full-order and Complete-linkage</li>
<li>Full-order and Average-linkage</li>
<li>Full-order and Single-linkage</li>
<li>Full-order and Wards-linkage</li>
</ul>
<p>For example, to find 4 clusters using the same dataset and weights as
above using REDCAP with Full-order and Complete-linkage method:</p>
<div class="sourceCode" id="cb107"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">redcap_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/redcap.html">redcap</a></span><span class="op">(</span><span class="fl">4</span>, <span class="va">queen_w</span>, <span class="va">data</span>, <span class="st">"fullorder-completelinkage"</span><span class="op">)</span></span>
<span><span class="va">redcap_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 1 2 1 3 3 1 2 3 2 3 3 3 2 1 1 1 1 1 2 1 1 1 2 3 2 2 1 3 3 3 3 3 1 1 1 3 2 3</span></span>
<span><span class="co">## [39] 1 1 4 1 2 3 3 3 1 1 2 2 1 2 2 1 2 1 2 2 1 2 1 3 3 3 2 2 3 2 1 1 2 2 2 2 1 2</span></span>
<span><span class="co">## [77] 3 3 3 3 1 1 1 2 2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 59.33033 55.01580 28.20272 68.58974 61.27232 54.63519</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 176.9539</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.351099</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="spatially-constrained-hierarchical-clucstering">5.3 Spatially Constrained Hierarchical Clucstering<a class="anchor" aria-label="anchor" href="#spatially-constrained-hierarchical-clucstering"></a>
</h3>
<p>Spatially constrained hierarchical clustering is a special form of
constrained clustering, where the constraint is based on contiguity
(common borders). The method builds up the clusters using agglomerative
hierarchical clustering methods: single linkage, complete linkage,
average linkage and Ward’s method (a special form of centroid linkage).
Meanwhile, it also maintains the spatial contiguity when merging two
clusters.</p>
<p>For example, to find 4 spatially constrained clusters using the same
dataset and weights as above using Complete-linkage method:</p>
<div class="sourceCode" id="cb109"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">schc_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/schc.html">schc</a></span><span class="op">(</span><span class="fl">4</span>, <span class="va">queen_w</span>, <span class="va">data</span>, <span class="st">"complete"</span><span class="op">)</span></span>
<span><span class="va">schc_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 4 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span>
<span><span class="co">## [39] 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span>
<span><span class="co">## [77] 1 1 1 1 1 1 1 1 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 78.13831 54.75868 81.49771 63.48675 80.60111 65.74389</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 79.77355</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.1582809</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="azp">5.4 AZP<a class="anchor" aria-label="anchor" href="#azp"></a>
</h3>
<p>The automatic zoning procedure (AZP) was initially outlined in
Openshaw (1977) as a way to address some of the consequences of the
modifiable areal unit problem (MAUP). In essence, it consists of a
heuristic to find the best set of combinations of contiguous spatial
units into p regions, minimizing the within-sum of squares as a
criterion of homogeneity. The number of regions needs to be specified
beforehand, as in most other clustering methods considered so far.</p>
<p><code>rgeoda</code> provides three different heuristic algorithms to
find an optimal solution for AZP:</p>
<ul>
<li>greedy</li>
<li>Tabu Search</li>
<li>Simulated Annealing</li>
</ul>
<div class="section level4">
<h4 id="azp-greedy">5.4.1 AZP greedy<a class="anchor" aria-label="anchor" href="#azp-greedy"></a>
</h4>
<p>The original AZP heuristic is a local optimization procedure that
cycles through a series of possible swaps between spatial units at the
boundary of a set of regions. The process starts with an initial
feasible solution, i.e., a grouping of n spatial units into p contiguous
regions. This initial solution can be constructed in several different
ways. The initial solution must satisfy the contiguity constraints. For
example, this can be accomplished by growing a set of contiguous regions
from p randomly selected seed units by adding neighboring locations
until the contiguity constraint can no longer be met.</p>
<div class="sourceCode" id="cb111"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">azp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/azp_greedy.html">azp_greedy</a></span><span class="op">(</span><span class="fl">5</span>, <span class="va">queen_w</span>, <span class="va">data</span><span class="op">)</span></span>
<span><span class="va">azp_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 5 2 3 1 1 1 2 1 2 1 1 1 2 1 4 4 3 4 2 3 3 1 2 1 2 2 3 1 1 1 1 1 3 3 3 1 2 1</span></span>
<span><span class="co">## [39] 2 3 1 3 2 1 1 1 3 3 2 2 3 2 2 3 2 3 2 2 3 2 1 1 1 1 2 2 1 2 3 3 2 2 2 2 4 2</span></span>
<span><span class="co">## [77] 1 1 1 1 4 4 4 2 2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 47.20703 60.10165 32.71213 57.69760 59.41673 65.49840</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 181.3665</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.3598541</span></span></code></pre>
</div>
<div class="section level4">
<h4 id="azp-simulated-annealing">5.4.2 AZP Simulated Annealing<a class="anchor" aria-label="anchor" href="#azp-simulated-annealing"></a>
</h4>
<p>To call AZP simulate annealing algorithm, one needs to specify
cooling_rate (default: 0.85):</p>
<div class="sourceCode" id="cb113"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">azp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/azp_sa.html">azp_sa</a></span><span class="op">(</span><span class="fl">5</span>, <span class="va">queen_w</span>, <span class="va">data</span>, cooling_rate <span class="op">=</span> <span class="fl">0.85</span><span class="op">)</span></span>
<span><span class="va">azp_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 5 2 3 1 1 1 2 1 2 1 1 1 2 1 4 4 3 4 2 3 3 1 2 1 2 2 3 1 1 1 1 1 3 3 3 1 2 1</span></span>
<span><span class="co">## [39] 3 3 1 3 2 1 1 1 3 3 2 2 3 2 2 3 2 3 2 2 3 2 1 1 1 1 2 2 1 2 3 3 2 2 2 2 4 2</span></span>
<span><span class="co">## [77] 1 1 1 1 4 4 4 2 2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 47.86263 61.08506 29.62824 58.04068 60.31298 66.23291</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 180.8375</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.3588045</span></span></code></pre>
</div>
<div class="section level4">
<h4 id="azp-tabu-search">5.4.3 AZP Tabu Search<a class="anchor" aria-label="anchor" href="#azp-tabu-search"></a>
</h4>
<p>To call AZP Tabu search algorithm, one needs to specify tabu_length
(deafult: 10) , or conv_tabu (default: 10):</p>
<div class="sourceCode" id="cb115"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">azp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/azp_tabu.html">azp_tabu</a></span><span class="op">(</span><span class="fl">5</span>, <span class="va">queen_w</span>, <span class="va">data</span>, tabu_length <span class="op">=</span> <span class="fl">10</span>, conv_tabu <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">azp_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 4 1 2 3 3 3 1 3 1 3 3 3 2 4 2 2 2 2 1 2 4 2 1 3 1 1 2 3 3 3 2 3 2 2 2 3 1 2</span></span>
<span><span class="co">## [39] 2 4 4 2 1 3 2 3 2 2 1 1 2 1 1 2 1 2 1 1 2 1 4 3 3 3 1 1 3 1 4 2 1 1 1 1 5 1</span></span>
<span><span class="co">## [77] 3 3 3 3 5 5 2 1 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 52.20796 39.86439 30.75532 54.95106 54.00440 59.41931</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 212.7976</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.4222174</span></span></code></pre>
<p>NOTE: the AZP algorithm is very sensitive to the initial positions
for constructing final solutions. Therefore, the random seed, which is
used to determine the initial positions, could be used to execute
several rounds of max-p algorithms for sensitive analysis.</p>
</div>
</div>
<div class="section level3">
<h3 id="max-p">5.5 Max-p<a class="anchor" aria-label="anchor" href="#max-p"></a>
</h3>
<p>The so-called max-p regions model (outlined in Duque, Anselin, and
Rey 2012) uses a different approach and considers the regionalization
problem as an application of integer programming. Besides, the number of
regions is determined endogenously.</p>
<p>The algorithm itself consists of a search process that starts with an
initial feasible solution and iteratively improves upon it while
maintaining contiguity among the elements of each cluster.
<code>rgeoda</code> provides three different heuristic algorithms to
find an optimal solution for max-p:</p>
<ul>
<li>greedy</li>
<li>Tabu Search</li>
<li>Simulated Annealing</li>
</ul>
<p>Unlike SKATER and REDCAP that one can specify the number of clusters
as an input parameter, max-p doesn’t allow to specify the number of
clusters explicitly, but a constrained variable and the minimum bounding
value that each cluster should reach that are used to find an optimized
number of clusters.</p>
</div>
<div class="section level3">
<h3 id="max-p-greedy">5.5.1 Max-p greedy<a class="anchor" aria-label="anchor" href="#max-p-greedy"></a>
</h3>
<p>For example, to use the <code>greedy</code> algorithm in maxp
function with the same dataset and weights as above to find optimal
clusters using max-p:</p>
<p>First, we need to specify, for example, every cluster must have
population &gt;= 3236.67 thousand people:</p>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">bound_vals</span> <span class="op">&lt;-</span> <span class="va">guerry</span><span class="op">[</span><span class="st">'Pop1831'</span><span class="op">]</span></span>
<span><span class="va">min_bound</span> <span class="op">&lt;-</span> <span class="fl">3236.67</span> <span class="co"># 10% of Pop1831</span></span></code></pre></div>
<p>Then, we can call the max-p function with the “greedy” algorithm, the
bound values, and minimum bound value:</p>
<div class="sourceCode" id="cb118"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">maxp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_greedy.html">maxp_greedy</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span><span class="op">)</span></span>
<span><span class="va">maxp_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 7 2 7 1 1 1 2 3 6 3 1 1 8 7 4 4 5 7 2 4 7 3 6 1 8 8 4 1 3 3 3 1 4 5 5 7 2 3</span></span>
<span><span class="co">## [39] 5 7 7 4 8 1 3 1 5 5 6 6 5 6 2 4 6 5 2 2 5 8 7 3 3 3 6 6 2 6 2 5 8 8 2 8 4 8</span></span>
<span><span class="co">## [77] 1 1 1 1 4 4 4 6 2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 44.39253 37.80089 28.19168 53.09362 48.11754 48.21628</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 244.1875</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.4844989</span></span></code></pre>
<pre><code>Note: the results of max-p may be different with GeoDa desktop software, it is caused by the different implementation of boost::unordered_map in version 1.58 (used in GeoDa) and version 1.75 (used in rgeoda via BH package). The keys in boost::unordered_map are not ordered and have different orders in the two Boost versions we used. This involves a different mechanism of randomness in max-p algorithm when picking which area or region to process. Therefore, the results might be slightly different. This is normal and shows the sensitiveness of the max-p algorithm: see https://geodacenter.github.io/workbook/9d_spatial4/lab9d.html#max-p-region-problem for more about sensitivy study of max-p algorithm.

If you want to replicate the identical results as in GeoDa software v1.18.0, please install BH == 1.58.0-1 and build/install rgeoda from source using: devtools::install_github("lixun910/rgeoda")</code></pre>
</div>
<div class="section level3">
<h3 id="max-p-tabu-search">5.5.2 Max-p Tabu Search<a class="anchor" aria-label="anchor" href="#max-p-tabu-search"></a>
</h3>
<p>To use <code>tabu search</code> algorithm in maxp function, we can
specify the parameters of tabu_length and conv_tabu:</p>
<div class="sourceCode" id="cb121"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">maxp_tabu_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_tabu.html">maxp_tabu</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span>, tabu_length<span class="op">=</span><span class="fl">10</span>, conv_tabu<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">maxp_tabu_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 2 5 1 3 3 1 5 1 4 1 1 3 6 1 2 7 2 7 5 8 2 7 4 3 6 6 8 3 1 1 7 3 8 2 7 3 5 7</span></span>
<span><span class="co">## [39] 2 2 1 8 6 1 7 3 2 2 4 5 8 4 4 8 4 2 5 5 2 6 1 1 1 1 4 4 3 4 2 2 6 6 5 6 2 6</span></span>
<span><span class="co">## [77] 1 1 3 3 8 7 7 4 5</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 37.71292 53.00122 24.16448 61.51004 53.23544 33.45476</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 240.9211</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.4780181</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="max-p-simulated-annealing">5.5.3 Max-p Simulated Annealing<a class="anchor" aria-label="anchor" href="#max-p-simulated-annealing"></a>
</h3>
<p>To apply <code>simulated annealing</code> algorithm in maxp function
with the parameter of cooling rate:</p>
<div class="sourceCode" id="cb123"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">maxp_sa_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_sa.html">maxp_sa</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span>, cooling_rate<span class="op">=</span><span class="fl">0.85</span>, sa_maxit<span class="op">=</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">maxp_sa_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 2 3 7 5 5 7 3 1 6 1 7 5 8 7 4 4 2 7 3 4 7 7 6 5 8 8 4 5 1 1 1 5 4 2 2 5 3 1</span></span>
<span><span class="co">## [39] 2 7 7 4 8 1 1 5 2 2 6 6 2 6 3 4 6 2 3 3 2 3 7 1 1 1 6 6 5 6 2 2 8 8 3 8 4 3</span></span>
<span><span class="co">## [77] 1 1 5 5 4 4 4 6 3</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 44.78939 44.22570 24.40716 52.89492 50.78755 36.79676</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 250.0985</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.4962272</span></span></code></pre>
<p>We can also increase the number of iterations for local search
process by specifying the parameter <code>iterations</code> (default
value is 99):</p>
<div class="sourceCode" id="cb125"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">maxp_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/maxp_greedy.html">maxp_greedy</a></span><span class="op">(</span><span class="va">queen_w</span>, <span class="va">data</span>, <span class="va">bound_vals</span>, <span class="va">min_bound</span>, iterations<span class="op">=</span><span class="fl">199</span><span class="op">)</span></span>
<span><span class="va">maxp_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">## $Clusters</span></span>
<span><span class="co">##  [1] 7 2 7 1 1 1 2 3 6 3 1 1 8 7 4 4 5 7 2 4 7 3 6 1 8 8 4 1 3 3 3 1 4 5 5 7 2 3</span></span>
<span><span class="co">## [39] 5 7 7 4 8 1 3 1 5 5 6 6 5 6 2 4 6 5 2 2 5 8 7 3 3 3 6 6 2 6 2 5 8 8 2 8 4 8</span></span>
<span><span class="co">## [77] 1 1 1 1 4 4 4 6 2</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total sum of squares`</span></span>
<span><span class="co">## [1] 504</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 44.39253 37.80089 28.19168 53.09362 48.11754 48.21628</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`Total within-cluster sum of squares`</span></span>
<span><span class="co">## [1] 244.1875</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`The ratio of between to total sum of squares`</span></span>
<span><span class="co">## [1] 0.4844989</span></span></code></pre>
<p>NOTE: the max-p algorithm is very sensitive to the initial positions
for constructing final solutions. Therefore, the random seed, which is
used to determine the initial positions, could be used to execute
several rounds of max-p algorithms for sensitive analysis.</p>
</div>
</div>
<div class="section level2">
<h2 id="exploratory-spatial-data-analysis">6 Exploratory Spatial Data Analysis<a class="anchor" aria-label="anchor" href="#exploratory-spatial-data-analysis"></a>
</h2>
<p>For exploratory spatial data analysis (ESDA), rgeoa provides some
utility functions to allow users to easily work with sf to visualize the
results and do exploratory spatial data analysis.</p>
<div class="section level3">
<h3 id="start-from-sf-package">6.1 Start from <code>sf</code> package<a class="anchor" aria-label="anchor" href="#start-from-sf-package"></a>
</h3>
<p>The sf package has been popular tool to handle geospatial data. It is
a good substitue of sp package which will be deprecated soon.</p>
<p>For example, we can simply call plot() function to render the first 9
chorepleth maps using the frist 9 variables in the dataset:</p>
<div class="sourceCode" id="cb127"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning: plotting the first 9 out of 30 attributes; use max.plot = 30 to plot</span></span>
<span><span class="co">## all</span></span></code></pre>
<p><img src="rgeoda_tutorial_files/figure-html/unnamed-chunk-62-1.png" width="576"></p>
</div>
<div class="section level3">
<h3 id="esda-with-rgeoda">6.2 ESDA with rgeoda<a class="anchor" aria-label="anchor" href="#esda-with-rgeoda"></a>
</h3>
<p>Now, with the sf object <code>guerry</code>, you can call rgeoda’s
spatial analysis functions. For example, to examine the local Moran
statistics of variable “crm_prs” (Population per Crime against
persons):</p>
<div class="sourceCode" id="cb129"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">queen_w</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/queen_weights.html">queen_weights</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span></span>
<span><span class="va">lisa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/local_moran.html">local_moran</a></span><span class="op">(</span><span class="va">queen_w</span>,  <span class="va">guerry</span><span class="op">[</span><span class="st">'Crm_prs'</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>Note: rgeoda uses wkb, which is a binary representation of
geometries, to exchange data between sf and libgeoda in memory.</p>
</div>
<div class="section level3">
<h3 id="create-local-moran-map">6.3 Create Local Moran Map<a class="anchor" aria-label="anchor" href="#create-local-moran-map"></a>
</h3>
<p>With the LISA results, we can make a local moran cluster map:</p>
<div class="sourceCode" id="cb130"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lisa_colors</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_colors.html">lisa_colors</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span></span>
<span><span class="va">lisa_labels</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_labels.html">lisa_labels</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span></span>
<span><span class="va">lisa_clusters</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_clusters.html">lisa_clusters</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html" class="external-link">st_geometry</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>, </span>
<span>     col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">lisa_clusters</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span><span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">lisa_colors</span><span class="op">[[</span><span class="va">x</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">}</span><span class="op">)</span>, </span>
<span>     border <span class="op">=</span> <span class="st">"#333333"</span>, lwd<span class="op">=</span><span class="fl">0.2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span>main <span class="op">=</span> <span class="st">"Local Moran Map of Crm_prs"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">'bottomleft'</span>, legend <span class="op">=</span> <span class="va">lisa_labels</span>, fill <span class="op">=</span> <span class="va">lisa_colors</span>, border <span class="op">=</span> <span class="st">"#eeeeee"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rgeoda_tutorial_files/figure-html/unnamed-chunk-64-1.png" width="576"></p>
<p>In the above code, we use th values of cluster indicators from
<code>rgeoda</code>’s <code>LISA</code> object are used to make the LISA
map. We can save the clusters back to the original <code>sf</code>
data.frame:</p>
<div class="sourceCode" id="cb131"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">guerry</span><span class="op">[</span><span class="st">'moran_cluster'</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lisa_clusters</span></span></code></pre></div>
<p>Checking the values of the cluster indicators, we will see they are
integer numbers 0 (not significant), 1 (high-high cluster), 2 (low-low
cluster), 3 (low-high cluster), 4 (high-low cluster), 5
(neighborless/island), 6 (undefined):</p>
<div class="sourceCode" id="cb132"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lisa_clusters</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 0 1 1 0 0 2 0 2 0 2 2 0 0 2 0 0 1 0 0 0 0 0 0 2 0 0 0 2 2 0 0 2 1 0 3 0 0 0</span></span>
<span><span class="co">## [39] 0 0 0 0 0 0 0 2 0 0 3 0 1 0 0 0 0 0 1 0 0 1 0 0 0 2 0 0 0 0 1 1 0 0 0 0 0 0</span></span>
<span><span class="co">## [77] 2 2 0 2 0 0 0 0 0</span></span></code></pre>
<p>To create a significance map that is associated with the local Moran
map, we can do the same as making the local moran cluster map using the
results from lisa_pvalues():</p>
<div class="sourceCode" id="cb134"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lisa_p</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/lisa_pvalues.html">lisa_pvalues</a></span><span class="op">(</span><span class="va">lisa</span><span class="op">)</span></span>
<span><span class="va">p_labels</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Not significant"</span>, <span class="st">"p &lt;= 0.05"</span>, <span class="st">"p &lt;= 0.01"</span>, <span class="st">"p &lt;= 0.001"</span><span class="op">)</span></span>
<span><span class="va">p_colors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"#eeeeee"</span>, <span class="st">"#84f576"</span>, <span class="st">"#53c53c"</span>, <span class="st">"#348124"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html" class="external-link">st_geometry</a></span><span class="op">(</span><span class="va">guerry</span><span class="op">)</span>, </span>
<span>     col<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">lisa_p</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">{</span></span>
<span>       <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">&lt;=</span> <span class="fl">0.001</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span></span>
<span>       <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">&lt;=</span> <span class="fl">0.01</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span></span>
<span>       <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">&lt;=</span> <span class="fl">0.05</span><span class="op">)</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span> <span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span>       <span class="kw">else</span> <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="va">p_colors</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span>       <span class="op">}</span><span class="op">)</span>, </span>
<span>     border <span class="op">=</span> <span class="st">"#333333"</span>, lwd<span class="op">=</span><span class="fl">0.2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span>main <span class="op">=</span> <span class="st">"Local Moran Map of Crm_prs"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">'bottomleft'</span>, legend <span class="op">=</span> <span class="va">p_labels</span>, fill <span class="op">=</span> <span class="va">p_colors</span>, border <span class="op">=</span> <span class="st">"#eeeeee"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rgeoda_tutorial_files/figure-html/unnamed-chunk-67-1.png" width="576"></p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Xun Li, Luc Anselin.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

      </footer>
</div>






  </body>
</html>
