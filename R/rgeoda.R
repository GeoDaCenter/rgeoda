# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -I../../deps/libgeoda/include -o rgeoda.cpp ./rgeoda.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  delayedAssign(defName,  .values, assign.env = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_float_std__allocatorT_float_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_char_std__allocatorT_char_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_int_std__allocatorT_int_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_long_long_std__allocatorT_long_long_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', contains = 'C++Reference')
setClass('_p_GeoDaWeight', contains = 'C++Reference')
setClass('_p_AbstractLocalSA', contains = 'C++Reference')
setClass('_p_UniLisa', contains = c('_p_AbstractLocalSA'))
setClass('_p_GeoDaColumn', contains = 'C++Reference')
setClass('_p_GeoDaIntColumn', contains = c('_p_GeoDaColumn'))
setClass('_p_GeoDaStringColumn', contains = c('_p_GeoDaColumn'))
setClass('_p_GeoDaRealColumn', contains = c('_p_GeoDaColumn'))
setClass('_p_GeoDaTable', contains = 'C++Reference')
setClass('_p_GeoDa', contains = 'C++Reference')
setClass('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of VecVoid___nonzero__

`VecVoid___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid___nonzero__`, 'returnType') = 'logical'
attr(`VecVoid___nonzero__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid___nonzero__`) = c("SWIGFunction", class('VecVoid___nonzero__'))

# Start of VecVoid___len__

`VecVoid___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid___len__`, 'returnType') = 'integer'
attr(`VecVoid___len__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid___len__`) = c("SWIGFunction", class('VecVoid___len__'))

# Start of VecVoid_pop

`VecVoid_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid_pop`, 'returnType') = '_p_void'
attr(`VecVoid_pop`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_pop`) = c("SWIGFunction", class('VecVoid_pop'))

# Start of VecVoid___getslice__

`VecVoid___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVoid___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  ans
  
}

attr(`VecVoid___getslice__`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid___getslice__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', 'integer')
class(`VecVoid___getslice__`) = c("SWIGFunction", class('VecVoid___getslice__'))

# Start of VecVoid___setslice__

`VecVoid___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVoid___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVoid___setslice__`, 'returnType') = 'void'
attr(`VecVoid___setslice__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', 'integer', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid___setslice__`) = c("SWIGFunction", class('VecVoid___setslice__'))

# Start of VecVoid___delslice__

`VecVoid___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVoid___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVoid___delslice__`, 'returnType') = 'void'
attr(`VecVoid___delslice__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', 'integer')
class(`VecVoid___delslice__`) = c("SWIGFunction", class('VecVoid___delslice__'))

# Start of VecVoid___delitem__

`VecVoid___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVoid___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVoid___delitem__`, 'returnType') = 'void'
attr(`VecVoid___delitem__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid___delitem__`) = c("SWIGFunction", class('VecVoid___delitem__'))

# Start of VecVoid___getitem__

`VecVoid___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_VecVoid___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid___getitem__`, 'returnType') = '_p_void'
attr(`VecVoid___getitem__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid___getitem__`) = c("SWIGFunction", class('VecVoid___getitem__'))

# Start of VecVoid___setitem__

`VecVoid___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid___setitem__`, 'returnType') = 'void'
attr(`VecVoid___setitem__`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', '_p_void')
class(`VecVoid___setitem__`) = c("SWIGFunction", class('VecVoid___setitem__'))

# Start of VecVoid_append

`VecVoid_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_append`, 'returnType') = 'void'
attr(`VecVoid_append`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', '_p_void')
class(`VecVoid_append`) = c("SWIGFunction", class('VecVoid_append'))

# Start of new_VecVoid

`VecVoid__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVoid__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_0`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
class(`VecVoid__SWIG_0`) = c("SWIGFunction", class('VecVoid__SWIG_0'))

# Start of new_VecVoid

`VecVoid__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecVoid__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_1`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid__SWIG_1`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid__SWIG_1`) = c("SWIGFunction", class('VecVoid__SWIG_1'))

# Start of VecVoid_empty

`VecVoid_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid_empty`, 'returnType') = 'logical'
attr(`VecVoid_empty`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_empty`) = c("SWIGFunction", class('VecVoid_empty'))

# Start of VecVoid_size

`VecVoid_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid_size`, 'returnType') = 'integer'
attr(`VecVoid_size`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_size`) = c("SWIGFunction", class('VecVoid_size'))

# Start of VecVoid_swap

`VecVoid_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVoid_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVoid_swap`, 'returnType') = 'void'
attr(`VecVoid_swap`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_swap`) = c("SWIGFunction", class('VecVoid_swap'))

# Start of VecVoid_clear

`VecVoid_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVoid_clear`, 'returnType') = 'void'
attr(`VecVoid_clear`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_clear`) = c("SWIGFunction", class('VecVoid_clear'))

# Start of VecVoid_get_allocator

`VecVoid_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_void_p_t", ref=ans);
  
  ans
  
}

attr(`VecVoid_get_allocator`, 'returnType') = '_p_std__allocatorT_void_p_t'
attr(`VecVoid_get_allocator`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_get_allocator`) = c("SWIGFunction", class('VecVoid_get_allocator'))

# Start of new_VecVoid

`VecVoid__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVoid__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_2`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid__SWIG_2`, "inputTypes") = c('integer')
class(`VecVoid__SWIG_2`) = c("SWIGFunction", class('VecVoid__SWIG_2'))

# Start of VecVoid_pop_back

`VecVoid_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVoid_pop_back`, 'returnType') = 'void'
attr(`VecVoid_pop_back`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_pop_back`) = c("SWIGFunction", class('VecVoid_pop_back'))

# Start of VecVoid_resize

`VecVoid_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVoid_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVoid_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVoid_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid_resize__SWIG_0`) = c("SWIGFunction", class('VecVoid_resize__SWIG_0'))

# Start of new_VecVoid

`VecVoid__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_VecVoid__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_void_p_std__allocatorT_void_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVoid)
  ans
  
}

attr(`VecVoid__SWIG_3`, 'returnType') = '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t'
attr(`VecVoid__SWIG_3`, "inputTypes") = c('integer', '_p_void')
class(`VecVoid__SWIG_3`) = c("SWIGFunction", class('VecVoid__SWIG_3'))

`VecVoid` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVoid__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVoid__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t') && length(argv[[1]]) == 1) {
      f <- VecVoid__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_void') && length(argv[[2]]) == 1) {
      f <- VecVoid__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVoid with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVoid_push_back

`VecVoid_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_push_back`, 'returnType') = 'void'
attr(`VecVoid_push_back`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', '_p_void')
class(`VecVoid_push_back`) = c("SWIGFunction", class('VecVoid_push_back'))

# Start of VecVoid_front

`VecVoid_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_front', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid_front`, 'returnType') = '_p_void'
attr(`VecVoid_front`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_front`) = c("SWIGFunction", class('VecVoid_front'))

# Start of VecVoid_back

`VecVoid_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVoid_back', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_void", ref=ans);
  
  ans
  
}

attr(`VecVoid_back`, 'returnType') = '_p_void'
attr(`VecVoid_back`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_back`) = c("SWIGFunction", class('VecVoid_back'))

# Start of VecVoid_assign

`VecVoid_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_assign`, 'returnType') = 'void'
attr(`VecVoid_assign`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', '_p_void')
class(`VecVoid_assign`) = c("SWIGFunction", class('VecVoid_assign'))

# Start of VecVoid_resize

`VecVoid_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVoid_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVoid_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVoid_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer', '_p_void')
class(`VecVoid_resize__SWIG_1`) = c("SWIGFunction", class('VecVoid_resize__SWIG_1'))

`VecVoid_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVoid_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_void') && length(argv[[3]]) == 1) {
      f <- VecVoid_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVoid_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVoid_reserve

`VecVoid_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVoid_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVoid_reserve`, 'returnType') = 'void'
attr(`VecVoid_reserve`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', 'integer')
class(`VecVoid_reserve`) = c("SWIGFunction", class('VecVoid_reserve'))

# Start of VecVoid_capacity

`VecVoid_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVoid_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVoid_capacity`, 'returnType') = 'integer'
attr(`VecVoid_capacity`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`VecVoid_capacity`) = c("SWIGFunction", class('VecVoid_capacity'))

# Start of delete_VecVoid

`delete_VecVoid` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVoid', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVoid`, 'returnType') = 'void'
attr(`delete_VecVoid`, "inputTypes") = c('_p_std__vectorT_void_p_std__allocatorT_void_p_t_t')
class(`delete_VecVoid`) = c("SWIGFunction", class('delete_VecVoid'))

# Start of accessor method for std::vector<(p.void)>
setMethod('$', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVoid___nonzero__, '__len__' = VecVoid___len__, 'pop' = VecVoid_pop, '__getslice__' = VecVoid___getslice__, '__setslice__' = VecVoid___setslice__, '__delslice__' = VecVoid___delslice__, '__delitem__' = VecVoid___delitem__, '__getitem__' = VecVoid___getitem__, '__setitem__' = VecVoid___setitem__, 'append' = VecVoid_append, 'empty' = VecVoid_empty, 'size' = VecVoid_size, 'swap' = VecVoid_swap, 'clear' = VecVoid_clear, 'get_allocator' = VecVoid_get_allocator, 'pop_back' = VecVoid_pop_back, 'resize' = VecVoid_resize, 'push_back' = VecVoid_push_back, 'front' = VecVoid_front, 'back' = VecVoid_back, 'assign' = VecVoid_assign, 'reserve' = VecVoid_reserve, 'capacity' = VecVoid_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(p.void)>
setMethod('delete', '_p_std__vectorT_void_p_std__allocatorT_void_p_t_t', function(obj) {delete_std__vectorT_void_p_std__allocatorT_void_p_t_t(obj)})
# Start of VecFloat___nonzero__

`VecFloat___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat___nonzero__`, 'returnType') = 'logical'
attr(`VecFloat___nonzero__`, "inputTypes") = c('numeric')
class(`VecFloat___nonzero__`) = c("SWIGFunction", class('VecFloat___nonzero__'))

# Start of VecFloat___len__

`VecFloat___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat___len__`, 'returnType') = 'integer'
attr(`VecFloat___len__`, "inputTypes") = c('numeric')
class(`VecFloat___len__`) = c("SWIGFunction", class('VecFloat___len__'))

# Start of VecFloat_pop

`VecFloat_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_pop`, 'returnType') = 'numeric'
attr(`VecFloat_pop`, "inputTypes") = c('numeric')
class(`VecFloat_pop`) = c("SWIGFunction", class('VecFloat_pop'))

# Start of VecFloat___getslice__

`VecFloat___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecFloat___getslice__`, 'returnType') = 'numeric'
attr(`VecFloat___getslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___getslice__`) = c("SWIGFunction", class('VecFloat___getslice__'))

# Start of VecFloat___setslice__

`VecFloat___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecFloat___setslice__`, 'returnType') = 'void'
attr(`VecFloat___setslice__`, "inputTypes") = c('numeric', 'integer', 'integer', 'numeric')
class(`VecFloat___setslice__`) = c("SWIGFunction", class('VecFloat___setslice__'))

# Start of VecFloat___delslice__

`VecFloat___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecFloat___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecFloat___delslice__`, 'returnType') = 'void'
attr(`VecFloat___delslice__`, "inputTypes") = c('numeric', 'integer', 'integer')
class(`VecFloat___delslice__`) = c("SWIGFunction", class('VecFloat___delslice__'))

# Start of VecFloat___delitem__

`VecFloat___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecFloat___delitem__`, 'returnType') = 'void'
attr(`VecFloat___delitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___delitem__`) = c("SWIGFunction", class('VecFloat___delitem__'))

# Start of VecFloat___getitem__

`VecFloat___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecFloat___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat___getitem__`, 'returnType') = 'numeric'
attr(`VecFloat___getitem__`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat___getitem__`) = c("SWIGFunction", class('VecFloat___getitem__'))

# Start of VecFloat___setitem__

`VecFloat___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecFloat___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat___setitem__`, 'returnType') = 'void'
attr(`VecFloat___setitem__`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat___setitem__`) = c("SWIGFunction", class('VecFloat___setitem__'))

# Start of VecFloat_append

`VecFloat_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_append`, 'returnType') = 'void'
attr(`VecFloat_append`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_append`) = c("SWIGFunction", class('VecFloat_append'))

# Start of new_VecFloat

`VecFloat__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecFloat__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_0`, 'returnType') = 'numeric'
class(`VecFloat__SWIG_0`) = c("SWIGFunction", class('VecFloat__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_VecFloat__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_1`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_1`, "inputTypes") = c('numeric')
class(`VecFloat__SWIG_1`) = c("SWIGFunction", class('VecFloat__SWIG_1'))

# Start of VecFloat_empty

`VecFloat_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_empty`, 'returnType') = 'logical'
attr(`VecFloat_empty`, "inputTypes") = c('numeric')
class(`VecFloat_empty`) = c("SWIGFunction", class('VecFloat_empty'))

# Start of VecFloat_size

`VecFloat_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_size`, 'returnType') = 'integer'
attr(`VecFloat_size`, "inputTypes") = c('numeric')
class(`VecFloat_size`) = c("SWIGFunction", class('VecFloat_size'))

# Start of VecFloat_swap

`VecFloat_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecFloat_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecFloat_swap`, 'returnType') = 'void'
attr(`VecFloat_swap`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_swap`) = c("SWIGFunction", class('VecFloat_swap'))

# Start of VecFloat_clear

`VecFloat_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecFloat_clear`, 'returnType') = 'void'
attr(`VecFloat_clear`, "inputTypes") = c('numeric')
class(`VecFloat_clear`) = c("SWIGFunction", class('VecFloat_clear'))

# Start of VecFloat_get_allocator

`VecFloat_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecFloat_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_float_t", ref=ans);
  
  ans
  
}

attr(`VecFloat_get_allocator`, 'returnType') = '_p_std__allocatorT_float_t'
attr(`VecFloat_get_allocator`, "inputTypes") = c('numeric')
class(`VecFloat_get_allocator`) = c("SWIGFunction", class('VecFloat_get_allocator'))

# Start of new_VecFloat

`VecFloat__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecFloat__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_2`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_2`, "inputTypes") = c('integer')
class(`VecFloat__SWIG_2`) = c("SWIGFunction", class('VecFloat__SWIG_2'))

# Start of VecFloat_pop_back

`VecFloat_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecFloat_pop_back`, 'returnType') = 'void'
attr(`VecFloat_pop_back`, "inputTypes") = c('numeric')
class(`VecFloat_pop_back`) = c("SWIGFunction", class('VecFloat_pop_back'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecFloat_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecFloat_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_0`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_resize__SWIG_0`) = c("SWIGFunction", class('VecFloat_resize__SWIG_0'))

# Start of new_VecFloat

`VecFloat__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecFloat__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecFloat__SWIG_3`, 'returnType') = 'numeric'
attr(`VecFloat__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecFloat__SWIG_3`) = c("SWIGFunction", class('VecFloat__SWIG_3'))

`VecFloat` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecFloat__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecFloat__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecFloat__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecFloat__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_push_back

`VecFloat_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecFloat_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_push_back`, 'returnType') = 'void'
attr(`VecFloat_push_back`, "inputTypes") = c('numeric', 'numeric')
class(`VecFloat_push_back`) = c("SWIGFunction", class('VecFloat_push_back'))

# Start of VecFloat_front

`VecFloat_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_front`, 'returnType') = 'numeric'
attr(`VecFloat_front`, "inputTypes") = c('numeric')
class(`VecFloat_front`) = c("SWIGFunction", class('VecFloat_front'))

# Start of VecFloat_back

`VecFloat_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_back`, 'returnType') = 'numeric'
attr(`VecFloat_back`, "inputTypes") = c('numeric')
class(`VecFloat_back`) = c("SWIGFunction", class('VecFloat_back'))

# Start of VecFloat_assign

`VecFloat_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecFloat_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_assign`, 'returnType') = 'void'
attr(`VecFloat_assign`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_assign`) = c("SWIGFunction", class('VecFloat_assign'))

# Start of VecFloat_resize

`VecFloat_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecFloat_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecFloat_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecFloat_resize__SWIG_1`, "inputTypes") = c('numeric', 'integer', 'numeric')
class(`VecFloat_resize__SWIG_1`) = c("SWIGFunction", class('VecFloat_resize__SWIG_1'))

`VecFloat_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecFloat_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecFloat_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecFloat_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecFloat_reserve

`VecFloat_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecFloat_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecFloat_reserve`, 'returnType') = 'void'
attr(`VecFloat_reserve`, "inputTypes") = c('numeric', 'integer')
class(`VecFloat_reserve`) = c("SWIGFunction", class('VecFloat_reserve'))

# Start of VecFloat_capacity

`VecFloat_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecFloat_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecFloat_capacity`, 'returnType') = 'integer'
attr(`VecFloat_capacity`, "inputTypes") = c('numeric')
class(`VecFloat_capacity`) = c("SWIGFunction", class('VecFloat_capacity'))

# Start of delete_VecFloat

`delete_VecFloat` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecFloat', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecFloat`, 'returnType') = 'void'
attr(`delete_VecFloat`, "inputTypes") = c('numeric')
class(`delete_VecFloat`) = c("SWIGFunction", class('delete_VecFloat'))

# Start of accessor method for std::vector<(float)>
setMethod('$', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecFloat___nonzero__, '__len__' = VecFloat___len__, 'pop' = VecFloat_pop, '__getslice__' = VecFloat___getslice__, '__setslice__' = VecFloat___setslice__, '__delslice__' = VecFloat___delslice__, '__delitem__' = VecFloat___delitem__, '__getitem__' = VecFloat___getitem__, '__setitem__' = VecFloat___setitem__, 'append' = VecFloat_append, 'empty' = VecFloat_empty, 'size' = VecFloat_size, 'swap' = VecFloat_swap, 'clear' = VecFloat_clear, 'get_allocator' = VecFloat_get_allocator, 'pop_back' = VecFloat_pop_back, 'resize' = VecFloat_resize, 'push_back' = VecFloat_push_back, 'front' = VecFloat_front, 'back' = VecFloat_back, 'assign' = VecFloat_assign, 'reserve' = VecFloat_reserve, 'capacity' = VecFloat_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(float)>
setMethod('delete', '_p_std__vectorT_float_std__allocatorT_float_t_t', function(obj) {delete_std__vectorT_float_std__allocatorT_float_t_t(obj)})
# Start of VecString___nonzero__

`VecString___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString___nonzero__`, 'returnType') = 'logical'
attr(`VecString___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___nonzero__`) = c("SWIGFunction", class('VecString___nonzero__'))

# Start of VecString___len__

`VecString___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString___len__`, 'returnType') = 'integer'
attr(`VecString___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___len__`) = c("SWIGFunction", class('VecString___len__'))

# Start of VecString_pop

`VecString_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_pop`, 'returnType') = 'character'
attr(`VecString_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop`) = c("SWIGFunction", class('VecString_pop'))

# Start of VecString___getslice__

`VecString___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecString___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`VecString___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___getslice__`) = c("SWIGFunction", class('VecString___getslice__'))

# Start of VecString___setslice__

`VecString___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecString___setslice__`, 'returnType') = 'void'
attr(`VecString___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString___setslice__`) = c("SWIGFunction", class('VecString___setslice__'))

# Start of VecString___delslice__

`VecString___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecString___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecString___delslice__`, 'returnType') = 'void'
attr(`VecString___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`VecString___delslice__`) = c("SWIGFunction", class('VecString___delslice__'))

# Start of VecString___delitem__

`VecString___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecString___delitem__`, 'returnType') = 'void'
attr(`VecString___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___delitem__`) = c("SWIGFunction", class('VecString___delitem__'))

# Start of VecString___getitem__

`VecString___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecString___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString___getitem__`, 'returnType') = 'character'
attr(`VecString___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString___getitem__`) = c("SWIGFunction", class('VecString___getitem__'))

# Start of VecString___setitem__

`VecString___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecString___setitem__`, 'returnType') = 'void'
attr(`VecString___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString___setitem__`) = c("SWIGFunction", class('VecString___setitem__'))

# Start of VecString_append

`VecString_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecString_append`, 'returnType') = 'void'
attr(`VecString_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_append`) = c("SWIGFunction", class('VecString_append'))

# Start of new_VecString

`VecString__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecString__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`VecString__SWIG_0`) = c("SWIGFunction", class('VecString__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecString__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString__SWIG_1`) = c("SWIGFunction", class('VecString__SWIG_1'))

# Start of VecString_empty

`VecString_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_empty`, 'returnType') = 'logical'
attr(`VecString_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_empty`) = c("SWIGFunction", class('VecString_empty'))

# Start of VecString_size

`VecString_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_size`, 'returnType') = 'integer'
attr(`VecString_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_size`) = c("SWIGFunction", class('VecString_size'))

# Start of VecString_swap

`VecString_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecString_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecString_swap`, 'returnType') = 'void'
attr(`VecString_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_swap`) = c("SWIGFunction", class('VecString_swap'))

# Start of VecString_clear

`VecString_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecString_clear`, 'returnType') = 'void'
attr(`VecString_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_clear`) = c("SWIGFunction", class('VecString_clear'))

# Start of VecString_get_allocator

`VecString_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecString_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`VecString_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`VecString_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_get_allocator`) = c("SWIGFunction", class('VecString_get_allocator'))

# Start of new_VecString

`VecString__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecString__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_2`, "inputTypes") = c('integer')
class(`VecString__SWIG_2`) = c("SWIGFunction", class('VecString__SWIG_2'))

# Start of VecString_pop_back

`VecString_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecString_pop_back`, 'returnType') = 'void'
attr(`VecString_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_pop_back`) = c("SWIGFunction", class('VecString_pop_back'))

# Start of VecString_resize

`VecString_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecString_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecString_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_resize__SWIG_0`) = c("SWIGFunction", class('VecString_resize__SWIG_0'))

# Start of new_VecString

`VecString__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_VecString__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecString)
  ans
  
}

attr(`VecString__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VecString__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`VecString__SWIG_3`) = c("SWIGFunction", class('VecString__SWIG_3'))

`VecString` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecString__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecString__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- VecString__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecString__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecString with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_push_back

`VecString_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecString_push_back`, 'returnType') = 'void'
attr(`VecString_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`VecString_push_back`) = c("SWIGFunction", class('VecString_push_back'))

# Start of VecString_front

`VecString_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_front`, 'returnType') = 'character'
attr(`VecString_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_front`) = c("SWIGFunction", class('VecString_front'))

# Start of VecString_back

`VecString_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_back`, 'returnType') = 'character'
attr(`VecString_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_back`) = c("SWIGFunction", class('VecString_back'))

# Start of VecString_assign

`VecString_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecString_assign`, 'returnType') = 'void'
attr(`VecString_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_assign`) = c("SWIGFunction", class('VecString_assign'))

# Start of VecString_resize

`VecString_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_VecString_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecString_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecString_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`VecString_resize__SWIG_1`) = c("SWIGFunction", class('VecString_resize__SWIG_1'))

`VecString_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecString_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecString_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecString_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecString_reserve

`VecString_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecString_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecString_reserve`, 'returnType') = 'void'
attr(`VecString_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`VecString_reserve`) = c("SWIGFunction", class('VecString_reserve'))

# Start of VecString_capacity

`VecString_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecString_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecString_capacity`, 'returnType') = 'integer'
attr(`VecString_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VecString_capacity`) = c("SWIGFunction", class('VecString_capacity'))

# Start of delete_VecString

`delete_VecString` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecString', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecString`, 'returnType') = 'void'
attr(`delete_VecString`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_VecString`) = c("SWIGFunction", class('delete_VecString'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecString___nonzero__, '__len__' = VecString___len__, 'pop' = VecString_pop, '__getslice__' = VecString___getslice__, '__setslice__' = VecString___setslice__, '__delslice__' = VecString___delslice__, '__delitem__' = VecString___delitem__, '__getitem__' = VecString___getitem__, '__setitem__' = VecString___setitem__, 'append' = VecString_append, 'empty' = VecString_empty, 'size' = VecString_size, 'swap' = VecString_swap, 'clear' = VecString_clear, 'get_allocator' = VecString_get_allocator, 'pop_back' = VecString_pop_back, 'resize' = VecString_resize, 'push_back' = VecString_push_back, 'front' = VecString_front, 'back' = VecString_back, 'assign' = VecString_assign, 'reserve' = VecString_reserve, 'capacity' = VecString_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of VecDouble___nonzero__

`VecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecDouble___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___nonzero__`) = c("SWIGFunction", class('VecDouble___nonzero__'))

# Start of VecDouble___len__

`VecDouble___len__` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble___len__`, 'returnType') = 'integer'
attr(`VecDouble___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___len__`) = c("SWIGFunction", class('VecDouble___len__'))

# Start of VecDouble_pop

`VecDouble_pop` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_pop`, 'returnType') = 'numeric'
attr(`VecDouble_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop`) = c("SWIGFunction", class('VecDouble_pop'))

# Start of VecDouble___getslice__

`VecDouble___getslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecDouble___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___getslice__`) = c("SWIGFunction", class('VecDouble___getslice__'))

# Start of VecDouble___setslice__

`VecDouble___setslice__` = function(self, i, j, v)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecDouble___setslice__`, 'returnType') = 'void'
attr(`VecDouble___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble___setslice__`) = c("SWIGFunction", class('VecDouble___setslice__'))

# Start of VecDouble___delslice__

`VecDouble___delslice__` = function(self, i, j)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecDouble___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecDouble___delslice__`, 'returnType') = 'void'
attr(`VecDouble___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`VecDouble___delslice__`) = c("SWIGFunction", class('VecDouble___delslice__'))

# Start of VecDouble___delitem__

`VecDouble___delitem__` = function(self, i)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecDouble___delitem__`, 'returnType') = 'void'
attr(`VecDouble___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___delitem__`) = c("SWIGFunction", class('VecDouble___delitem__'))

# Start of VecDouble___getitem__

`VecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble___getitem__`, 'returnType') = 'numeric'
attr(`VecDouble___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble___getitem__`) = c("SWIGFunction", class('VecDouble___getitem__'))

# Start of VecDouble___setitem__

`VecDouble___setitem__` = function(self, i, x)
{
  self = as.numeric(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VecDouble___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble___setitem__`, 'returnType') = 'void'
attr(`VecDouble___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble___setitem__`) = c("SWIGFunction", class('VecDouble___setitem__'))

# Start of VecDouble_append

`VecDouble_append` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_append`, 'returnType') = 'void'
attr(`VecDouble_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_append`) = c("SWIGFunction", class('VecDouble_append'))

# Start of new_VecDouble

`VecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecDouble__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`VecDouble__SWIG_0`) = c("SWIGFunction", class('VecDouble__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_1` = function(other)
{
  other = as.numeric(other);
  ;.Call('R_swig_new_VecDouble__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble__SWIG_1`) = c("SWIGFunction", class('VecDouble__SWIG_1'))

# Start of VecDouble_empty

`VecDouble_empty` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_empty`, 'returnType') = 'logical'
attr(`VecDouble_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_empty`) = c("SWIGFunction", class('VecDouble_empty'))

# Start of VecDouble_size

`VecDouble_size` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_size`, 'returnType') = 'integer'
attr(`VecDouble_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_size`) = c("SWIGFunction", class('VecDouble_size'))

# Start of VecDouble_swap

`VecDouble_swap` = function(self, v)
{
  self = as.numeric(self);
  v = as.numeric(v);
  ;.Call('R_swig_VecDouble_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecDouble_swap`, 'returnType') = 'void'
attr(`VecDouble_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_swap`) = c("SWIGFunction", class('VecDouble_swap'))

# Start of VecDouble_clear

`VecDouble_clear` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecDouble_clear`, 'returnType') = 'void'
attr(`VecDouble_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_clear`) = c("SWIGFunction", class('VecDouble_clear'))

# Start of VecDouble_get_allocator

`VecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;ans = .Call('R_swig_VecDouble_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`VecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`VecDouble_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_get_allocator`) = c("SWIGFunction", class('VecDouble_get_allocator'))

# Start of new_VecDouble

`VecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecDouble__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecDouble__SWIG_2`) = c("SWIGFunction", class('VecDouble__SWIG_2'))

# Start of VecDouble_pop_back

`VecDouble_pop_back` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecDouble_pop_back`, 'returnType') = 'void'
attr(`VecDouble_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_pop_back`) = c("SWIGFunction", class('VecDouble_pop_back'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecDouble_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecDouble_resize__SWIG_0'))

# Start of new_VecDouble

`VecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VecDouble__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecDouble__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecDouble__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`VecDouble__SWIG_3`) = c("SWIGFunction", class('VecDouble__SWIG_3'))

`VecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecDouble__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- VecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- VecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_push_back

`VecDouble_push_back` = function(self, x)
{
  self = as.numeric(self);
  
  ;.Call('R_swig_VecDouble_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_push_back`, 'returnType') = 'void'
attr(`VecDouble_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`VecDouble_push_back`) = c("SWIGFunction", class('VecDouble_push_back'))

# Start of VecDouble_front

`VecDouble_front` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_front`, 'returnType') = 'numeric'
attr(`VecDouble_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_front`) = c("SWIGFunction", class('VecDouble_front'))

# Start of VecDouble_back

`VecDouble_back` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_back`, 'returnType') = 'numeric'
attr(`VecDouble_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_back`) = c("SWIGFunction", class('VecDouble_back'))

# Start of VecDouble_assign

`VecDouble_assign` = function(self, n, x)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VecDouble_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_assign`, 'returnType') = 'void'
attr(`VecDouble_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_assign`) = c("SWIGFunction", class('VecDouble_assign'))

# Start of VecDouble_resize

`VecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.numeric(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecDouble_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`VecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecDouble_resize__SWIG_1'))

`VecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- VecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecDouble_reserve

`VecDouble_reserve` = function(self, n)
{
  self = as.numeric(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecDouble_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecDouble_reserve`, 'returnType') = 'void'
attr(`VecDouble_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`VecDouble_reserve`) = c("SWIGFunction", class('VecDouble_reserve'))

# Start of VecDouble_capacity

`VecDouble_capacity` = function(self, .copy = FALSE)
{
  self = as.numeric(self);
  ;.Call('R_swig_VecDouble_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecDouble_capacity`, 'returnType') = 'integer'
attr(`VecDouble_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecDouble_capacity`) = c("SWIGFunction", class('VecDouble_capacity'))

# Start of delete_VecDouble

`delete_VecDouble` = function(self)
{
  self = as.numeric(self);
  ;.Call('R_swig_delete_VecDouble', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecDouble`, 'returnType') = 'void'
attr(`delete_VecDouble`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_VecDouble`) = c("SWIGFunction", class('delete_VecDouble'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecDouble___nonzero__, '__len__' = VecDouble___len__, 'pop' = VecDouble_pop, '__getslice__' = VecDouble___getslice__, '__setslice__' = VecDouble___setslice__, '__delslice__' = VecDouble___delslice__, '__delitem__' = VecDouble___delitem__, '__getitem__' = VecDouble___getitem__, '__setitem__' = VecDouble___setitem__, 'append' = VecDouble_append, 'empty' = VecDouble_empty, 'size' = VecDouble_size, 'swap' = VecDouble_swap, 'clear' = VecDouble_clear, 'get_allocator' = VecDouble_get_allocator, 'pop_back' = VecDouble_pop_back, 'resize' = VecDouble_resize, 'push_back' = VecDouble_push_back, 'front' = VecDouble_front, 'back' = VecDouble_back, 'assign' = VecDouble_assign, 'reserve' = VecDouble_reserve, 'capacity' = VecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of VecChar___nonzero__

`VecChar___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar___nonzero__`, 'returnType') = 'logical'
attr(`VecChar___nonzero__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar___nonzero__`) = c("SWIGFunction", class('VecChar___nonzero__'))

# Start of VecChar___len__

`VecChar___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar___len__`, 'returnType') = 'integer'
attr(`VecChar___len__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar___len__`) = c("SWIGFunction", class('VecChar___len__'))

# Start of VecChar_pop

`VecChar_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_pop`, 'returnType') = 'character'
attr(`VecChar_pop`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_pop`) = c("SWIGFunction", class('VecChar_pop'))

# Start of VecChar___getslice__

`VecChar___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecChar___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecChar___getslice__`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar___getslice__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', 'integer')
class(`VecChar___getslice__`) = c("SWIGFunction", class('VecChar___getslice__'))

# Start of VecChar___setslice__

`VecChar___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecChar___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecChar___setslice__`, 'returnType') = 'void'
attr(`VecChar___setslice__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar___setslice__`) = c("SWIGFunction", class('VecChar___setslice__'))

# Start of VecChar___delslice__

`VecChar___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecChar___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecChar___delslice__`, 'returnType') = 'void'
attr(`VecChar___delslice__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', 'integer')
class(`VecChar___delslice__`) = c("SWIGFunction", class('VecChar___delslice__'))

# Start of VecChar___delitem__

`VecChar___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecChar___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecChar___delitem__`, 'returnType') = 'void'
attr(`VecChar___delitem__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar___delitem__`) = c("SWIGFunction", class('VecChar___delitem__'))

# Start of VecChar___getitem__

`VecChar___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecChar___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar___getitem__`, 'returnType') = '_p_char'
attr(`VecChar___getitem__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar___getitem__`) = c("SWIGFunction", class('VecChar___getitem__'))

# Start of VecChar___setitem__

`VecChar___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character");     
  ;.Call('R_swig_VecChar___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecChar___setitem__`, 'returnType') = 'void'
attr(`VecChar___setitem__`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', '_p_char')
class(`VecChar___setitem__`) = c("SWIGFunction", class('VecChar___setitem__'))

# Start of VecChar_append

`VecChar_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_append`, 'returnType') = 'void'
attr(`VecChar_append`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', '_p_char')
class(`VecChar_append`) = c("SWIGFunction", class('VecChar_append'))

# Start of new_VecChar

`VecChar__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecChar__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_0`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
class(`VecChar__SWIG_0`) = c("SWIGFunction", class('VecChar__SWIG_0'))

# Start of new_VecChar

`VecChar__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecChar__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_1`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar__SWIG_1`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar__SWIG_1`) = c("SWIGFunction", class('VecChar__SWIG_1'))

# Start of VecChar_empty

`VecChar_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_empty`, 'returnType') = 'logical'
attr(`VecChar_empty`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_empty`) = c("SWIGFunction", class('VecChar_empty'))

# Start of VecChar_size

`VecChar_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_size`, 'returnType') = 'integer'
attr(`VecChar_size`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_size`) = c("SWIGFunction", class('VecChar_size'))

# Start of VecChar_swap

`VecChar_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecChar_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecChar_swap`, 'returnType') = 'void'
attr(`VecChar_swap`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_swap`) = c("SWIGFunction", class('VecChar_swap'))

# Start of VecChar_clear

`VecChar_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecChar_clear`, 'returnType') = 'void'
attr(`VecChar_clear`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_clear`) = c("SWIGFunction", class('VecChar_clear'))

# Start of VecChar_get_allocator

`VecChar_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecChar_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_char_t", ref=ans);
  
  ans
  
}

attr(`VecChar_get_allocator`, 'returnType') = '_p_std__allocatorT_char_t'
attr(`VecChar_get_allocator`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_get_allocator`) = c("SWIGFunction", class('VecChar_get_allocator'))

# Start of new_VecChar

`VecChar__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecChar__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_2`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar__SWIG_2`, "inputTypes") = c('integer')
class(`VecChar__SWIG_2`) = c("SWIGFunction", class('VecChar__SWIG_2'))

# Start of VecChar_pop_back

`VecChar_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecChar_pop_back`, 'returnType') = 'void'
attr(`VecChar_pop_back`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_pop_back`) = c("SWIGFunction", class('VecChar_pop_back'))

# Start of VecChar_resize

`VecChar_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecChar_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecChar_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecChar_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar_resize__SWIG_0`) = c("SWIGFunction", class('VecChar_resize__SWIG_0'))

# Start of new_VecChar

`VecChar__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character");     
  ;ans = .Call('R_swig_new_VecChar__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecChar)
  ans
  
}

attr(`VecChar__SWIG_3`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecChar__SWIG_3`, "inputTypes") = c('integer', '_p_char')
class(`VecChar__SWIG_3`) = c("SWIGFunction", class('VecChar__SWIG_3'))

`VecChar` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecChar__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecChar__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_char_std__allocatorT_char_t_t') && length(argv[[1]]) == 1) {
      f <- VecChar__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_char') && length(argv[[2]]) == 1) {
      f <- VecChar__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecChar with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecChar_push_back

`VecChar_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_push_back`, 'returnType') = 'void'
attr(`VecChar_push_back`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', '_p_char')
class(`VecChar_push_back`) = c("SWIGFunction", class('VecChar_push_back'))

# Start of VecChar_front

`VecChar_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_front`, 'returnType') = '_p_char'
attr(`VecChar_front`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_front`) = c("SWIGFunction", class('VecChar_front'))

# Start of VecChar_back

`VecChar_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_back`, 'returnType') = '_p_char'
attr(`VecChar_back`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_back`) = c("SWIGFunction", class('VecChar_back'))

# Start of VecChar_assign

`VecChar_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_assign`, 'returnType') = 'void'
attr(`VecChar_assign`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', '_p_char')
class(`VecChar_assign`) = c("SWIGFunction", class('VecChar_assign'))

# Start of VecChar_resize

`VecChar_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character");     
  ;.Call('R_swig_VecChar_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecChar_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecChar_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer', '_p_char')
class(`VecChar_resize__SWIG_1`) = c("SWIGFunction", class('VecChar_resize__SWIG_1'))

`VecChar_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_char_std__allocatorT_char_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecChar_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_char_std__allocatorT_char_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_char') && length(argv[[3]]) == 1) {
      f <- VecChar_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecChar_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecChar_reserve

`VecChar_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecChar_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecChar_reserve`, 'returnType') = 'void'
attr(`VecChar_reserve`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t', 'integer')
class(`VecChar_reserve`) = c("SWIGFunction", class('VecChar_reserve'))

# Start of VecChar_capacity

`VecChar_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecChar_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecChar_capacity`, 'returnType') = 'integer'
attr(`VecChar_capacity`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecChar_capacity`) = c("SWIGFunction", class('VecChar_capacity'))

# Start of delete_VecChar

`delete_VecChar` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecChar', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecChar`, 'returnType') = 'void'
attr(`delete_VecChar`, "inputTypes") = c('_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`delete_VecChar`) = c("SWIGFunction", class('delete_VecChar'))

# Start of accessor method for std::vector<(char)>
setMethod('$', '_p_std__vectorT_char_std__allocatorT_char_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecChar___nonzero__, '__len__' = VecChar___len__, 'pop' = VecChar_pop, '__getslice__' = VecChar___getslice__, '__setslice__' = VecChar___setslice__, '__delslice__' = VecChar___delslice__, '__delitem__' = VecChar___delitem__, '__getitem__' = VecChar___getitem__, '__setitem__' = VecChar___setitem__, 'append' = VecChar_append, 'empty' = VecChar_empty, 'size' = VecChar_size, 'swap' = VecChar_swap, 'clear' = VecChar_clear, 'get_allocator' = VecChar_get_allocator, 'pop_back' = VecChar_pop_back, 'resize' = VecChar_resize, 'push_back' = VecChar_push_back, 'front' = VecChar_front, 'back' = VecChar_back, 'assign' = VecChar_assign, 'reserve' = VecChar_reserve, 'capacity' = VecChar_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(char)>
setMethod('delete', '_p_std__vectorT_char_std__allocatorT_char_t_t', function(obj) {delete_std__vectorT_char_std__allocatorT_char_t_t(obj)})
# Start of VecVecDouble___nonzero__

`VecVecDouble___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___nonzero__`, 'returnType') = 'logical'
attr(`VecVecDouble___nonzero__`, "inputTypes") = c('list')
class(`VecVecDouble___nonzero__`) = c("SWIGFunction", class('VecVecDouble___nonzero__'))

# Start of VecVecDouble___len__

`VecVecDouble___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___len__`, 'returnType') = 'integer'
attr(`VecVecDouble___len__`, "inputTypes") = c('list')
class(`VecVecDouble___len__`) = c("SWIGFunction", class('VecVecDouble___len__'))

# Start of VecVecDouble_pop

`VecVecDouble_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_pop`, 'returnType') = 'numeric'
attr(`VecVecDouble_pop`, "inputTypes") = c('list')
class(`VecVecDouble_pop`) = c("SWIGFunction", class('VecVecDouble_pop'))

# Start of VecVecDouble___getslice__

`VecVecDouble___getslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___getslice__`, 'returnType') = 'list'
attr(`VecVecDouble___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___getslice__`) = c("SWIGFunction", class('VecVecDouble___getslice__'))

# Start of VecVecDouble___setslice__

`VecVecDouble___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___setslice__`, 'returnType') = 'void'
attr(`VecVecDouble___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecDouble___setslice__`) = c("SWIGFunction", class('VecVecDouble___setslice__'))

# Start of VecVecDouble___delslice__

`VecVecDouble___delslice__` = function(self, i, j)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecDouble___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___delslice__`, 'returnType') = 'void'
attr(`VecVecDouble___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecDouble___delslice__`) = c("SWIGFunction", class('VecVecDouble___delslice__'))

# Start of VecVecDouble___delitem__

`VecVecDouble___delitem__` = function(self, i)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___delitem__`, 'returnType') = 'void'
attr(`VecVecDouble___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___delitem__`) = c("SWIGFunction", class('VecVecDouble___delitem__'))

# Start of VecVecDouble___getitem__

`VecVecDouble___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecDouble___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___getitem__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble___getitem__`) = c("SWIGFunction", class('VecVecDouble___getitem__'))

# Start of VecVecDouble___setitem__

`VecVecDouble___setitem__` = function(self, i, x)
{
  self = lapply(self, as.numeric);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble___setitem__`, 'returnType') = 'void'
attr(`VecVecDouble___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble___setitem__`) = c("SWIGFunction", class('VecVecDouble___setitem__'))

# Start of VecVecDouble_append

`VecVecDouble_append` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_append`, 'returnType') = 'void'
attr(`VecVecDouble_append`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_append`) = c("SWIGFunction", class('VecVecDouble_append'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecDouble__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_0`, 'returnType') = 'list'
class(`VecVecDouble__SWIG_0`) = c("SWIGFunction", class('VecVecDouble__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_1` = function(other)
{
  other = lapply(other, as.numeric);
  ;.Call('R_swig_new_VecVecDouble__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_1`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_1`, "inputTypes") = c('list')
class(`VecVecDouble__SWIG_1`) = c("SWIGFunction", class('VecVecDouble__SWIG_1'))

# Start of VecVecDouble_empty

`VecVecDouble_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_empty`, 'returnType') = 'logical'
attr(`VecVecDouble_empty`, "inputTypes") = c('list')
class(`VecVecDouble_empty`) = c("SWIGFunction", class('VecVecDouble_empty'))

# Start of VecVecDouble_size

`VecVecDouble_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_size`, 'returnType') = 'integer'
attr(`VecVecDouble_size`, "inputTypes") = c('list')
class(`VecVecDouble_size`) = c("SWIGFunction", class('VecVecDouble_size'))

# Start of VecVecDouble_swap

`VecVecDouble_swap` = function(self, v)
{
  self = lapply(self, as.numeric);
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VecVecDouble_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_swap`, 'returnType') = 'void'
attr(`VecVecDouble_swap`, "inputTypes") = c('list', 'list')
class(`VecVecDouble_swap`) = c("SWIGFunction", class('VecVecDouble_swap'))

# Start of VecVecDouble_clear

`VecVecDouble_clear` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_clear`, 'returnType') = 'void'
attr(`VecVecDouble_clear`, "inputTypes") = c('list')
class(`VecVecDouble_clear`) = c("SWIGFunction", class('VecVecDouble_clear'))

# Start of VecVecDouble_get_allocator

`VecVecDouble_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;ans = .Call('R_swig_VecVecDouble_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecDouble_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`VecVecDouble_get_allocator`, "inputTypes") = c('list')
class(`VecVecDouble_get_allocator`) = c("SWIGFunction", class('VecVecDouble_get_allocator'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecDouble__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_2`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecDouble__SWIG_2`) = c("SWIGFunction", class('VecVecDouble__SWIG_2'))

# Start of VecVecDouble_pop_back

`VecVecDouble_pop_back` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_pop_back`, 'returnType') = 'void'
attr(`VecVecDouble_pop_back`, "inputTypes") = c('list')
class(`VecVecDouble_pop_back`) = c("SWIGFunction", class('VecVecDouble_pop_back'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecDouble_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_resize__SWIG_0`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_0'))

# Start of new_VecVecDouble

`VecVecDouble__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.numeric(value);
  ;.Call('R_swig_new_VecVecDouble__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble__SWIG_3`, 'returnType') = 'list'
attr(`VecVecDouble__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble__SWIG_3`) = c("SWIGFunction", class('VecVecDouble__SWIG_3'))

`VecVecDouble` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecDouble__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecDouble__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecDouble__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) )) {
      f <- VecVecDouble__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_push_back

`VecVecDouble_push_back` = function(self, x)
{
  self = lapply(self, as.numeric);
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_push_back`, 'returnType') = 'void'
attr(`VecVecDouble_push_back`, "inputTypes") = c('list', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_push_back`) = c("SWIGFunction", class('VecVecDouble_push_back'))

# Start of VecVecDouble_front

`VecVecDouble_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_front`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_front`, "inputTypes") = c('list')
class(`VecVecDouble_front`) = c("SWIGFunction", class('VecVecDouble_front'))

# Start of VecVecDouble_back

`VecVecDouble_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_back`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VecVecDouble_back`, "inputTypes") = c('list')
class(`VecVecDouble_back`) = c("SWIGFunction", class('VecVecDouble_back'))

# Start of VecVecDouble_assign

`VecVecDouble_assign` = function(self, n, x)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_assign`, 'returnType') = 'void'
attr(`VecVecDouble_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_assign`) = c("SWIGFunction", class('VecVecDouble_assign'))

# Start of VecVecDouble_resize

`VecVecDouble_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.numeric);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.numeric(x);
  ;.Call('R_swig_VecVecDouble_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecDouble_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VecVecDouble_resize__SWIG_1`) = c("SWIGFunction", class('VecVecDouble_resize__SWIG_1'))

`VecVecDouble_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecDouble_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) )) {
      f <- VecVecDouble_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecDouble_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecDouble_reserve

`VecVecDouble_reserve` = function(self, n)
{
  self = lapply(self, as.numeric);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecDouble_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_reserve`, 'returnType') = 'void'
attr(`VecVecDouble_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecDouble_reserve`) = c("SWIGFunction", class('VecVecDouble_reserve'))

# Start of VecVecDouble_capacity

`VecVecDouble_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_VecVecDouble_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecDouble_capacity`, 'returnType') = 'integer'
attr(`VecVecDouble_capacity`, "inputTypes") = c('list')
class(`VecVecDouble_capacity`) = c("SWIGFunction", class('VecVecDouble_capacity'))

# Start of delete_VecVecDouble

`delete_VecVecDouble` = function(self)
{
  self = lapply(self, as.numeric);
  ;.Call('R_swig_delete_VecVecDouble', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecDouble`, 'returnType') = 'void'
attr(`delete_VecVecDouble`, "inputTypes") = c('list')
class(`delete_VecVecDouble`) = c("SWIGFunction", class('delete_VecVecDouble'))

# Start of accessor method for std::vector<(std::vector<(double)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecDouble___nonzero__, '__len__' = VecVecDouble___len__, 'pop' = VecVecDouble_pop, '__getslice__' = VecVecDouble___getslice__, '__setslice__' = VecVecDouble___setslice__, '__delslice__' = VecVecDouble___delslice__, '__delitem__' = VecVecDouble___delitem__, '__getitem__' = VecVecDouble___getitem__, '__setitem__' = VecVecDouble___setitem__, 'append' = VecVecDouble_append, 'empty' = VecVecDouble_empty, 'size' = VecVecDouble_size, 'swap' = VecVecDouble_swap, 'clear' = VecVecDouble_clear, 'get_allocator' = VecVecDouble_get_allocator, 'pop_back' = VecVecDouble_pop_back, 'resize' = VecVecDouble_resize, 'push_back' = VecVecDouble_push_back, 'front' = VecVecDouble_front, 'back' = VecVecDouble_back, 'assign' = VecVecDouble_assign, 'reserve' = VecVecDouble_reserve, 'capacity' = VecVecDouble_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(double)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t(obj)})
# Start of VecInt___nonzero__

`VecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecInt___nonzero__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___nonzero__`) = c("SWIGFunction", class('VecInt___nonzero__'))

# Start of VecInt___len__

`VecInt___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt___len__`, 'returnType') = 'integer'
attr(`VecInt___len__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___len__`) = c("SWIGFunction", class('VecInt___len__'))

# Start of VecInt_pop

`VecInt_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_pop`, 'returnType') = 'integer'
attr(`VecInt_pop`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop`) = c("SWIGFunction", class('VecInt_pop'))

# Start of VecInt___getslice__

`VecInt___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt___getslice__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt___getslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___getslice__`) = c("SWIGFunction", class('VecInt___getslice__'))

# Start of VecInt___setslice__

`VecInt___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecInt___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecInt___setslice__`, 'returnType') = 'void'
attr(`VecInt___setslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt___setslice__`) = c("SWIGFunction", class('VecInt___setslice__'))

# Start of VecInt___delslice__

`VecInt___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt___delslice__`, 'returnType') = 'void'
attr(`VecInt___delslice__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___delslice__`) = c("SWIGFunction", class('VecInt___delslice__'))

# Start of VecInt___delitem__

`VecInt___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecInt___delitem__`, 'returnType') = 'void'
attr(`VecInt___delitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___delitem__`) = c("SWIGFunction", class('VecInt___delitem__'))

# Start of VecInt___getitem__

`VecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt___getitem__`, 'returnType') = 'integer'
attr(`VecInt___getitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt___getitem__`) = c("SWIGFunction", class('VecInt___getitem__'))

# Start of VecInt___setitem__

`VecInt___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecInt___setitem__`, 'returnType') = 'void'
attr(`VecInt___setitem__`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt___setitem__`) = c("SWIGFunction", class('VecInt___setitem__'))

# Start of VecInt_append

`VecInt_append` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_append`, 'returnType') = 'void'
attr(`VecInt_append`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_append`) = c("SWIGFunction", class('VecInt_append'))

# Start of new_VecInt

`VecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecInt__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_0`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
class(`VecInt__SWIG_0`) = c("SWIGFunction", class('VecInt__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecInt__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_1`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt__SWIG_1`) = c("SWIGFunction", class('VecInt__SWIG_1'))

# Start of VecInt_empty

`VecInt_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_empty`, 'returnType') = 'logical'
attr(`VecInt_empty`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_empty`) = c("SWIGFunction", class('VecInt_empty'))

# Start of VecInt_size

`VecInt_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_size`, 'returnType') = 'integer'
attr(`VecInt_size`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_size`) = c("SWIGFunction", class('VecInt_size'))

# Start of VecInt_swap

`VecInt_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecInt_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecInt_swap`, 'returnType') = 'void'
attr(`VecInt_swap`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_swap`) = c("SWIGFunction", class('VecInt_swap'))

# Start of VecInt_clear

`VecInt_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecInt_clear`, 'returnType') = 'void'
attr(`VecInt_clear`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_clear`) = c("SWIGFunction", class('VecInt_clear'))

# Start of VecInt_get_allocator

`VecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecInt_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_int_t", ref=ans);
  
  ans
  
}

attr(`VecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_int_t'
attr(`VecInt_get_allocator`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_get_allocator`) = c("SWIGFunction", class('VecInt_get_allocator'))

# Start of new_VecInt

`VecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecInt__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_2`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecInt__SWIG_2`) = c("SWIGFunction", class('VecInt__SWIG_2'))

# Start of VecInt_pop_back

`VecInt_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecInt_pop_back`, 'returnType') = 'void'
attr(`VecInt_pop_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_pop_back`) = c("SWIGFunction", class('VecInt_pop_back'))

# Start of VecInt_resize

`VecInt_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecInt_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecInt_resize__SWIG_0'))

# Start of new_VecInt

`VecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecInt__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecInt__SWIG_3`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecInt__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecInt__SWIG_3`) = c("SWIGFunction", class('VecInt__SWIG_3'))

`VecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecInt__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_push_back

`VecInt_push_back` = function(self, x)
{
  self = as.integer(self);
  x = as.integer(x);
  ;.Call('R_swig_VecInt_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_push_back`, 'returnType') = 'void'
attr(`VecInt_push_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_push_back`) = c("SWIGFunction", class('VecInt_push_back'))

# Start of VecInt_front

`VecInt_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_front`, 'returnType') = 'integer'
attr(`VecInt_front`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_front`) = c("SWIGFunction", class('VecInt_front'))

# Start of VecInt_back

`VecInt_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_back`, 'returnType') = 'integer'
attr(`VecInt_back`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_back`) = c("SWIGFunction", class('VecInt_back'))

# Start of VecInt_assign

`VecInt_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_assign`, 'returnType') = 'void'
attr(`VecInt_assign`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_assign`) = c("SWIGFunction", class('VecInt_assign'))

# Start of VecInt_resize

`VecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecInt_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecInt_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer', 'integer')
class(`VecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecInt_resize__SWIG_1'))

`VecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 )) {
      f <- VecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt_reserve

`VecInt_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecInt_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecInt_reserve`, 'returnType') = 'void'
attr(`VecInt_reserve`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t', 'integer')
class(`VecInt_reserve`) = c("SWIGFunction", class('VecInt_reserve'))

# Start of VecInt_capacity

`VecInt_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt_capacity`, 'returnType') = 'integer'
attr(`VecInt_capacity`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecInt_capacity`) = c("SWIGFunction", class('VecInt_capacity'))

# Start of delete_VecInt

`delete_VecInt` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecInt', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecInt`, 'returnType') = 'void'
attr(`delete_VecInt`, "inputTypes") = c('_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`delete_VecInt`) = c("SWIGFunction", class('delete_VecInt'))

# Start of accessor method for std::vector<(int)>
setMethod('$', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecInt___nonzero__, '__len__' = VecInt___len__, 'pop' = VecInt_pop, '__getslice__' = VecInt___getslice__, '__setslice__' = VecInt___setslice__, '__delslice__' = VecInt___delslice__, '__delitem__' = VecInt___delitem__, '__getitem__' = VecInt___getitem__, '__setitem__' = VecInt___setitem__, 'append' = VecInt_append, 'empty' = VecInt_empty, 'size' = VecInt_size, 'swap' = VecInt_swap, 'clear' = VecInt_clear, 'get_allocator' = VecInt_get_allocator, 'pop_back' = VecInt_pop_back, 'resize' = VecInt_resize, 'push_back' = VecInt_push_back, 'front' = VecInt_front, 'back' = VecInt_back, 'assign' = VecInt_assign, 'reserve' = VecInt_reserve, 'capacity' = VecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(int)>
setMethod('delete', '_p_std__vectorT_int_std__allocatorT_int_t_t', function(obj) {delete_std__vectorT_int_std__allocatorT_int_t_t(obj)})
# Start of VecInt64___nonzero__

`VecInt64___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64___nonzero__`, 'returnType') = 'logical'
attr(`VecInt64___nonzero__`, "inputTypes") = c('integer')
class(`VecInt64___nonzero__`) = c("SWIGFunction", class('VecInt64___nonzero__'))

# Start of VecInt64___len__

`VecInt64___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64___len__`, 'returnType') = 'integer'
attr(`VecInt64___len__`, "inputTypes") = c('integer')
class(`VecInt64___len__`) = c("SWIGFunction", class('VecInt64___len__'))

# Start of VecInt64_pop

`VecInt64_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_pop`, 'returnType') = 'integer'
attr(`VecInt64_pop`, "inputTypes") = c('integer')
class(`VecInt64_pop`) = c("SWIGFunction", class('VecInt64_pop'))

# Start of VecInt64___getslice__

`VecInt64___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt64___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt64___getslice__`, 'returnType') = 'integer'
attr(`VecInt64___getslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecInt64___getslice__`) = c("SWIGFunction", class('VecInt64___getslice__'))

# Start of VecInt64___setslice__

`VecInt64___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecInt64___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecInt64___setslice__`, 'returnType') = 'void'
attr(`VecInt64___setslice__`, "inputTypes") = c('integer', 'integer', 'integer', 'integer')
class(`VecInt64___setslice__`) = c("SWIGFunction", class('VecInt64___setslice__'))

# Start of VecInt64___delslice__

`VecInt64___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecInt64___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecInt64___delslice__`, 'returnType') = 'void'
attr(`VecInt64___delslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecInt64___delslice__`) = c("SWIGFunction", class('VecInt64___delslice__'))

# Start of VecInt64___delitem__

`VecInt64___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt64___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecInt64___delitem__`, 'returnType') = 'void'
attr(`VecInt64___delitem__`, "inputTypes") = c('integer', 'integer')
class(`VecInt64___delitem__`) = c("SWIGFunction", class('VecInt64___delitem__'))

# Start of VecInt64___getitem__

`VecInt64___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecInt64___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64___getitem__`, 'returnType') = '_p_long_long'
attr(`VecInt64___getitem__`, "inputTypes") = c('integer', 'integer')
class(`VecInt64___getitem__`) = c("SWIGFunction", class('VecInt64___getitem__'))

# Start of VecInt64___setitem__

`VecInt64___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64___setitem__`, 'returnType') = 'void'
attr(`VecInt64___setitem__`, "inputTypes") = c('integer', 'integer', '_p_long_long')
class(`VecInt64___setitem__`) = c("SWIGFunction", class('VecInt64___setitem__'))

# Start of VecInt64_append

`VecInt64_append` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_append`, 'returnType') = 'void'
attr(`VecInt64_append`, "inputTypes") = c('integer', '_p_long_long')
class(`VecInt64_append`) = c("SWIGFunction", class('VecInt64_append'))

# Start of new_VecInt64

`VecInt64__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecInt64__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_0`, 'returnType') = 'integer'
class(`VecInt64__SWIG_0`) = c("SWIGFunction", class('VecInt64__SWIG_0'))

# Start of new_VecInt64

`VecInt64__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecInt64__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_1`, 'returnType') = 'integer'
attr(`VecInt64__SWIG_1`, "inputTypes") = c('integer')
class(`VecInt64__SWIG_1`) = c("SWIGFunction", class('VecInt64__SWIG_1'))

# Start of VecInt64_empty

`VecInt64_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_empty`, 'returnType') = 'logical'
attr(`VecInt64_empty`, "inputTypes") = c('integer')
class(`VecInt64_empty`) = c("SWIGFunction", class('VecInt64_empty'))

# Start of VecInt64_size

`VecInt64_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_size`, 'returnType') = 'integer'
attr(`VecInt64_size`, "inputTypes") = c('integer')
class(`VecInt64_size`) = c("SWIGFunction", class('VecInt64_size'))

# Start of VecInt64_swap

`VecInt64_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecInt64_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecInt64_swap`, 'returnType') = 'void'
attr(`VecInt64_swap`, "inputTypes") = c('integer', 'integer')
class(`VecInt64_swap`) = c("SWIGFunction", class('VecInt64_swap'))

# Start of VecInt64_clear

`VecInt64_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecInt64_clear`, 'returnType') = 'void'
attr(`VecInt64_clear`, "inputTypes") = c('integer')
class(`VecInt64_clear`) = c("SWIGFunction", class('VecInt64_clear'))

# Start of VecInt64_get_allocator

`VecInt64_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecInt64_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_long_long_t", ref=ans);
  
  ans
  
}

attr(`VecInt64_get_allocator`, 'returnType') = '_p_std__allocatorT_long_long_t'
attr(`VecInt64_get_allocator`, "inputTypes") = c('integer')
class(`VecInt64_get_allocator`) = c("SWIGFunction", class('VecInt64_get_allocator'))

# Start of new_VecInt64

`VecInt64__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecInt64__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_2`, 'returnType') = 'integer'
attr(`VecInt64__SWIG_2`, "inputTypes") = c('integer')
class(`VecInt64__SWIG_2`) = c("SWIGFunction", class('VecInt64__SWIG_2'))

# Start of VecInt64_pop_back

`VecInt64_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecInt64_pop_back`, 'returnType') = 'void'
attr(`VecInt64_pop_back`, "inputTypes") = c('integer')
class(`VecInt64_pop_back`) = c("SWIGFunction", class('VecInt64_pop_back'))

# Start of VecInt64_resize

`VecInt64_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecInt64_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecInt64_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecInt64_resize__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`VecInt64_resize__SWIG_0`) = c("SWIGFunction", class('VecInt64_resize__SWIG_0'))

# Start of new_VecInt64

`VecInt64__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;.Call('R_swig_new_VecInt64__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecInt64__SWIG_3`, 'returnType') = 'integer'
attr(`VecInt64__SWIG_3`, "inputTypes") = c('integer', '_p_long_long')
class(`VecInt64__SWIG_3`) = c("SWIGFunction", class('VecInt64__SWIG_3'))

`VecInt64` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecInt64__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecInt64__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecInt64__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_long_long') && length(argv[[2]]) == 1) {
      f <- VecInt64__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecInt64 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt64_push_back

`VecInt64_push_back` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_push_back`, 'returnType') = 'void'
attr(`VecInt64_push_back`, "inputTypes") = c('integer', '_p_long_long')
class(`VecInt64_push_back`) = c("SWIGFunction", class('VecInt64_push_back'))

# Start of VecInt64_front

`VecInt64_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_front`, 'returnType') = '_p_long_long'
attr(`VecInt64_front`, "inputTypes") = c('integer')
class(`VecInt64_front`) = c("SWIGFunction", class('VecInt64_front'))

# Start of VecInt64_back

`VecInt64_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_back`, 'returnType') = '_p_long_long'
attr(`VecInt64_back`, "inputTypes") = c('integer')
class(`VecInt64_back`) = c("SWIGFunction", class('VecInt64_back'))

# Start of VecInt64_assign

`VecInt64_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_assign`, 'returnType') = 'void'
attr(`VecInt64_assign`, "inputTypes") = c('integer', 'integer', '_p_long_long')
class(`VecInt64_assign`) = c("SWIGFunction", class('VecInt64_assign'))

# Start of VecInt64_resize

`VecInt64_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecInt64_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecInt64_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecInt64_resize__SWIG_1`, "inputTypes") = c('integer', 'integer', '_p_long_long')
class(`VecInt64_resize__SWIG_1`) = c("SWIGFunction", class('VecInt64_resize__SWIG_1'))

`VecInt64_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecInt64_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_long_long') && length(argv[[3]]) == 1) {
      f <- VecInt64_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecInt64_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecInt64_reserve

`VecInt64_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecInt64_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecInt64_reserve`, 'returnType') = 'void'
attr(`VecInt64_reserve`, "inputTypes") = c('integer', 'integer')
class(`VecInt64_reserve`) = c("SWIGFunction", class('VecInt64_reserve'))

# Start of VecInt64_capacity

`VecInt64_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecInt64_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecInt64_capacity`, 'returnType') = 'integer'
attr(`VecInt64_capacity`, "inputTypes") = c('integer')
class(`VecInt64_capacity`) = c("SWIGFunction", class('VecInt64_capacity'))

# Start of delete_VecInt64

`delete_VecInt64` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecInt64', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecInt64`, 'returnType') = 'void'
attr(`delete_VecInt64`, "inputTypes") = c('integer')
class(`delete_VecInt64`) = c("SWIGFunction", class('delete_VecInt64'))

# Start of accessor method for std::vector<(long long)>
setMethod('$', '_p_std__vectorT_long_long_std__allocatorT_long_long_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecInt64___nonzero__, '__len__' = VecInt64___len__, 'pop' = VecInt64_pop, '__getslice__' = VecInt64___getslice__, '__setslice__' = VecInt64___setslice__, '__delslice__' = VecInt64___delslice__, '__delitem__' = VecInt64___delitem__, '__getitem__' = VecInt64___getitem__, '__setitem__' = VecInt64___setitem__, 'append' = VecInt64_append, 'empty' = VecInt64_empty, 'size' = VecInt64_size, 'swap' = VecInt64_swap, 'clear' = VecInt64_clear, 'get_allocator' = VecInt64_get_allocator, 'pop_back' = VecInt64_pop_back, 'resize' = VecInt64_resize, 'push_back' = VecInt64_push_back, 'front' = VecInt64_front, 'back' = VecInt64_back, 'assign' = VecInt64_assign, 'reserve' = VecInt64_reserve, 'capacity' = VecInt64_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(long long)>
setMethod('delete', '_p_std__vectorT_long_long_std__allocatorT_long_long_t_t', function(obj) {delete_std__vectorT_long_long_std__allocatorT_long_long_t_t(obj)})
# Start of VecVecInt___nonzero__

`VecVecInt___nonzero__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt___nonzero__`, 'returnType') = 'logical'
attr(`VecVecInt___nonzero__`, "inputTypes") = c('list')
class(`VecVecInt___nonzero__`) = c("SWIGFunction", class('VecVecInt___nonzero__'))

# Start of VecVecInt___len__

`VecVecInt___len__` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt___len__`, 'returnType') = 'integer'
attr(`VecVecInt___len__`, "inputTypes") = c('list')
class(`VecVecInt___len__`) = c("SWIGFunction", class('VecVecInt___len__'))

# Start of VecVecInt_pop

`VecVecInt_pop` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_pop`, 'returnType') = 'integer'
attr(`VecVecInt_pop`, "inputTypes") = c('list')
class(`VecVecInt_pop`) = c("SWIGFunction", class('VecVecInt_pop'))

# Start of VecVecInt___getslice__

`VecVecInt___getslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___getslice__`, 'returnType') = 'list'
attr(`VecVecInt___getslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___getslice__`) = c("SWIGFunction", class('VecVecInt___getslice__'))

# Start of VecVecInt___setslice__

`VecVecInt___setslice__` = function(self, i, j, v)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___setslice__`, 'returnType') = 'void'
attr(`VecVecInt___setslice__`, "inputTypes") = c('list', 'integer', 'integer', 'list')
class(`VecVecInt___setslice__`) = c("SWIGFunction", class('VecVecInt___setslice__'))

# Start of VecVecInt___delslice__

`VecVecInt___delslice__` = function(self, i, j)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecInt___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___delslice__`, 'returnType') = 'void'
attr(`VecVecInt___delslice__`, "inputTypes") = c('list', 'integer', 'integer')
class(`VecVecInt___delslice__`) = c("SWIGFunction", class('VecVecInt___delslice__'))

# Start of VecVecInt___delitem__

`VecVecInt___delitem__` = function(self, i)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___delitem__`, 'returnType') = 'void'
attr(`VecVecInt___delitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___delitem__`) = c("SWIGFunction", class('VecVecInt___delitem__'))

# Start of VecVecInt___getitem__

`VecVecInt___getitem__` = function(self, i, .copy = FALSE)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecInt___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt___getitem__`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt___getitem__`, "inputTypes") = c('list', 'integer')
class(`VecVecInt___getitem__`) = c("SWIGFunction", class('VecVecInt___getitem__'))

# Start of VecVecInt___setitem__

`VecVecInt___setitem__` = function(self, i, x)
{
  self = lapply(self, as.integer);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt___setitem__`, 'returnType') = 'void'
attr(`VecVecInt___setitem__`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt___setitem__`) = c("SWIGFunction", class('VecVecInt___setitem__'))

# Start of VecVecInt_append

`VecVecInt_append` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_append`, 'returnType') = 'void'
attr(`VecVecInt_append`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_append`) = c("SWIGFunction", class('VecVecInt_append'))

# Start of new_VecVecInt

`VecVecInt__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecVecInt__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_0`, 'returnType') = 'list'
class(`VecVecInt__SWIG_0`) = c("SWIGFunction", class('VecVecInt__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_1` = function(other)
{
  other = lapply(other, as.integer);
  ;.Call('R_swig_new_VecVecInt__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_1`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_1`, "inputTypes") = c('list')
class(`VecVecInt__SWIG_1`) = c("SWIGFunction", class('VecVecInt__SWIG_1'))

# Start of VecVecInt_empty

`VecVecInt_empty` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_empty`, 'returnType') = 'logical'
attr(`VecVecInt_empty`, "inputTypes") = c('list')
class(`VecVecInt_empty`) = c("SWIGFunction", class('VecVecInt_empty'))

# Start of VecVecInt_size

`VecVecInt_size` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_size`, 'returnType') = 'integer'
attr(`VecVecInt_size`, "inputTypes") = c('list')
class(`VecVecInt_size`) = c("SWIGFunction", class('VecVecInt_size'))

# Start of VecVecInt_swap

`VecVecInt_swap` = function(self, v)
{
  self = lapply(self, as.integer);
  v = lapply(v, as.integer);
  ;.Call('R_swig_VecVecInt_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_swap`, 'returnType') = 'void'
attr(`VecVecInt_swap`, "inputTypes") = c('list', 'list')
class(`VecVecInt_swap`) = c("SWIGFunction", class('VecVecInt_swap'))

# Start of VecVecInt_clear

`VecVecInt_clear` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_clear`, 'returnType') = 'void'
attr(`VecVecInt_clear`, "inputTypes") = c('list')
class(`VecVecInt_clear`) = c("SWIGFunction", class('VecVecInt_clear'))

# Start of VecVecInt_get_allocator

`VecVecInt_get_allocator` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;ans = .Call('R_swig_VecVecInt_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecInt_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t'
attr(`VecVecInt_get_allocator`, "inputTypes") = c('list')
class(`VecVecInt_get_allocator`) = c("SWIGFunction", class('VecVecInt_get_allocator'))

# Start of new_VecVecInt

`VecVecInt__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecVecInt__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_2`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecInt__SWIG_2`) = c("SWIGFunction", class('VecVecInt__SWIG_2'))

# Start of VecVecInt_pop_back

`VecVecInt_pop_back` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_pop_back`, 'returnType') = 'void'
attr(`VecVecInt_pop_back`, "inputTypes") = c('list')
class(`VecVecInt_pop_back`) = c("SWIGFunction", class('VecVecInt_pop_back'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_0` = function(self, new_size)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecInt_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_0`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_resize__SWIG_0`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_0'))

# Start of new_VecVecInt

`VecVecInt__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;.Call('R_swig_new_VecVecInt__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecVecInt__SWIG_3`, 'returnType') = 'list'
attr(`VecVecInt__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt__SWIG_3`) = c("SWIGFunction", class('VecVecInt__SWIG_3'))

`VecVecInt` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecInt__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecInt__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VecVecInt__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecInt__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_push_back

`VecVecInt_push_back` = function(self, x)
{
  self = lapply(self, as.integer);
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_push_back`, 'returnType') = 'void'
attr(`VecVecInt_push_back`, "inputTypes") = c('list', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_push_back`) = c("SWIGFunction", class('VecVecInt_push_back'))

# Start of VecVecInt_front

`VecVecInt_front` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_front`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_front`, "inputTypes") = c('list')
class(`VecVecInt_front`) = c("SWIGFunction", class('VecVecInt_front'))

# Start of VecVecInt_back

`VecVecInt_back` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_back`, 'returnType') = '_p_std__vectorT_int_std__allocatorT_int_t_t'
attr(`VecVecInt_back`, "inputTypes") = c('list')
class(`VecVecInt_back`) = c("SWIGFunction", class('VecVecInt_back'))

# Start of VecVecInt_assign

`VecVecInt_assign` = function(self, n, x)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_assign`, 'returnType') = 'void'
attr(`VecVecInt_assign`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_assign`) = c("SWIGFunction", class('VecVecInt_assign'))

# Start of VecVecInt_resize

`VecVecInt_resize__SWIG_1` = function(self, new_size, x)
{
  self = lapply(self, as.integer);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecInt_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecInt_resize__SWIG_1`, "inputTypes") = c('list', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`VecVecInt_resize__SWIG_1`) = c("SWIGFunction", class('VecVecInt_resize__SWIG_1'))

`VecVecInt_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecInt_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecInt_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecInt_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecInt_reserve

`VecVecInt_reserve` = function(self, n)
{
  self = lapply(self, as.integer);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecInt_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecInt_reserve`, 'returnType') = 'void'
attr(`VecVecInt_reserve`, "inputTypes") = c('list', 'integer')
class(`VecVecInt_reserve`) = c("SWIGFunction", class('VecVecInt_reserve'))

# Start of VecVecInt_capacity

`VecVecInt_capacity` = function(self, .copy = FALSE)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_VecVecInt_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecInt_capacity`, 'returnType') = 'integer'
attr(`VecVecInt_capacity`, "inputTypes") = c('list')
class(`VecVecInt_capacity`) = c("SWIGFunction", class('VecVecInt_capacity'))

# Start of delete_VecVecInt

`delete_VecVecInt` = function(self)
{
  self = lapply(self, as.integer);
  ;.Call('R_swig_delete_VecVecInt', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecInt`, 'returnType') = 'void'
attr(`delete_VecVecInt`, "inputTypes") = c('list')
class(`delete_VecVecInt`) = c("SWIGFunction", class('delete_VecVecInt'))

# Start of accessor method for std::vector<(std::vector<(int)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecInt___nonzero__, '__len__' = VecVecInt___len__, 'pop' = VecVecInt_pop, '__getslice__' = VecVecInt___getslice__, '__setslice__' = VecVecInt___setslice__, '__delslice__' = VecVecInt___delslice__, '__delitem__' = VecVecInt___delitem__, '__getitem__' = VecVecInt___getitem__, '__setitem__' = VecVecInt___setitem__, 'append' = VecVecInt_append, 'empty' = VecVecInt_empty, 'size' = VecVecInt_size, 'swap' = VecVecInt_swap, 'clear' = VecVecInt_clear, 'get_allocator' = VecVecInt_get_allocator, 'pop_back' = VecVecInt_pop_back, 'resize' = VecVecInt_resize, 'push_back' = VecVecInt_push_back, 'front' = VecVecInt_front, 'back' = VecVecInt_back, 'assign' = VecVecInt_assign, 'reserve' = VecVecInt_reserve, 'capacity' = VecVecInt_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(int)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t(obj)})
# Start of VecUINT8___nonzero__

`VecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecUINT8___nonzero__`, "inputTypes") = c('integer')
class(`VecUINT8___nonzero__`) = c("SWIGFunction", class('VecUINT8___nonzero__'))

# Start of VecUINT8___len__

`VecUINT8___len__` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8___len__`, 'returnType') = 'integer'
attr(`VecUINT8___len__`, "inputTypes") = c('integer')
class(`VecUINT8___len__`) = c("SWIGFunction", class('VecUINT8___len__'))

# Start of VecUINT8_pop

`VecUINT8_pop` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_pop`, 'returnType') = 'integer'
attr(`VecUINT8_pop`, "inputTypes") = c('integer')
class(`VecUINT8_pop`) = c("SWIGFunction", class('VecUINT8_pop'))

# Start of VecUINT8___getslice__

`VecUINT8___getslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___getslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___getslice__`, 'returnType') = 'integer'
attr(`VecUINT8___getslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___getslice__`) = c("SWIGFunction", class('VecUINT8___getslice__'))

# Start of VecUINT8___setslice__

`VecUINT8___setslice__` = function(self, i, j, v)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecUINT8___setslice__`, "inputTypes") = c('integer', 'integer', 'integer', 'integer')
class(`VecUINT8___setslice__`) = c("SWIGFunction", class('VecUINT8___setslice__'))

# Start of VecUINT8___delslice__

`VecUINT8___delslice__` = function(self, i, j)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecUINT8___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecUINT8___delslice__`, "inputTypes") = c('integer', 'integer', 'integer')
class(`VecUINT8___delslice__`) = c("SWIGFunction", class('VecUINT8___delslice__'))

# Start of VecUINT8___delitem__

`VecUINT8___delitem__` = function(self, i)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecUINT8___delitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___delitem__`) = c("SWIGFunction", class('VecUINT8___delitem__'))

# Start of VecUINT8___getitem__

`VecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8___getitem__`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8___getitem__`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8___getitem__`) = c("SWIGFunction", class('VecUINT8___getitem__'))

# Start of VecUINT8___setitem__

`VecUINT8___setitem__` = function(self, i, x)
{
  self = as.integer(self);
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecUINT8___setitem__`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8___setitem__`) = c("SWIGFunction", class('VecUINT8___setitem__'))

# Start of VecUINT8_append

`VecUINT8_append` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_append`, 'returnType') = 'void'
attr(`VecUINT8_append`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_append`) = c("SWIGFunction", class('VecUINT8_append'))

# Start of new_VecUINT8

`VecUINT8__SWIG_0` = function()
{
  ;.Call('R_swig_new_VecUINT8__SWIG_0', PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_0`, 'returnType') = 'integer'
class(`VecUINT8__SWIG_0`) = c("SWIGFunction", class('VecUINT8__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_1` = function(other)
{
  other = as.integer(other);
  ;.Call('R_swig_new_VecUINT8__SWIG_1', other, PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_1`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_1`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_1`) = c("SWIGFunction", class('VecUINT8__SWIG_1'))

# Start of VecUINT8_empty

`VecUINT8_empty` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_empty`, 'returnType') = 'logical'
attr(`VecUINT8_empty`, "inputTypes") = c('integer')
class(`VecUINT8_empty`) = c("SWIGFunction", class('VecUINT8_empty'))

# Start of VecUINT8_size

`VecUINT8_size` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_size`, 'returnType') = 'integer'
attr(`VecUINT8_size`, "inputTypes") = c('integer')
class(`VecUINT8_size`) = c("SWIGFunction", class('VecUINT8_size'))

# Start of VecUINT8_swap

`VecUINT8_swap` = function(self, v)
{
  self = as.integer(self);
  v = as.integer(v);
  ;.Call('R_swig_VecUINT8_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_swap`, 'returnType') = 'void'
attr(`VecUINT8_swap`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_swap`) = c("SWIGFunction", class('VecUINT8_swap'))

# Start of VecUINT8_clear

`VecUINT8_clear` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_clear`, 'returnType') = 'void'
attr(`VecUINT8_clear`, "inputTypes") = c('integer')
class(`VecUINT8_clear`) = c("SWIGFunction", class('VecUINT8_clear'))

# Start of VecUINT8_get_allocator

`VecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;ans = .Call('R_swig_VecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_unsigned_char_t", ref=ans);
  
  ans
  
}

attr(`VecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_unsigned_char_t'
attr(`VecUINT8_get_allocator`, "inputTypes") = c('integer')
class(`VecUINT8_get_allocator`) = c("SWIGFunction", class('VecUINT8_get_allocator'))

# Start of new_VecUINT8

`VecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VecUINT8__SWIG_2', size, PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_2`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecUINT8__SWIG_2`) = c("SWIGFunction", class('VecUINT8__SWIG_2'))

# Start of VecUINT8_pop_back

`VecUINT8_pop_back` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecUINT8_pop_back`, "inputTypes") = c('integer')
class(`VecUINT8_pop_back`) = c("SWIGFunction", class('VecUINT8_pop_back'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_0` = function(self, new_size)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecUINT8_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_0`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_0'))

# Start of new_VecUINT8

`VecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;.Call('R_swig_new_VecUINT8__SWIG_3', size, value, PACKAGE='rgeoda');
  
}

attr(`VecUINT8__SWIG_3`, 'returnType') = 'integer'
attr(`VecUINT8__SWIG_3`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8__SWIG_3`) = c("SWIGFunction", class('VecUINT8__SWIG_3'))

`VecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecUINT8__SWIG_2; 
    }
    else if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) )) {
      f <- VecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_unsigned_char') && length(argv[[2]]) == 1) {
      f <- VecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_push_back

`VecUINT8_push_back` = function(self, x)
{
  self = as.integer(self);
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_push_back`, 'returnType') = 'void'
attr(`VecUINT8_push_back`, "inputTypes") = c('integer', '_p_unsigned_char')
class(`VecUINT8_push_back`) = c("SWIGFunction", class('VecUINT8_push_back'))

# Start of VecUINT8_front

`VecUINT8_front` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_front`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_front`, "inputTypes") = c('integer')
class(`VecUINT8_front`) = c("SWIGFunction", class('VecUINT8_front'))

# Start of VecUINT8_back

`VecUINT8_back` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_back`, 'returnType') = '_p_unsigned_char'
attr(`VecUINT8_back`, "inputTypes") = c('integer')
class(`VecUINT8_back`) = c("SWIGFunction", class('VecUINT8_back'))

# Start of VecUINT8_assign

`VecUINT8_assign` = function(self, n, x)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_assign`, 'returnType') = 'void'
attr(`VecUINT8_assign`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_assign`) = c("SWIGFunction", class('VecUINT8_assign'))

# Start of VecUINT8_resize

`VecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  self = as.integer(self);
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecUINT8_resize__SWIG_1`, "inputTypes") = c('integer', 'integer', '_p_unsigned_char')
class(`VecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecUINT8_resize__SWIG_1'))

`VecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (( is.integer(argv[[1]]) || is.numeric(argv[[1]]) ) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_unsigned_char') && length(argv[[3]]) == 1) {
      f <- VecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecUINT8_reserve

`VecUINT8_reserve` = function(self, n)
{
  self = as.integer(self);
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecUINT8_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecUINT8_reserve`, 'returnType') = 'void'
attr(`VecUINT8_reserve`, "inputTypes") = c('integer', 'integer')
class(`VecUINT8_reserve`) = c("SWIGFunction", class('VecUINT8_reserve'))

# Start of VecUINT8_capacity

`VecUINT8_capacity` = function(self, .copy = FALSE)
{
  self = as.integer(self);
  ;.Call('R_swig_VecUINT8_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecUINT8_capacity`, "inputTypes") = c('integer')
class(`VecUINT8_capacity`) = c("SWIGFunction", class('VecUINT8_capacity'))

# Start of delete_VecUINT8

`delete_VecUINT8` = function(self)
{
  self = as.integer(self);
  ;.Call('R_swig_delete_VecUINT8', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecUINT8`, 'returnType') = 'void'
attr(`delete_VecUINT8`, "inputTypes") = c('integer')
class(`delete_VecUINT8`) = c("SWIGFunction", class('delete_VecUINT8'))

# Start of accessor method for std::vector<(unsigned char)>
setMethod('$', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecUINT8___nonzero__, '__len__' = VecUINT8___len__, 'pop' = VecUINT8_pop, '__getslice__' = VecUINT8___getslice__, '__setslice__' = VecUINT8___setslice__, '__delslice__' = VecUINT8___delslice__, '__delitem__' = VecUINT8___delitem__, '__getitem__' = VecUINT8___getitem__, '__setitem__' = VecUINT8___setitem__, 'append' = VecUINT8_append, 'empty' = VecUINT8_empty, 'size' = VecUINT8_size, 'swap' = VecUINT8_swap, 'clear' = VecUINT8_clear, 'get_allocator' = VecUINT8_get_allocator, 'pop_back' = VecUINT8_pop_back, 'resize' = VecUINT8_resize, 'push_back' = VecUINT8_push_back, 'front' = VecUINT8_front, 'back' = VecUINT8_back, 'assign' = VecUINT8_assign, 'reserve' = VecUINT8_reserve, 'capacity' = VecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(unsigned char)>
setMethod('delete', '_p_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t', function(obj) {delete_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t(obj)})
# Start of VecVecUINT8___nonzero__

`VecVecUINT8___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___nonzero__`, 'returnType') = 'logical'
attr(`VecVecUINT8___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___nonzero__`) = c("SWIGFunction", class('VecVecUINT8___nonzero__'))

# Start of VecVecUINT8___len__

`VecVecUINT8___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___len__`, 'returnType') = 'integer'
attr(`VecVecUINT8___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___len__`) = c("SWIGFunction", class('VecVecUINT8___len__'))

# Start of VecVecUINT8_pop

`VecVecUINT8_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_pop`, 'returnType') = 'integer'
attr(`VecVecUINT8_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop`) = c("SWIGFunction", class('VecVecUINT8_pop'))

# Start of VecVecUINT8___getslice__

`VecVecUINT8___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVecUINT8___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecUINT8___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___getslice__`) = c("SWIGFunction", class('VecVecUINT8___getslice__'))

# Start of VecVecUINT8___setslice__

`VecVecUINT8___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___setslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8___setslice__`) = c("SWIGFunction", class('VecVecUINT8___setslice__'))

# Start of VecVecUINT8___delslice__

`VecVecUINT8___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecUINT8___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___delslice__`, 'returnType') = 'void'
attr(`VecVecUINT8___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___delslice__`) = c("SWIGFunction", class('VecVecUINT8___delslice__'))

# Start of VecVecUINT8___delitem__

`VecVecUINT8___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___delitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___delitem__`) = c("SWIGFunction", class('VecVecUINT8___delitem__'))

# Start of VecVecUINT8___getitem__

`VecVecUINT8___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecUINT8___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___getitem__`, 'returnType') = 'integer'
attr(`VecVecUINT8___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8___getitem__`) = c("SWIGFunction", class('VecVecUINT8___getitem__'))

# Start of VecVecUINT8___setitem__

`VecVecUINT8___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8___setitem__`, 'returnType') = 'void'
attr(`VecVecUINT8___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8___setitem__`) = c("SWIGFunction", class('VecVecUINT8___setitem__'))

# Start of VecVecUINT8_append

`VecVecUINT8_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_append`, 'returnType') = 'void'
attr(`VecVecUINT8_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_append`) = c("SWIGFunction", class('VecVecUINT8_append'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
class(`VecVecUINT8__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8__SWIG_1'))

# Start of VecVecUINT8_empty

`VecVecUINT8_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_empty`, 'returnType') = 'logical'
attr(`VecVecUINT8_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_empty`) = c("SWIGFunction", class('VecVecUINT8_empty'))

# Start of VecVecUINT8_size

`VecVecUINT8_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_size`, 'returnType') = 'integer'
attr(`VecVecUINT8_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_size`) = c("SWIGFunction", class('VecVecUINT8_size'))

# Start of VecVecUINT8_swap

`VecVecUINT8_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecUINT8_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_swap`, 'returnType') = 'void'
attr(`VecVecUINT8_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_swap`) = c("SWIGFunction", class('VecVecUINT8_swap'))

# Start of VecVecUINT8_clear

`VecVecUINT8_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_clear`, 'returnType') = 'void'
attr(`VecVecUINT8_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_clear`) = c("SWIGFunction", class('VecVecUINT8_clear'))

# Start of VecVecUINT8_get_allocator

`VecVecUINT8_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecUINT8_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecUINT8_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t'
attr(`VecVecUINT8_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_get_allocator`) = c("SWIGFunction", class('VecVecUINT8_get_allocator'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecUINT8__SWIG_2`) = c("SWIGFunction", class('VecVecUINT8__SWIG_2'))

# Start of VecVecUINT8_pop_back

`VecVecUINT8_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_pop_back`, 'returnType') = 'void'
attr(`VecVecUINT8_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_pop_back`) = c("SWIGFunction", class('VecVecUINT8_pop_back'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_resize__SWIG_0`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_0'))

# Start of new_VecVecUINT8

`VecVecUINT8__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as.integer(value);
  ;ans = .Call('R_swig_new_VecVecUINT8__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecUINT8)
  ans
  
}

attr(`VecVecUINT8__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`VecVecUINT8__SWIG_3`, "inputTypes") = c('integer', 'integer')
class(`VecVecUINT8__SWIG_3`) = c("SWIGFunction", class('VecVecUINT8__SWIG_3'))

`VecVecUINT8` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecUINT8__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecUINT8__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- VecVecUINT8__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.integer(argv[[2]]) || is.numeric(argv[[2]]) )) {
      f <- VecVecUINT8__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8 with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_push_back

`VecVecUINT8_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_push_back`, 'returnType') = 'void'
attr(`VecVecUINT8_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_push_back`) = c("SWIGFunction", class('VecVecUINT8_push_back'))

# Start of VecVecUINT8_front

`VecVecUINT8_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_front', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_front`, 'returnType') = 'integer'
attr(`VecVecUINT8_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_front`) = c("SWIGFunction", class('VecVecUINT8_front'))

# Start of VecVecUINT8_back

`VecVecUINT8_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_back', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_back`, 'returnType') = 'integer'
attr(`VecVecUINT8_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_back`) = c("SWIGFunction", class('VecVecUINT8_back'))

# Start of VecVecUINT8_assign

`VecVecUINT8_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_assign`, 'returnType') = 'void'
attr(`VecVecUINT8_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_assign`) = c("SWIGFunction", class('VecVecUINT8_assign'))

# Start of VecVecUINT8_resize

`VecVecUINT8_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as.integer(x);
  ;.Call('R_swig_VecVecUINT8_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecUINT8_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer', 'integer')
class(`VecVecUINT8_resize__SWIG_1`) = c("SWIGFunction", class('VecVecUINT8_resize__SWIG_1'))

`VecVecUINT8_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecUINT8_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.integer(argv[[3]]) || is.numeric(argv[[3]]) )) {
      f <- VecVecUINT8_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecUINT8_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecUINT8_reserve

`VecVecUINT8_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecUINT8_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_reserve`, 'returnType') = 'void'
attr(`VecVecUINT8_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', 'integer')
class(`VecVecUINT8_reserve`) = c("SWIGFunction", class('VecVecUINT8_reserve'))

# Start of VecVecUINT8_capacity

`VecVecUINT8_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecUINT8_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecUINT8_capacity`, 'returnType') = 'integer'
attr(`VecVecUINT8_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`VecVecUINT8_capacity`) = c("SWIGFunction", class('VecVecUINT8_capacity'))

# Start of delete_VecVecUINT8

`delete_VecVecUINT8` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVecUINT8', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecUINT8`, 'returnType') = 'void'
attr(`delete_VecVecUINT8`, "inputTypes") = c('_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t')
class(`delete_VecVecUINT8`) = c("SWIGFunction", class('delete_VecVecUINT8'))

# Start of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecUINT8___nonzero__, '__len__' = VecVecUINT8___len__, 'pop' = VecVecUINT8_pop, '__getslice__' = VecVecUINT8___getslice__, '__setslice__' = VecVecUINT8___setslice__, '__delslice__' = VecVecUINT8___delslice__, '__delitem__' = VecVecUINT8___delitem__, '__getitem__' = VecVecUINT8___getitem__, '__setitem__' = VecVecUINT8___setitem__, 'append' = VecVecUINT8_append, 'empty' = VecVecUINT8_empty, 'size' = VecVecUINT8_size, 'swap' = VecVecUINT8_swap, 'clear' = VecVecUINT8_clear, 'get_allocator' = VecVecUINT8_get_allocator, 'pop_back' = VecVecUINT8_pop_back, 'resize' = VecVecUINT8_resize, 'push_back' = VecVecUINT8_push_back, 'front' = VecVecUINT8_front, 'back' = VecVecUINT8_back, 'assign' = VecVecUINT8_assign, 'reserve' = VecVecUINT8_reserve, 'capacity' = VecVecUINT8_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(unsigned char)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t(obj)})
# Start of VecVecChar___nonzero__

`VecVecChar___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar___nonzero__`, 'returnType') = 'logical'
attr(`VecVecChar___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar___nonzero__`) = c("SWIGFunction", class('VecVecChar___nonzero__'))

# Start of VecVecChar___len__

`VecVecChar___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar___len__`, 'returnType') = 'integer'
attr(`VecVecChar___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar___len__`) = c("SWIGFunction", class('VecVecChar___len__'))

# Start of VecVecChar_pop

`VecVecChar_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_pop`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_pop`) = c("SWIGFunction", class('VecVecChar_pop'))

# Start of VecVecChar___getslice__

`VecVecChar___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecVecChar___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', 'integer')
class(`VecVecChar___getslice__`) = c("SWIGFunction", class('VecVecChar___getslice__'))

# Start of VecVecChar___setslice__

`VecVecChar___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecChar___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___setslice__`, 'returnType') = 'void'
attr(`VecVecChar___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar___setslice__`) = c("SWIGFunction", class('VecVecChar___setslice__'))

# Start of VecVecChar___delslice__

`VecVecChar___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecVecChar___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___delslice__`, 'returnType') = 'void'
attr(`VecVecChar___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', 'integer')
class(`VecVecChar___delslice__`) = c("SWIGFunction", class('VecVecChar___delslice__'))

# Start of VecVecChar___delitem__

`VecVecChar___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecVecChar___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___delitem__`, 'returnType') = 'void'
attr(`VecVecChar___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar___delitem__`) = c("SWIGFunction", class('VecVecChar___delitem__'))

# Start of VecVecChar___getitem__

`VecVecChar___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_VecVecChar___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar___getitem__`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar___getitem__`) = c("SWIGFunction", class('VecVecChar___getitem__'))

# Start of VecVecChar___setitem__

`VecVecChar___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar___setitem__`, 'returnType') = 'void'
attr(`VecVecChar___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar___setitem__`) = c("SWIGFunction", class('VecVecChar___setitem__'))

# Start of VecVecChar_append

`VecVecChar_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_append`, 'returnType') = 'void'
attr(`VecVecChar_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_append`) = c("SWIGFunction", class('VecVecChar_append'))

# Start of new_VecVecChar

`VecVecChar__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
class(`VecVecChar__SWIG_0`) = c("SWIGFunction", class('VecVecChar__SWIG_0'))

# Start of new_VecVecChar

`VecVecChar__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar__SWIG_1`) = c("SWIGFunction", class('VecVecChar__SWIG_1'))

# Start of VecVecChar_empty

`VecVecChar_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar_empty`, 'returnType') = 'logical'
attr(`VecVecChar_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_empty`) = c("SWIGFunction", class('VecVecChar_empty'))

# Start of VecVecChar_size

`VecVecChar_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar_size`, 'returnType') = 'integer'
attr(`VecVecChar_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_size`) = c("SWIGFunction", class('VecVecChar_size'))

# Start of VecVecChar_swap

`VecVecChar_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecVecChar_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_swap`, 'returnType') = 'void'
attr(`VecVecChar_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_swap`) = c("SWIGFunction", class('VecVecChar_swap'))

# Start of VecVecChar_clear

`VecVecChar_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_clear`, 'returnType') = 'void'
attr(`VecVecChar_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_clear`) = c("SWIGFunction", class('VecVecChar_clear'))

# Start of VecVecChar_get_allocator

`VecVecChar_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t'
attr(`VecVecChar_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_get_allocator`) = c("SWIGFunction", class('VecVecChar_get_allocator'))

# Start of new_VecVecChar

`VecVecChar__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar__SWIG_2`, "inputTypes") = c('integer')
class(`VecVecChar__SWIG_2`) = c("SWIGFunction", class('VecVecChar__SWIG_2'))

# Start of VecVecChar_pop_back

`VecVecChar_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_pop_back`, 'returnType') = 'void'
attr(`VecVecChar_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_pop_back`) = c("SWIGFunction", class('VecVecChar_pop_back'))

# Start of VecVecChar_resize

`VecVecChar_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecVecChar_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecVecChar_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar_resize__SWIG_0`) = c("SWIGFunction", class('VecVecChar_resize__SWIG_0'))

# Start of new_VecVecChar

`VecVecChar__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_VecVecChar__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecVecChar)
  ans
  
}

attr(`VecVecChar__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t'
attr(`VecVecChar__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar__SWIG_3`) = c("SWIGFunction", class('VecVecChar__SWIG_3'))

`VecVecChar` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecVecChar__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecVecChar__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- VecVecChar__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_std__vectorT_char_std__allocatorT_char_t_t') && length(argv[[2]]) == 1) {
      f <- VecVecChar__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecVecChar with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecChar_push_back

`VecVecChar_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_push_back`, 'returnType') = 'void'
attr(`VecVecChar_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_push_back`) = c("SWIGFunction", class('VecVecChar_push_back'))

# Start of VecVecChar_front

`VecVecChar_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_front', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_front`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_front`) = c("SWIGFunction", class('VecVecChar_front'))

# Start of VecVecChar_back

`VecVecChar_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecVecChar_back', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_char_std__allocatorT_char_t_t", ref=ans);
  
  ans
  
}

attr(`VecVecChar_back`, 'returnType') = '_p_std__vectorT_char_std__allocatorT_char_t_t'
attr(`VecVecChar_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_back`) = c("SWIGFunction", class('VecVecChar_back'))

# Start of VecVecChar_assign

`VecVecChar_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_assign`, 'returnType') = 'void'
attr(`VecVecChar_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_assign`) = c("SWIGFunction", class('VecVecChar_assign'))

# Start of VecVecChar_resize

`VecVecChar_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecVecChar_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecVecChar_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer', '_p_std__vectorT_char_std__allocatorT_char_t_t')
class(`VecVecChar_resize__SWIG_1`) = c("SWIGFunction", class('VecVecChar_resize__SWIG_1'))

`VecVecChar_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecVecChar_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_std__vectorT_char_std__allocatorT_char_t_t') && length(argv[[3]]) == 1) {
      f <- VecVecChar_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecVecChar_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecVecChar_reserve

`VecVecChar_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecVecChar_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecVecChar_reserve`, 'returnType') = 'void'
attr(`VecVecChar_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', 'integer')
class(`VecVecChar_reserve`) = c("SWIGFunction", class('VecVecChar_reserve'))

# Start of VecVecChar_capacity

`VecVecChar_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecVecChar_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecVecChar_capacity`, 'returnType') = 'integer'
attr(`VecVecChar_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`VecVecChar_capacity`) = c("SWIGFunction", class('VecVecChar_capacity'))

# Start of delete_VecVecChar

`delete_VecVecChar` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecVecChar', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecVecChar`, 'returnType') = 'void'
attr(`delete_VecVecChar`, "inputTypes") = c('_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t')
class(`delete_VecVecChar`) = c("SWIGFunction", class('delete_VecVecChar'))

# Start of accessor method for std::vector<(std::vector<(char)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecVecChar___nonzero__, '__len__' = VecVecChar___len__, 'pop' = VecVecChar_pop, '__getslice__' = VecVecChar___getslice__, '__setslice__' = VecVecChar___setslice__, '__delslice__' = VecVecChar___delslice__, '__delitem__' = VecVecChar___delitem__, '__getitem__' = VecVecChar___getitem__, '__setitem__' = VecVecChar___setitem__, 'append' = VecVecChar_append, 'empty' = VecVecChar_empty, 'size' = VecVecChar_size, 'swap' = VecVecChar_swap, 'clear' = VecVecChar_clear, 'get_allocator' = VecVecChar_get_allocator, 'pop_back' = VecVecChar_pop_back, 'resize' = VecVecChar_resize, 'push_back' = VecVecChar_push_back, 'front' = VecVecChar_front, 'back' = VecVecChar_back, 'assign' = VecVecChar_assign, 'reserve' = VecVecChar_reserve, 'capacity' = VecVecChar_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(char)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_char_std__allocatorT_char_t_t_std__allocatorT_std__vectorT_char_std__allocatorT_char_t_t_t_t(obj)})
# Start of delete_GeoDaWeight

`delete_GeoDaWeight` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaWeight', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaWeight`, 'returnType') = 'void'
attr(`delete_GeoDaWeight`, "inputTypes") = c('_p_GeoDaWeight')
class(`delete_GeoDaWeight`) = c("SWIGFunction", class('delete_GeoDaWeight'))

# Start of GeoDaWeight_SaveDIDWeights

`GeoDaWeight_SaveDIDWeights` = function(self, num_obs, newids, stack_ids, ofname, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  num_obs = as.integer(num_obs);
  
  if(length(num_obs) > 1) {
    warning("using only the first element of num_obs");
  };
  
  if (inherits(newids, "ExternalReference")) newids = slot(newids,"ref") 
  if (inherits(stack_ids, "ExternalReference")) stack_ids = slot(stack_ids,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveDIDWeights', self, num_obs, newids, stack_ids, ofname, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_SaveDIDWeights`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveDIDWeights`, "inputTypes") = c('_p_GeoDaWeight', 'integer', '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t', '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t', '_p_wxString')
class(`GeoDaWeight_SaveDIDWeights`) = c("SWIGFunction", class('GeoDaWeight_SaveDIDWeights'))

# Start of GeoDaWeight_SaveSpaceTimeWeights

`GeoDaWeight_SaveSpaceTimeWeights` = function(self, ofname, id_vec, time_ids, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  if (inherits(id_vec, "ExternalReference")) id_vec = slot(id_vec,"ref") 
  if (inherits(time_ids, "ExternalReference")) time_ids = slot(time_ids,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveSpaceTimeWeights', self, ofname, id_vec, time_ids, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_SaveSpaceTimeWeights`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveSpaceTimeWeights`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString', '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t', '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t')
class(`GeoDaWeight_SaveSpaceTimeWeights`) = c("SWIGFunction", class('GeoDaWeight_SaveSpaceTimeWeights'))

# Start of GeoDaWeight_CheckNeighbor

`GeoDaWeight_CheckNeighbor` = function(self, obs_idx, nbr_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  nbr_idx = as.integer(nbr_idx);
  
  if(length(nbr_idx) > 1) {
    warning("using only the first element of nbr_idx");
  };
  
  ;.Call('R_swig_GeoDaWeight_CheckNeighbor', self, obs_idx, nbr_idx, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_CheckNeighbor`, 'returnType') = 'logical'
attr(`GeoDaWeight_CheckNeighbor`, "inputTypes") = c('_p_GeoDaWeight', 'integer', 'integer')
class(`GeoDaWeight_CheckNeighbor`) = c("SWIGFunction", class('GeoDaWeight_CheckNeighbor'))

# Start of GeoDaWeight_GetNeighbors

`GeoDaWeight_GetNeighbors` = function(self, obs_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  ;ans = .Call('R_swig_GeoDaWeight_GetNeighbors', self, obs_idx, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_long_std__allocatorT_long_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_GetNeighbors`, 'returnType') = '_p_std__vectorT_long_std__allocatorT_long_t_t'
attr(`GeoDaWeight_GetNeighbors`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_GetNeighbors`) = c("SWIGFunction", class('GeoDaWeight_GetNeighbors'))

# Start of GeoDaWeight_Update

`GeoDaWeight_Update` = function(self, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  undefs = as.logical(undefs);
  ;.Call('R_swig_GeoDaWeight_Update', self, undefs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_Update`, 'returnType') = 'void'
attr(`GeoDaWeight_Update`, "inputTypes") = c('_p_GeoDaWeight', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDaWeight_Update`) = c("SWIGFunction", class('GeoDaWeight_Update'))

# Start of GeoDaWeight_HasIsolates

`GeoDaWeight_HasIsolates` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_HasIsolates', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_HasIsolates`, 'returnType') = 'logical'
attr(`GeoDaWeight_HasIsolates`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_HasIsolates`) = c("SWIGFunction", class('GeoDaWeight_HasIsolates'))

# Start of GeoDaWeight_GetNbrStats

`GeoDaWeight_GetNbrStats` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetNbrStats', self, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetNbrStats`, 'returnType') = 'void'
attr(`GeoDaWeight_GetNbrStats`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetNbrStats`) = c("SWIGFunction", class('GeoDaWeight_GetNbrStats'))

# Start of GeoDaWeight_GetNbrSize

`GeoDaWeight_GetNbrSize` = function(self, obs_idx, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  ;.Call('R_swig_GeoDaWeight_GetNbrSize', self, obs_idx, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetNbrSize`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetNbrSize`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_GetNbrSize`) = c("SWIGFunction", class('GeoDaWeight_GetNbrSize'))

# Start of GeoDaWeight_SpatialLag

`GeoDaWeight_SpatialLag` = function(self, obs_idx, data, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_idx = as.integer(obs_idx);
  
  if(length(obs_idx) > 1) {
    warning("using only the first element of obs_idx");
  };
  
  data = as.numeric(data);
  ;.Call('R_swig_GeoDaWeight_SpatialLag', self, obs_idx, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_SpatialLag`, 'returnType') = 'numeric'
attr(`GeoDaWeight_SpatialLag`, "inputTypes") = c('_p_GeoDaWeight', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaWeight_SpatialLag`) = c("SWIGFunction", class('GeoDaWeight_SpatialLag'))

# Start of GeoDaWeight_SaveToFile

`GeoDaWeight_SaveToFile__SWIG_0` = function(self, ofname, layer_name, id_var_name, id_vec, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  if (inherits(layer_name, "ExternalReference")) layer_name = slot(layer_name,"ref") 
  if (inherits(id_var_name, "ExternalReference")) id_var_name = slot(id_var_name,"ref") 
  if (inherits(id_vec, "ExternalReference")) id_vec = slot(id_vec,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveToFile__SWIG_0', self, ofname, layer_name, id_var_name, id_vec, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_SaveToFile__SWIG_0`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveToFile__SWIG_0`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString', '_p_wxString', '_p_wxString', '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t')
class(`GeoDaWeight_SaveToFile__SWIG_0`) = c("SWIGFunction", class('GeoDaWeight_SaveToFile__SWIG_0'))

# Start of GeoDaWeight_SaveToFile

`GeoDaWeight_SaveToFile__SWIG_1` = function(self, ofname, layer_name, id_var_name, id_vec, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(ofname, "ExternalReference")) ofname = slot(ofname,"ref") 
  if (inherits(layer_name, "ExternalReference")) layer_name = slot(layer_name,"ref") 
  if (inherits(id_var_name, "ExternalReference")) id_var_name = slot(id_var_name,"ref") 
  if (inherits(id_vec, "ExternalReference")) id_vec = slot(id_vec,"ref") 
  ;.Call('R_swig_GeoDaWeight_SaveToFile__SWIG_1', self, ofname, layer_name, id_var_name, id_vec, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_SaveToFile__SWIG_1`, 'returnType') = 'logical'
attr(`GeoDaWeight_SaveToFile__SWIG_1`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString', '_p_wxString', '_p_wxString', '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t')
class(`GeoDaWeight_SaveToFile__SWIG_1`) = c("SWIGFunction", class('GeoDaWeight_SaveToFile__SWIG_1'))

`GeoDaWeight_SaveToFile` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && extends(argtypes[2], '_p_wxString') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_wxString') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_wxString') && length(argv[[4]]) == 1 && extends(argtypes[5], '_p_std__vectorT_wxInt64_std__allocatorT_wxInt64_t_t') && length(argv[[5]]) == 1) {
      f <- GeoDaWeight_SaveToFile__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaWeight') || is.null(argv[[1]])) && extends(argtypes[2], '_p_wxString') && length(argv[[2]]) == 1 && extends(argtypes[3], '_p_wxString') && length(argv[[3]]) == 1 && extends(argtypes[4], '_p_wxString') && length(argv[[4]]) == 1 && extends(argtypes[5], '_p_std__vectorT_wxString_std__allocatorT_wxString_t_t') && length(argv[[5]]) == 1) {
      f <- GeoDaWeight_SaveToFile__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaWeight_SaveToFile with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaWeight_GetSparsity

`GeoDaWeight_GetSparsity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetSparsity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetSparsity`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetSparsity`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetSparsity`) = c("SWIGFunction", class('GeoDaWeight_GetSparsity'))

# Start of GeoDaWeight_GetDensity

`GeoDaWeight_GetDensity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetDensity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetDensity`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetDensity`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetDensity`) = c("SWIGFunction", class('GeoDaWeight_GetDensity'))

# Start of GeoDaWeight_GetMinNumNbrs

`GeoDaWeight_GetMinNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMinNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMinNumNbrs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetMinNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMinNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMinNumNbrs'))

# Start of GeoDaWeight_GetMaxNumNbrs

`GeoDaWeight_GetMaxNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMaxNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMaxNumNbrs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetMaxNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMaxNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMaxNumNbrs'))

# Start of GeoDaWeight_GetMeanNumNbrs

`GeoDaWeight_GetMeanNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMeanNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMeanNumNbrs`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetMeanNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMeanNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMeanNumNbrs'))

# Start of GeoDaWeight_GetMedianNumNbrs

`GeoDaWeight_GetMedianNumNbrs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetMedianNumNbrs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetMedianNumNbrs`, 'returnType') = 'numeric'
attr(`GeoDaWeight_GetMedianNumNbrs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetMedianNumNbrs`) = c("SWIGFunction", class('GeoDaWeight_GetMedianNumNbrs'))

# Start of GeoDaWeight_GetNumObs

`GeoDaWeight_GetNumObs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_GetNumObs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_GetNumObs`, 'returnType') = 'integer'
attr(`GeoDaWeight_GetNumObs`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetNumObs`) = c("SWIGFunction", class('GeoDaWeight_GetNumObs'))

# Start of GeoDaWeight_IsInternalUse

`GeoDaWeight_IsInternalUse` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_IsInternalUse', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_IsInternalUse`, 'returnType') = 'logical'
attr(`GeoDaWeight_IsInternalUse`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_IsInternalUse`) = c("SWIGFunction", class('GeoDaWeight_IsInternalUse'))

# Start of GeoDaWeight_Equal

`GeoDaWeight_Equal` = function(self, gw, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(gw, "ExternalReference")) gw = slot(gw,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_Equal', self, gw, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_Equal`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDaWeight_Equal`, "inputTypes") = c('_p_GeoDaWeight', '_p_GeoDaWeight')
class(`GeoDaWeight_Equal`) = c("SWIGFunction", class('GeoDaWeight_Equal'))

# Start of GeoDaWeight_GetTitle

`GeoDaWeight_GetTitle` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_GetTitle', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_GetTitle`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_GetTitle`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetTitle`) = c("SWIGFunction", class('GeoDaWeight_GetTitle'))

# Start of GeoDaWeight_GetIDName

`GeoDaWeight_GetIDName` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_GetIDName', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_GetIDName`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_GetIDName`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_GetIDName`) = c("SWIGFunction", class('GeoDaWeight_GetIDName'))

# Start of GeoDaWeight_gal_type_get

`GeoDaWeight_gal_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaWeight_gal_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_gal_type_get`, 'returnType') = 'character'
class(`GeoDaWeight_gal_type_get`) = c("SWIGFunction", class('GeoDaWeight_gal_type_get'))

# Start of GeoDaWeight_gwt_type_get

`GeoDaWeight_gwt_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaWeight_gwt_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_gwt_type_get`, 'returnType') = 'character'
class(`GeoDaWeight_gwt_type_get`) = c("SWIGFunction", class('GeoDaWeight_gwt_type_get'))

# Start of GeoDaWeight_weight_type_set

`GeoDaWeight_weight_type_set` = function(self, s_weight_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_weight_type = enumToInteger(s_weight_type, "_GeoDaWeight__WeightType"); 
  
  if(length(s_weight_type) > 1) {
    warning("using only the first element of s_weight_type");
  };
  
  ;.Call('R_swig_GeoDaWeight_weight_type_set', self, s_weight_type, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_weight_type_set`, 'returnType') = 'void'
attr(`GeoDaWeight_weight_type_set`, "inputTypes") = c('_p_GeoDaWeight', 'character')
class(`GeoDaWeight_weight_type_set`) = c("SWIGFunction", class('GeoDaWeight_weight_type_set'))

# Start of GeoDaWeight_weight_type_get

`GeoDaWeight_weight_type_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_weight_type_get', self, as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaWeight__WeightType");
  
  ans
  
}

attr(`GeoDaWeight_weight_type_get`, 'returnType') = 'character'
attr(`GeoDaWeight_weight_type_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_weight_type_get`) = c("SWIGFunction", class('GeoDaWeight_weight_type_get'))

# Start of GeoDaWeight_wflnm_set

`GeoDaWeight_wflnm_set` = function(self, s_wflnm)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_wflnm, "ExternalReference")) s_wflnm = slot(s_wflnm,"ref") 
  ;.Call('R_swig_GeoDaWeight_wflnm_set', self, s_wflnm, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_wflnm_set`, 'returnType') = 'void'
attr(`GeoDaWeight_wflnm_set`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString')
class(`GeoDaWeight_wflnm_set`) = c("SWIGFunction", class('GeoDaWeight_wflnm_set'))

# Start of GeoDaWeight_wflnm_get

`GeoDaWeight_wflnm_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_wflnm_get', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_wflnm_get`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_wflnm_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_wflnm_get`) = c("SWIGFunction", class('GeoDaWeight_wflnm_get'))

# Start of GeoDaWeight_id_field_set

`GeoDaWeight_id_field_set` = function(self, s_id_field)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_id_field, "ExternalReference")) s_id_field = slot(s_id_field,"ref") 
  ;.Call('R_swig_GeoDaWeight_id_field_set', self, s_id_field, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_id_field_set`, 'returnType') = 'void'
attr(`GeoDaWeight_id_field_set`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString')
class(`GeoDaWeight_id_field_set`) = c("SWIGFunction", class('GeoDaWeight_id_field_set'))

# Start of GeoDaWeight_id_field_get

`GeoDaWeight_id_field_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_id_field_get', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_id_field_get`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_id_field_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_id_field_get`) = c("SWIGFunction", class('GeoDaWeight_id_field_get'))

# Start of GeoDaWeight_title_set

`GeoDaWeight_title_set` = function(self, s_title)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_title, "ExternalReference")) s_title = slot(s_title,"ref") 
  ;.Call('R_swig_GeoDaWeight_title_set', self, s_title, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_title_set`, 'returnType') = 'void'
attr(`GeoDaWeight_title_set`, "inputTypes") = c('_p_GeoDaWeight', '_p_wxString')
class(`GeoDaWeight_title_set`) = c("SWIGFunction", class('GeoDaWeight_title_set'))

# Start of GeoDaWeight_title_get

`GeoDaWeight_title_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaWeight_title_get', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_wxString", ref=ans);
  
  ans
  
}

attr(`GeoDaWeight_title_get`, 'returnType') = '_p_wxString'
attr(`GeoDaWeight_title_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_title_get`) = c("SWIGFunction", class('GeoDaWeight_title_get'))

# Start of GeoDaWeight_symmetry_checked_set

`GeoDaWeight_symmetry_checked_set` = function(self, s_symmetry_checked)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_symmetry_checked = as.logical(s_symmetry_checked);
  ;.Call('R_swig_GeoDaWeight_symmetry_checked_set', self, s_symmetry_checked, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_symmetry_checked_set`, 'returnType') = 'void'
attr(`GeoDaWeight_symmetry_checked_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_symmetry_checked_set`) = c("SWIGFunction", class('GeoDaWeight_symmetry_checked_set'))

# Start of GeoDaWeight_symmetry_checked_get

`GeoDaWeight_symmetry_checked_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_symmetry_checked_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_symmetry_checked_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_symmetry_checked_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_symmetry_checked_get`) = c("SWIGFunction", class('GeoDaWeight_symmetry_checked_get'))

# Start of GeoDaWeight_is_symmetric_set

`GeoDaWeight_is_symmetric_set` = function(self, s_is_symmetric)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_is_symmetric = as.logical(s_is_symmetric);
  ;.Call('R_swig_GeoDaWeight_is_symmetric_set', self, s_is_symmetric, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_symmetric_set`, 'returnType') = 'void'
attr(`GeoDaWeight_is_symmetric_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_is_symmetric_set`) = c("SWIGFunction", class('GeoDaWeight_is_symmetric_set'))

# Start of GeoDaWeight_is_symmetric_get

`GeoDaWeight_is_symmetric_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_is_symmetric_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_symmetric_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_is_symmetric_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_is_symmetric_get`) = c("SWIGFunction", class('GeoDaWeight_is_symmetric_get'))

# Start of GeoDaWeight_num_obs_set

`GeoDaWeight_num_obs_set` = function(self, s_num_obs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_num_obs = as.integer(s_num_obs);
  
  if(length(s_num_obs) > 1) {
    warning("using only the first element of s_num_obs");
  };
  
  ;.Call('R_swig_GeoDaWeight_num_obs_set', self, s_num_obs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_num_obs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_num_obs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_num_obs_set`) = c("SWIGFunction", class('GeoDaWeight_num_obs_set'))

# Start of GeoDaWeight_num_obs_get

`GeoDaWeight_num_obs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_num_obs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_num_obs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_num_obs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_num_obs_get`) = c("SWIGFunction", class('GeoDaWeight_num_obs_get'))

# Start of GeoDaWeight_sparsity_set

`GeoDaWeight_sparsity_set` = function(self, s_sparsity)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_sparsity_set', self, s_sparsity, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_sparsity_set`, 'returnType') = 'void'
attr(`GeoDaWeight_sparsity_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_sparsity_set`) = c("SWIGFunction", class('GeoDaWeight_sparsity_set'))

# Start of GeoDaWeight_sparsity_get

`GeoDaWeight_sparsity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_sparsity_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_sparsity_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_sparsity_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_sparsity_get`) = c("SWIGFunction", class('GeoDaWeight_sparsity_get'))

# Start of GeoDaWeight_density_set

`GeoDaWeight_density_set` = function(self, s_density)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_density_set', self, s_density, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_density_set`, 'returnType') = 'void'
attr(`GeoDaWeight_density_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_density_set`) = c("SWIGFunction", class('GeoDaWeight_density_set'))

# Start of GeoDaWeight_density_get

`GeoDaWeight_density_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_density_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_density_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_density_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_density_get`) = c("SWIGFunction", class('GeoDaWeight_density_get'))

# Start of GeoDaWeight_min_nbrs_set

`GeoDaWeight_min_nbrs_set` = function(self, s_min_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_min_nbrs = as.integer(s_min_nbrs);
  
  if(length(s_min_nbrs) > 1) {
    warning("using only the first element of s_min_nbrs");
  };
  
  ;.Call('R_swig_GeoDaWeight_min_nbrs_set', self, s_min_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_min_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_min_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_min_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_min_nbrs_set'))

# Start of GeoDaWeight_min_nbrs_get

`GeoDaWeight_min_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_min_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_min_nbrs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_min_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_min_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_min_nbrs_get'))

# Start of GeoDaWeight_max_nbrs_set

`GeoDaWeight_max_nbrs_set` = function(self, s_max_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_max_nbrs = as.integer(s_max_nbrs);
  
  if(length(s_max_nbrs) > 1) {
    warning("using only the first element of s_max_nbrs");
  };
  
  ;.Call('R_swig_GeoDaWeight_max_nbrs_set', self, s_max_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_max_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_max_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'integer')
class(`GeoDaWeight_max_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_max_nbrs_set'))

# Start of GeoDaWeight_max_nbrs_get

`GeoDaWeight_max_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_max_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_max_nbrs_get`, 'returnType') = 'integer'
attr(`GeoDaWeight_max_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_max_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_max_nbrs_get'))

# Start of GeoDaWeight_mean_nbrs_set

`GeoDaWeight_mean_nbrs_set` = function(self, s_mean_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_mean_nbrs_set', self, s_mean_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_mean_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_mean_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_mean_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_mean_nbrs_set'))

# Start of GeoDaWeight_mean_nbrs_get

`GeoDaWeight_mean_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_mean_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_mean_nbrs_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_mean_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_mean_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_mean_nbrs_get'))

# Start of GeoDaWeight_median_nbrs_set

`GeoDaWeight_median_nbrs_set` = function(self, s_median_nbrs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GeoDaWeight_median_nbrs_set', self, s_median_nbrs, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_median_nbrs_set`, 'returnType') = 'void'
attr(`GeoDaWeight_median_nbrs_set`, "inputTypes") = c('_p_GeoDaWeight', 'numeric')
class(`GeoDaWeight_median_nbrs_set`) = c("SWIGFunction", class('GeoDaWeight_median_nbrs_set'))

# Start of GeoDaWeight_median_nbrs_get

`GeoDaWeight_median_nbrs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_median_nbrs_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_median_nbrs_get`, 'returnType') = 'numeric'
attr(`GeoDaWeight_median_nbrs_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_median_nbrs_get`) = c("SWIGFunction", class('GeoDaWeight_median_nbrs_get'))

# Start of GeoDaWeight_is_internal_use_set

`GeoDaWeight_is_internal_use_set` = function(self, s_is_internal_use)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_is_internal_use = as.logical(s_is_internal_use);
  ;.Call('R_swig_GeoDaWeight_is_internal_use_set', self, s_is_internal_use, PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_internal_use_set`, 'returnType') = 'void'
attr(`GeoDaWeight_is_internal_use_set`, "inputTypes") = c('_p_GeoDaWeight', 'logical')
class(`GeoDaWeight_is_internal_use_set`) = c("SWIGFunction", class('GeoDaWeight_is_internal_use_set'))

# Start of GeoDaWeight_is_internal_use_get

`GeoDaWeight_is_internal_use_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaWeight_is_internal_use_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaWeight_is_internal_use_get`, 'returnType') = 'logical'
attr(`GeoDaWeight_is_internal_use_get`, "inputTypes") = c('_p_GeoDaWeight')
class(`GeoDaWeight_is_internal_use_get`) = c("SWIGFunction", class('GeoDaWeight_is_internal_use_get'))

# Start of accessor method for GeoDaWeight
setMethod('$', '_p_GeoDaWeight', function(x, name)

{
  accessorFuns = list('SaveDIDWeights' = GeoDaWeight_SaveDIDWeights, 'SaveSpaceTimeWeights' = GeoDaWeight_SaveSpaceTimeWeights, 'CheckNeighbor' = GeoDaWeight_CheckNeighbor, 'GetNeighbors' = GeoDaWeight_GetNeighbors, 'Update' = GeoDaWeight_Update, 'HasIsolates' = GeoDaWeight_HasIsolates, 'GetNbrStats' = GeoDaWeight_GetNbrStats, 'GetNbrSize' = GeoDaWeight_GetNbrSize, 'SpatialLag' = GeoDaWeight_SpatialLag, 'SaveToFile' = GeoDaWeight_SaveToFile, 'GetSparsity' = GeoDaWeight_GetSparsity, 'GetDensity' = GeoDaWeight_GetDensity, 'GetMinNumNbrs' = GeoDaWeight_GetMinNumNbrs, 'GetMaxNumNbrs' = GeoDaWeight_GetMaxNumNbrs, 'GetMeanNumNbrs' = GeoDaWeight_GetMeanNumNbrs, 'GetMedianNumNbrs' = GeoDaWeight_GetMedianNumNbrs, 'GetNumObs' = GeoDaWeight_GetNumObs, 'IsInternalUse' = GeoDaWeight_IsInternalUse, 'Equal' = GeoDaWeight_Equal, 'GetTitle' = GeoDaWeight_GetTitle, 'GetIDName' = GeoDaWeight_GetIDName, 'weight_type' = GeoDaWeight_weight_type_get, 'wflnm' = GeoDaWeight_wflnm_get, 'id_field' = GeoDaWeight_id_field_get, 'title' = GeoDaWeight_title_get, 'symmetry_checked' = GeoDaWeight_symmetry_checked_get, 'is_symmetric' = GeoDaWeight_is_symmetric_get, 'num_obs' = GeoDaWeight_num_obs_get, 'sparsity' = GeoDaWeight_sparsity_get, 'density' = GeoDaWeight_density_get, 'min_nbrs' = GeoDaWeight_min_nbrs_get, 'max_nbrs' = GeoDaWeight_max_nbrs_get, 'mean_nbrs' = GeoDaWeight_mean_nbrs_get, 'median_nbrs' = GeoDaWeight_median_nbrs_get, 'is_internal_use' = GeoDaWeight_is_internal_use_get);
  vaccessors = c('weight_type', 'wflnm', 'id_field', 'title', 'symmetry_checked', 'is_symmetric', 'num_obs', 'sparsity', 'density', 'min_nbrs', 'max_nbrs', 'mean_nbrs', 'median_nbrs', 'is_internal_use');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaWeight
# Start of accessor method for GeoDaWeight
setMethod('$<-', '_p_GeoDaWeight', function(x, name, value)

{
  accessorFuns = list('weight_type' = GeoDaWeight_weight_type_set, 'wflnm' = GeoDaWeight_wflnm_set, 'id_field' = GeoDaWeight_id_field_set, 'title' = GeoDaWeight_title_set, 'symmetry_checked' = GeoDaWeight_symmetry_checked_set, 'is_symmetric' = GeoDaWeight_is_symmetric_set, 'num_obs' = GeoDaWeight_num_obs_set, 'sparsity' = GeoDaWeight_sparsity_set, 'density' = GeoDaWeight_density_set, 'min_nbrs' = GeoDaWeight_min_nbrs_set, 'max_nbrs' = GeoDaWeight_max_nbrs_set, 'mean_nbrs' = GeoDaWeight_mean_nbrs_set, 'median_nbrs' = GeoDaWeight_median_nbrs_set, 'is_internal_use' = GeoDaWeight_is_internal_use_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaWeight', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('weight_type' = GeoDaWeight_weight_type_set, 'wflnm' = GeoDaWeight_wflnm_set, 'id_field' = GeoDaWeight_id_field_set, 'title' = GeoDaWeight_title_set, 'symmetry_checked' = GeoDaWeight_symmetry_checked_set, 'is_symmetric' = GeoDaWeight_is_symmetric_set, 'num_obs' = GeoDaWeight_num_obs_set, 'sparsity' = GeoDaWeight_sparsity_set, 'density' = GeoDaWeight_density_set, 'min_nbrs' = GeoDaWeight_min_nbrs_set, 'max_nbrs' = GeoDaWeight_max_nbrs_set, 'mean_nbrs' = GeoDaWeight_mean_nbrs_set, 'median_nbrs' = GeoDaWeight_median_nbrs_set, 'is_internal_use' = GeoDaWeight_is_internal_use_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaWeight
setMethod('delete', '_p_GeoDaWeight', function(obj) {delete_GeoDaWeight(obj)})
# Start of delete_AbstractLocalSA

`delete_AbstractLocalSA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_AbstractLocalSA', self, PACKAGE='rgeoda');
  
}

attr(`delete_AbstractLocalSA`, 'returnType') = 'void'
attr(`delete_AbstractLocalSA`, "inputTypes") = c('_p_AbstractLocalSA')
class(`delete_AbstractLocalSA`) = c("SWIGFunction", class('delete_AbstractLocalSA'))

# Start of AbstractLocalSA_ComputeLoalSA

`AbstractLocalSA_ComputeLoalSA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_ComputeLoalSA', self, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_ComputeLoalSA`, 'returnType') = 'void'
attr(`AbstractLocalSA_ComputeLoalSA`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_ComputeLoalSA`) = c("SWIGFunction", class('AbstractLocalSA_ComputeLoalSA'))

# Start of AbstractLocalSA_CalcPseudoP

`AbstractLocalSA_CalcPseudoP` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_CalcPseudoP', self, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_CalcPseudoP`, 'returnType') = 'void'
attr(`AbstractLocalSA_CalcPseudoP`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_CalcPseudoP`) = c("SWIGFunction", class('AbstractLocalSA_CalcPseudoP'))

# Start of AbstractLocalSA_CalcPseudoP_threaded

`AbstractLocalSA_CalcPseudoP_threaded` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_CalcPseudoP_threaded', self, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_CalcPseudoP_threaded`, 'returnType') = 'void'
attr(`AbstractLocalSA_CalcPseudoP_threaded`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_CalcPseudoP_threaded`) = c("SWIGFunction", class('AbstractLocalSA_CalcPseudoP_threaded'))

# Start of AbstractLocalSA_CalcPseudoP_range

`AbstractLocalSA_CalcPseudoP_range` = function(self, obs_start, obs_end, seed_start)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  obs_start = as.integer(obs_start);
  
  if(length(obs_start) > 1) {
    warning("using only the first element of obs_start");
  };
  
  obs_end = as.integer(obs_end);
  
  if(length(obs_end) > 1) {
    warning("using only the first element of obs_end");
  };
  
  if (inherits(seed_start, "ExternalReference")) seed_start = slot(seed_start,"ref") 
  ;.Call('R_swig_AbstractLocalSA_CalcPseudoP_range', self, obs_start, obs_end, seed_start, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_CalcPseudoP_range`, 'returnType') = 'void'
attr(`AbstractLocalSA_CalcPseudoP_range`, "inputTypes") = c('_p_AbstractLocalSA', 'integer', 'integer', '_p_uint64_t')
class(`AbstractLocalSA_CalcPseudoP_range`) = c("SWIGFunction", class('AbstractLocalSA_CalcPseudoP_range'))

# Start of AbstractLocalSA_LargerPermLocalSA

`AbstractLocalSA_LargerPermLocalSA` = function(self, cnt, permNeighbors, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  cnt = as.integer(cnt);
  
  if(length(cnt) > 1) {
    warning("using only the first element of cnt");
  };
  
  permNeighbors = as.integer(permNeighbors);
  ;.Call('R_swig_AbstractLocalSA_LargerPermLocalSA', self, cnt, permNeighbors, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_LargerPermLocalSA`, 'returnType') = 'logical'
attr(`AbstractLocalSA_LargerPermLocalSA`, "inputTypes") = c('_p_AbstractLocalSA', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`AbstractLocalSA_LargerPermLocalSA`) = c("SWIGFunction", class('AbstractLocalSA_LargerPermLocalSA'))

# Start of AbstractLocalSA_Run

`AbstractLocalSA_Run` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_Run', self, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_Run`, 'returnType') = 'void'
attr(`AbstractLocalSA_Run`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_Run`) = c("SWIGFunction", class('AbstractLocalSA_Run'))

# Start of AbstractLocalSA_SetSignificanceFilter

`AbstractLocalSA_SetSignificanceFilter` = function(self, filter_id)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  filter_id = as.integer(filter_id);
  
  if(length(filter_id) > 1) {
    warning("using only the first element of filter_id");
  };
  
  ;.Call('R_swig_AbstractLocalSA_SetSignificanceFilter', self, filter_id, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetSignificanceFilter`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetSignificanceFilter`, "inputTypes") = c('_p_AbstractLocalSA', 'integer')
class(`AbstractLocalSA_SetSignificanceFilter`) = c("SWIGFunction", class('AbstractLocalSA_SetSignificanceFilter'))

# Start of AbstractLocalSA_GetSignificanceFilter

`AbstractLocalSA_GetSignificanceFilter` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetSignificanceFilter', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetSignificanceFilter`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetSignificanceFilter`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetSignificanceFilter`) = c("SWIGFunction", class('AbstractLocalSA_GetSignificanceFilter'))

# Start of AbstractLocalSA_GetSignificanceCutoff

`AbstractLocalSA_GetSignificanceCutoff` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetSignificanceCutoff', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetSignificanceCutoff`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetSignificanceCutoff`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetSignificanceCutoff`) = c("SWIGFunction", class('AbstractLocalSA_GetSignificanceCutoff'))

# Start of AbstractLocalSA_SetSignificanceCutoff

`AbstractLocalSA_SetSignificanceCutoff` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetSignificanceCutoff', self, val, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetSignificanceCutoff`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetSignificanceCutoff`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetSignificanceCutoff`) = c("SWIGFunction", class('AbstractLocalSA_SetSignificanceCutoff'))

# Start of AbstractLocalSA_GetUserCutoff

`AbstractLocalSA_GetUserCutoff` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetUserCutoff', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetUserCutoff`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetUserCutoff`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetUserCutoff`) = c("SWIGFunction", class('AbstractLocalSA_GetUserCutoff'))

# Start of AbstractLocalSA_SetUserCutoff

`AbstractLocalSA_SetUserCutoff` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetUserCutoff', self, val, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetUserCutoff`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetUserCutoff`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetUserCutoff`) = c("SWIGFunction", class('AbstractLocalSA_SetUserCutoff'))

# Start of AbstractLocalSA_GetBO

`AbstractLocalSA_GetBO` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetBO', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetBO`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetBO`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetBO`) = c("SWIGFunction", class('AbstractLocalSA_GetBO'))

# Start of AbstractLocalSA_SetBO

`AbstractLocalSA_SetBO` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetBO', self, val, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetBO`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetBO`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetBO`) = c("SWIGFunction", class('AbstractLocalSA_SetBO'))

# Start of AbstractLocalSA_GetFDR

`AbstractLocalSA_GetFDR` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetFDR', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetFDR`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetFDR`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetFDR`) = c("SWIGFunction", class('AbstractLocalSA_GetFDR'))

# Start of AbstractLocalSA_SetFDR

`AbstractLocalSA_SetFDR` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractLocalSA_SetFDR', self, val, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetFDR`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetFDR`, "inputTypes") = c('_p_AbstractLocalSA', 'numeric')
class(`AbstractLocalSA_SetFDR`) = c("SWIGFunction", class('AbstractLocalSA_SetFDR'))

# Start of AbstractLocalSA_GetNumPermutations

`AbstractLocalSA_GetNumPermutations` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetNumPermutations', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetNumPermutations`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetNumPermutations`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetNumPermutations`) = c("SWIGFunction", class('AbstractLocalSA_GetNumPermutations'))

# Start of AbstractLocalSA_SetNumPermutations

`AbstractLocalSA_SetNumPermutations` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  val = as.integer(val);
  
  if(length(val) > 1) {
    warning("using only the first element of val");
  };
  
  ;.Call('R_swig_AbstractLocalSA_SetNumPermutations', self, val, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetNumPermutations`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetNumPermutations`, "inputTypes") = c('_p_AbstractLocalSA', 'integer')
class(`AbstractLocalSA_SetNumPermutations`) = c("SWIGFunction", class('AbstractLocalSA_SetNumPermutations'))

# Start of AbstractLocalSA_GetLastUsedSeed

`AbstractLocalSA_GetLastUsedSeed` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractLocalSA_GetLastUsedSeed', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_uint64_t", ref=ans);
  
  ans
  
}

attr(`AbstractLocalSA_GetLastUsedSeed`, 'returnType') = '_p_uint64_t'
attr(`AbstractLocalSA_GetLastUsedSeed`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetLastUsedSeed`) = c("SWIGFunction", class('AbstractLocalSA_GetLastUsedSeed'))

# Start of AbstractLocalSA_SetLastUsedSeed

`AbstractLocalSA_SetLastUsedSeed` = function(self, seed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(seed, "ExternalReference")) seed = slot(seed,"ref") 
  ;.Call('R_swig_AbstractLocalSA_SetLastUsedSeed', self, seed, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetLastUsedSeed`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetLastUsedSeed`, "inputTypes") = c('_p_AbstractLocalSA', '_p_uint64_t')
class(`AbstractLocalSA_SetLastUsedSeed`) = c("SWIGFunction", class('AbstractLocalSA_SetLastUsedSeed'))

# Start of AbstractLocalSA_IsReuseLastSeed

`AbstractLocalSA_IsReuseLastSeed` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_IsReuseLastSeed', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_IsReuseLastSeed`, 'returnType') = 'logical'
attr(`AbstractLocalSA_IsReuseLastSeed`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_IsReuseLastSeed`) = c("SWIGFunction", class('AbstractLocalSA_IsReuseLastSeed'))

# Start of AbstractLocalSA_SetReuseLastSeed

`AbstractLocalSA_SetReuseLastSeed` = function(self, reuse)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  reuse = as.logical(reuse);
  ;.Call('R_swig_AbstractLocalSA_SetReuseLastSeed', self, reuse, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetReuseLastSeed`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetReuseLastSeed`, "inputTypes") = c('_p_AbstractLocalSA', 'logical')
class(`AbstractLocalSA_SetReuseLastSeed`) = c("SWIGFunction", class('AbstractLocalSA_SetReuseLastSeed'))

# Start of AbstractLocalSA_GetHasIsolates

`AbstractLocalSA_GetHasIsolates` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetHasIsolates', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetHasIsolates`, 'returnType') = 'logical'
attr(`AbstractLocalSA_GetHasIsolates`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetHasIsolates`) = c("SWIGFunction", class('AbstractLocalSA_GetHasIsolates'))

# Start of AbstractLocalSA_GetHasUndefined

`AbstractLocalSA_GetHasUndefined` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetHasUndefined', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetHasUndefined`, 'returnType') = 'logical'
attr(`AbstractLocalSA_GetHasUndefined`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetHasUndefined`) = c("SWIGFunction", class('AbstractLocalSA_GetHasUndefined'))

# Start of AbstractLocalSA_GetDefaultCategories

`AbstractLocalSA_GetDefaultCategories` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetDefaultCategories', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetDefaultCategories`, 'returnType') = 'character'
attr(`AbstractLocalSA_GetDefaultCategories`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetDefaultCategories`) = c("SWIGFunction", class('AbstractLocalSA_GetDefaultCategories'))

# Start of AbstractLocalSA_GetDefaultCutoffs

`AbstractLocalSA_GetDefaultCutoffs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetDefaultCutoffs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetDefaultCutoffs`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetDefaultCutoffs`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetDefaultCutoffs`) = c("SWIGFunction", class('AbstractLocalSA_GetDefaultCutoffs'))

# Start of AbstractLocalSA_GetLocalSignificanceValues

`AbstractLocalSA_GetLocalSignificanceValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetLocalSignificanceValues', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetLocalSignificanceValues`, 'returnType') = 'numeric'
attr(`AbstractLocalSA_GetLocalSignificanceValues`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetLocalSignificanceValues`) = c("SWIGFunction", class('AbstractLocalSA_GetLocalSignificanceValues'))

# Start of AbstractLocalSA_GetClusterIndicators

`AbstractLocalSA_GetClusterIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetClusterIndicators', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetClusterIndicators`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetClusterIndicators`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetClusterIndicators`) = c("SWIGFunction", class('AbstractLocalSA_GetClusterIndicators'))

# Start of AbstractLocalSA_GetSigCatIndicators

`AbstractLocalSA_GetSigCatIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetSigCatIndicators', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetSigCatIndicators`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetSigCatIndicators`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetSigCatIndicators`) = c("SWIGFunction", class('AbstractLocalSA_GetSigCatIndicators'))

# Start of AbstractLocalSA_IsRowStandardize

`AbstractLocalSA_IsRowStandardize` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_IsRowStandardize', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_IsRowStandardize`, 'returnType') = 'logical'
attr(`AbstractLocalSA_IsRowStandardize`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_IsRowStandardize`) = c("SWIGFunction", class('AbstractLocalSA_IsRowStandardize'))

# Start of AbstractLocalSA_SetRowStandardize

`AbstractLocalSA_SetRowStandardize` = function(self, rowStandardize)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  rowStandardize = as.logical(rowStandardize);
  ;.Call('R_swig_AbstractLocalSA_SetRowStandardize', self, rowStandardize, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetRowStandardize`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetRowStandardize`, "inputTypes") = c('_p_AbstractLocalSA', 'logical')
class(`AbstractLocalSA_SetRowStandardize`) = c("SWIGFunction", class('AbstractLocalSA_SetRowStandardize'))

# Start of AbstractLocalSA_GetNumThreads

`AbstractLocalSA_GetNumThreads` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractLocalSA_GetNumThreads', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_GetNumThreads`, 'returnType') = 'integer'
attr(`AbstractLocalSA_GetNumThreads`, "inputTypes") = c('_p_AbstractLocalSA')
class(`AbstractLocalSA_GetNumThreads`) = c("SWIGFunction", class('AbstractLocalSA_GetNumThreads'))

# Start of AbstractLocalSA_SetNumThreads

`AbstractLocalSA_SetNumThreads` = function(self, n_threads)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n_threads = as.integer(n_threads);
  
  if(length(n_threads) > 1) {
    warning("using only the first element of n_threads");
  };
  
  ;.Call('R_swig_AbstractLocalSA_SetNumThreads', self, n_threads, PACKAGE='rgeoda');
  
}

attr(`AbstractLocalSA_SetNumThreads`, 'returnType') = 'void'
attr(`AbstractLocalSA_SetNumThreads`, "inputTypes") = c('_p_AbstractLocalSA', 'integer')
class(`AbstractLocalSA_SetNumThreads`) = c("SWIGFunction", class('AbstractLocalSA_SetNumThreads'))

# Start of accessor method for AbstractLocalSA
setMethod('$', '_p_AbstractLocalSA', function(x, name)

{
  accessorFuns = list('ComputeLoalSA' = AbstractLocalSA_ComputeLoalSA, 'CalcPseudoP' = AbstractLocalSA_CalcPseudoP, 'CalcPseudoP_threaded' = AbstractLocalSA_CalcPseudoP_threaded, 'CalcPseudoP_range' = AbstractLocalSA_CalcPseudoP_range, 'LargerPermLocalSA' = AbstractLocalSA_LargerPermLocalSA, 'Run' = AbstractLocalSA_Run, 'SetSignificanceFilter' = AbstractLocalSA_SetSignificanceFilter, 'GetSignificanceFilter' = AbstractLocalSA_GetSignificanceFilter, 'GetSignificanceCutoff' = AbstractLocalSA_GetSignificanceCutoff, 'SetSignificanceCutoff' = AbstractLocalSA_SetSignificanceCutoff, 'GetUserCutoff' = AbstractLocalSA_GetUserCutoff, 'SetUserCutoff' = AbstractLocalSA_SetUserCutoff, 'GetBO' = AbstractLocalSA_GetBO, 'SetBO' = AbstractLocalSA_SetBO, 'GetFDR' = AbstractLocalSA_GetFDR, 'SetFDR' = AbstractLocalSA_SetFDR, 'GetNumPermutations' = AbstractLocalSA_GetNumPermutations, 'SetNumPermutations' = AbstractLocalSA_SetNumPermutations, 'GetLastUsedSeed' = AbstractLocalSA_GetLastUsedSeed, 'SetLastUsedSeed' = AbstractLocalSA_SetLastUsedSeed, 'IsReuseLastSeed' = AbstractLocalSA_IsReuseLastSeed, 'SetReuseLastSeed' = AbstractLocalSA_SetReuseLastSeed, 'GetHasIsolates' = AbstractLocalSA_GetHasIsolates, 'GetHasUndefined' = AbstractLocalSA_GetHasUndefined, 'GetDefaultCategories' = AbstractLocalSA_GetDefaultCategories, 'GetDefaultCutoffs' = AbstractLocalSA_GetDefaultCutoffs, 'GetLocalSignificanceValues' = AbstractLocalSA_GetLocalSignificanceValues, 'GetClusterIndicators' = AbstractLocalSA_GetClusterIndicators, 'GetSigCatIndicators' = AbstractLocalSA_GetSigCatIndicators, 'IsRowStandardize' = AbstractLocalSA_IsRowStandardize, 'SetRowStandardize' = AbstractLocalSA_SetRowStandardize, 'GetNumThreads' = AbstractLocalSA_GetNumThreads, 'SetNumThreads' = AbstractLocalSA_SetNumThreads);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for AbstractLocalSA
setMethod('delete', '_p_AbstractLocalSA', function(obj) {delete_AbstractLocalSA(obj)})
# Start of new_UniLisa

`UniLisa` = function(num_obs, data, undefs, w)
{
  num_obs = as.integer(num_obs);
  
  if(length(num_obs) > 1) {
    warning("using only the first element of num_obs");
  };
  
  data = as.numeric(data);
  undefs = as.logical(undefs);
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  ;ans = .Call('R_swig_new_UniLisa', num_obs, data, undefs, w, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_UniLisa", ref=ans);
  
  reg.finalizer(ans@ref, delete_UniLisa)
  ans
  
}

attr(`UniLisa`, 'returnType') = '_p_UniLisa'
attr(`UniLisa`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t', '_p_GeoDaWeight')
class(`UniLisa`) = c("SWIGFunction", class('UniLisa'))

# Start of delete_UniLisa

`delete_UniLisa` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_UniLisa', self, PACKAGE='rgeoda');
  
}

attr(`delete_UniLisa`, 'returnType') = 'void'
attr(`delete_UniLisa`, "inputTypes") = c('_p_UniLisa')
class(`delete_UniLisa`) = c("SWIGFunction", class('delete_UniLisa'))

# Start of UniLisa_ComputeLoalSA

`UniLisa_ComputeLoalSA` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_ComputeLoalSA', self, PACKAGE='rgeoda');
  
}

attr(`UniLisa_ComputeLoalSA`, 'returnType') = 'void'
attr(`UniLisa_ComputeLoalSA`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_ComputeLoalSA`) = c("SWIGFunction", class('UniLisa_ComputeLoalSA'))

# Start of UniLisa_LargerPermLocalSA

`UniLisa_LargerPermLocalSA` = function(self, cnt, permNeighbors, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  cnt = as.integer(cnt);
  
  if(length(cnt) > 1) {
    warning("using only the first element of cnt");
  };
  
  permNeighbors = as.integer(permNeighbors);
  ;.Call('R_swig_UniLisa_LargerPermLocalSA', self, cnt, permNeighbors, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`UniLisa_LargerPermLocalSA`, 'returnType') = 'logical'
attr(`UniLisa_LargerPermLocalSA`, "inputTypes") = c('_p_UniLisa', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t')
class(`UniLisa_LargerPermLocalSA`) = c("SWIGFunction", class('UniLisa_LargerPermLocalSA'))

# Start of UniLisa_GetClusterIndicators

`UniLisa_GetClusterIndicators` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_GetClusterIndicators', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`UniLisa_GetClusterIndicators`, 'returnType') = 'integer'
attr(`UniLisa_GetClusterIndicators`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_GetClusterIndicators`) = c("SWIGFunction", class('UniLisa_GetClusterIndicators'))

# Start of UniLisa_GetLagValues

`UniLisa_GetLagValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_GetLagValues', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`UniLisa_GetLagValues`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`UniLisa_GetLagValues`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_GetLagValues`) = c("SWIGFunction", class('UniLisa_GetLagValues'))

# Start of UniLisa_GetLocalMoranValues

`UniLisa_GetLocalMoranValues` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_UniLisa_GetLocalMoranValues', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`UniLisa_GetLocalMoranValues`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`UniLisa_GetLocalMoranValues`, "inputTypes") = c('_p_UniLisa')
class(`UniLisa_GetLocalMoranValues`) = c("SWIGFunction", class('UniLisa_GetLocalMoranValues'))

# Start of accessor method for UniLisa
setMethod('$', '_p_UniLisa', function(x, name)

{
  accessorFuns = list('ComputeLoalSA' = UniLisa_ComputeLoalSA, 'LargerPermLocalSA' = UniLisa_LargerPermLocalSA, 'GetClusterIndicators' = UniLisa_GetClusterIndicators, 'GetLagValues' = UniLisa_GetLagValues, 'GetLocalMoranValues' = UniLisa_GetLocalMoranValues);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for UniLisa
setMethod('delete', '_p_UniLisa', function(obj) {delete_UniLisa(obj)})
# Start of GeoDaColumn_integer_type_get

`GeoDaColumn_integer_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaColumn_integer_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_integer_type_get`, 'returnType') = 'character'
class(`GeoDaColumn_integer_type_get`) = c("SWIGFunction", class('GeoDaColumn_integer_type_get'))

# Start of GeoDaColumn_string_type_get

`GeoDaColumn_string_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaColumn_string_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_string_type_get`, 'returnType') = 'character'
class(`GeoDaColumn_string_type_get`) = c("SWIGFunction", class('GeoDaColumn_string_type_get'))

# Start of GeoDaColumn_real_type_get

`GeoDaColumn_real_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDaColumn_real_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_real_type_get`, 'returnType') = 'character'
class(`GeoDaColumn_real_type_get`) = c("SWIGFunction", class('GeoDaColumn_real_type_get'))

# Start of GeoDaColumn_name_set

`GeoDaColumn_name_set` = function(self, s_name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_name = as(s_name, "character"); 
  ;.Call('R_swig_GeoDaColumn_name_set', self, s_name, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_name_set`, 'returnType') = 'void'
attr(`GeoDaColumn_name_set`, "inputTypes") = c('_p_GeoDaColumn', 'character')
class(`GeoDaColumn_name_set`) = c("SWIGFunction", class('GeoDaColumn_name_set'))

# Start of GeoDaColumn_name_get

`GeoDaColumn_name_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaColumn_name_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_name_get`, 'returnType') = 'character'
attr(`GeoDaColumn_name_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_name_get`) = c("SWIGFunction", class('GeoDaColumn_name_get'))

# Start of GeoDaColumn_field_type_set

`GeoDaColumn_field_type_set` = function(self, s_field_type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_field_type = enumToInteger(s_field_type, "_GeoDaColumn__FieldType"); 
  
  if(length(s_field_type) > 1) {
    warning("using only the first element of s_field_type");
  };
  
  ;.Call('R_swig_GeoDaColumn_field_type_set', self, s_field_type, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_type_set`, 'returnType') = 'void'
attr(`GeoDaColumn_field_type_set`, "inputTypes") = c('_p_GeoDaColumn', 'character')
class(`GeoDaColumn_field_type_set`) = c("SWIGFunction", class('GeoDaColumn_field_type_set'))

# Start of GeoDaColumn_field_type_get

`GeoDaColumn_field_type_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaColumn_field_type_get', self, as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDaColumn__FieldType");
  
  ans
  
}

attr(`GeoDaColumn_field_type_get`, 'returnType') = 'character'
attr(`GeoDaColumn_field_type_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_field_type_get`) = c("SWIGFunction", class('GeoDaColumn_field_type_get'))

# Start of GeoDaColumn_field_length_set

`GeoDaColumn_field_length_set` = function(self, s_field_length)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_field_length = as.integer(s_field_length);
  
  if(length(s_field_length) > 1) {
    warning("using only the first element of s_field_length");
  };
  
  ;.Call('R_swig_GeoDaColumn_field_length_set', self, s_field_length, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_length_set`, 'returnType') = 'void'
attr(`GeoDaColumn_field_length_set`, "inputTypes") = c('_p_GeoDaColumn', 'integer')
class(`GeoDaColumn_field_length_set`) = c("SWIGFunction", class('GeoDaColumn_field_length_set'))

# Start of GeoDaColumn_field_length_get

`GeoDaColumn_field_length_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaColumn_field_length_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_length_get`, 'returnType') = 'integer'
attr(`GeoDaColumn_field_length_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_field_length_get`) = c("SWIGFunction", class('GeoDaColumn_field_length_get'))

# Start of GeoDaColumn_field_decimals_set

`GeoDaColumn_field_decimals_set` = function(self, s_field_decimals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_field_decimals = as.integer(s_field_decimals);
  
  if(length(s_field_decimals) > 1) {
    warning("using only the first element of s_field_decimals");
  };
  
  ;.Call('R_swig_GeoDaColumn_field_decimals_set', self, s_field_decimals, PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_decimals_set`, 'returnType') = 'void'
attr(`GeoDaColumn_field_decimals_set`, "inputTypes") = c('_p_GeoDaColumn', 'integer')
class(`GeoDaColumn_field_decimals_set`) = c("SWIGFunction", class('GeoDaColumn_field_decimals_set'))

# Start of GeoDaColumn_field_decimals_get

`GeoDaColumn_field_decimals_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaColumn_field_decimals_get', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaColumn_field_decimals_get`, 'returnType') = 'integer'
attr(`GeoDaColumn_field_decimals_get`, "inputTypes") = c('_p_GeoDaColumn')
class(`GeoDaColumn_field_decimals_get`) = c("SWIGFunction", class('GeoDaColumn_field_decimals_get'))

# Start of new_GeoDaColumn

`GeoDaColumn` = function(nm, ft, flen, fdec)
{
  nm = as(nm, "character"); 
  ft = enumToInteger(ft, "_GeoDaColumn__FieldType"); 
  
  if(length(ft) > 1) {
    warning("using only the first element of ft");
  };
  
  flen = as.integer(flen);
  
  if(length(flen) > 1) {
    warning("using only the first element of flen");
  };
  
  fdec = as.integer(fdec);
  
  if(length(fdec) > 1) {
    warning("using only the first element of fdec");
  };
  
  ;ans = .Call('R_swig_new_GeoDaColumn', nm, ft, flen, fdec, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaColumn)
  ans
  
}

attr(`GeoDaColumn`, 'returnType') = '_p_GeoDaColumn'
attr(`GeoDaColumn`, "inputTypes") = c('character', 'character', 'integer', 'integer')
class(`GeoDaColumn`) = c("SWIGFunction", class('GeoDaColumn'))

# Start of delete_GeoDaColumn

`delete_GeoDaColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaColumn`, 'returnType') = 'void'
attr(`delete_GeoDaColumn`, "inputTypes") = c('_p_GeoDaColumn')
class(`delete_GeoDaColumn`) = c("SWIGFunction", class('delete_GeoDaColumn'))

# Start of accessor method for GeoDaColumn
setMethod('$', '_p_GeoDaColumn', function(x, name)

{
  accessorFuns = list('name' = GeoDaColumn_name_get, 'field_type' = GeoDaColumn_field_type_get, 'field_length' = GeoDaColumn_field_length_get, 'field_decimals' = GeoDaColumn_field_decimals_get);
  vaccessors = c('name', 'field_type', 'field_length', 'field_decimals');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaColumn
# Start of accessor method for GeoDaColumn
setMethod('$<-', '_p_GeoDaColumn', function(x, name, value)

{
  accessorFuns = list('name' = GeoDaColumn_name_set, 'field_type' = GeoDaColumn_field_type_set, 'field_length' = GeoDaColumn_field_length_set, 'field_decimals' = GeoDaColumn_field_decimals_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('name' = GeoDaColumn_name_set, 'field_type' = GeoDaColumn_field_type_set, 'field_length' = GeoDaColumn_field_length_set, 'field_decimals' = GeoDaColumn_field_decimals_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaColumn
setMethod('delete', '_p_GeoDaColumn', function(obj) {delete_GeoDaColumn(obj)})
# Start of GeoDaIntColumn_data_set

`GeoDaIntColumn_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  ;.Call('R_swig_GeoDaIntColumn_data_set', self, s_data, PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_data_set`, 'returnType') = 'void'
attr(`GeoDaIntColumn_data_set`, "inputTypes") = c('_p_GeoDaIntColumn', 'integer')
class(`GeoDaIntColumn_data_set`) = c("SWIGFunction", class('GeoDaIntColumn_data_set'))

# Start of GeoDaIntColumn_data_get

`GeoDaIntColumn_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaIntColumn_data_get', self, PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_data_get`, 'returnType') = 'integer'
attr(`GeoDaIntColumn_data_get`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`GeoDaIntColumn_data_get`) = c("SWIGFunction", class('GeoDaIntColumn_data_get'))

# Start of GeoDaIntColumn_GetData

`GeoDaIntColumn_GetData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaIntColumn_GetData', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_GetData`, 'returnType') = 'integer'
attr(`GeoDaIntColumn_GetData`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`GeoDaIntColumn_GetData`) = c("SWIGFunction", class('GeoDaIntColumn_GetData'))

# Start of GeoDaIntColumn_SetData

`GeoDaIntColumn_SetData` = function(self, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  vals = as.integer(vals);
  ;.Call('R_swig_GeoDaIntColumn_SetData', self, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaIntColumn_SetData`, 'returnType') = 'void'
attr(`GeoDaIntColumn_SetData`, "inputTypes") = c('_p_GeoDaIntColumn', 'integer')
class(`GeoDaIntColumn_SetData`) = c("SWIGFunction", class('GeoDaIntColumn_SetData'))

# Start of new_GeoDaIntColumn

`GeoDaIntColumn` = function(nm, vals)
{
  nm = as(nm, "character"); 
  vals = as.integer(vals);
  ;ans = .Call('R_swig_new_GeoDaIntColumn', nm, vals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaIntColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaIntColumn)
  ans
  
}

attr(`GeoDaIntColumn`, 'returnType') = '_p_GeoDaIntColumn'
attr(`GeoDaIntColumn`, "inputTypes") = c('character', 'integer')
class(`GeoDaIntColumn`) = c("SWIGFunction", class('GeoDaIntColumn'))

# Start of delete_GeoDaIntColumn

`delete_GeoDaIntColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaIntColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaIntColumn`, 'returnType') = 'void'
attr(`delete_GeoDaIntColumn`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`delete_GeoDaIntColumn`) = c("SWIGFunction", class('delete_GeoDaIntColumn'))

# Start of accessor method for GeoDaIntColumn
setMethod('$', '_p_GeoDaIntColumn', function(x, name)

{
  accessorFuns = list('data' = GeoDaIntColumn_data_get, 'GetData' = GeoDaIntColumn_GetData, 'SetData' = GeoDaIntColumn_SetData);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaIntColumn
# Start of accessor method for GeoDaIntColumn
setMethod('$<-', '_p_GeoDaIntColumn', function(x, name, value)

{
  accessorFuns = list('data' = GeoDaIntColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaIntColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = GeoDaIntColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaIntColumn
setMethod('delete', '_p_GeoDaIntColumn', function(obj) {delete_GeoDaIntColumn(obj)})
# Start of GeoDaStringColumn_data_set

`GeoDaStringColumn_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_GeoDaStringColumn_data_set', self, s_data, PACKAGE='rgeoda');
  
}

attr(`GeoDaStringColumn_data_set`, 'returnType') = 'void'
attr(`GeoDaStringColumn_data_set`, "inputTypes") = c('_p_GeoDaStringColumn', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaStringColumn_data_set`) = c("SWIGFunction", class('GeoDaStringColumn_data_set'))

# Start of GeoDaStringColumn_data_get

`GeoDaStringColumn_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaStringColumn_data_get', self, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDaStringColumn_data_get`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`GeoDaStringColumn_data_get`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`GeoDaStringColumn_data_get`) = c("SWIGFunction", class('GeoDaStringColumn_data_get'))

# Start of GeoDaStringColumn_GetData

`GeoDaStringColumn_GetData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDaStringColumn_GetData', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`GeoDaStringColumn_GetData`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`GeoDaStringColumn_GetData`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`GeoDaStringColumn_GetData`) = c("SWIGFunction", class('GeoDaStringColumn_GetData'))

# Start of GeoDaStringColumn_SetData

`GeoDaStringColumn_SetData` = function(self, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(vals, "ExternalReference")) vals = slot(vals,"ref") 
  ;.Call('R_swig_GeoDaStringColumn_SetData', self, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaStringColumn_SetData`, 'returnType') = 'void'
attr(`GeoDaStringColumn_SetData`, "inputTypes") = c('_p_GeoDaStringColumn', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaStringColumn_SetData`) = c("SWIGFunction", class('GeoDaStringColumn_SetData'))

# Start of new_GeoDaStringColumn

`GeoDaStringColumn` = function(nm, vals)
{
  nm = as(nm, "character"); 
  if (inherits(vals, "ExternalReference")) vals = slot(vals,"ref") 
  ;ans = .Call('R_swig_new_GeoDaStringColumn', nm, vals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaStringColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaStringColumn)
  ans
  
}

attr(`GeoDaStringColumn`, 'returnType') = '_p_GeoDaStringColumn'
attr(`GeoDaStringColumn`, "inputTypes") = c('character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaStringColumn`) = c("SWIGFunction", class('GeoDaStringColumn'))

# Start of delete_GeoDaStringColumn

`delete_GeoDaStringColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaStringColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaStringColumn`, 'returnType') = 'void'
attr(`delete_GeoDaStringColumn`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`delete_GeoDaStringColumn`) = c("SWIGFunction", class('delete_GeoDaStringColumn'))

# Start of accessor method for GeoDaStringColumn
setMethod('$', '_p_GeoDaStringColumn', function(x, name)

{
  accessorFuns = list('data' = GeoDaStringColumn_data_get, 'GetData' = GeoDaStringColumn_GetData, 'SetData' = GeoDaStringColumn_SetData);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaStringColumn
# Start of accessor method for GeoDaStringColumn
setMethod('$<-', '_p_GeoDaStringColumn', function(x, name, value)

{
  accessorFuns = list('data' = GeoDaStringColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaStringColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = GeoDaStringColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaStringColumn
setMethod('delete', '_p_GeoDaStringColumn', function(obj) {delete_GeoDaStringColumn(obj)})
# Start of GeoDaRealColumn_data_set

`GeoDaRealColumn_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.numeric(s_data);
  ;.Call('R_swig_GeoDaRealColumn_data_set', self, s_data, PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_data_set`, 'returnType') = 'void'
attr(`GeoDaRealColumn_data_set`, "inputTypes") = c('_p_GeoDaRealColumn', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaRealColumn_data_set`) = c("SWIGFunction", class('GeoDaRealColumn_data_set'))

# Start of GeoDaRealColumn_data_get

`GeoDaRealColumn_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaRealColumn_data_get', self, PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_data_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`GeoDaRealColumn_data_get`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`GeoDaRealColumn_data_get`) = c("SWIGFunction", class('GeoDaRealColumn_data_get'))

# Start of GeoDaRealColumn_GetData

`GeoDaRealColumn_GetData` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaRealColumn_GetData', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_GetData`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`GeoDaRealColumn_GetData`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`GeoDaRealColumn_GetData`) = c("SWIGFunction", class('GeoDaRealColumn_GetData'))

# Start of GeoDaRealColumn_SetData

`GeoDaRealColumn_SetData` = function(self, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  vals = as.numeric(vals);
  ;.Call('R_swig_GeoDaRealColumn_SetData', self, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaRealColumn_SetData`, 'returnType') = 'void'
attr(`GeoDaRealColumn_SetData`, "inputTypes") = c('_p_GeoDaRealColumn', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaRealColumn_SetData`) = c("SWIGFunction", class('GeoDaRealColumn_SetData'))

# Start of new_GeoDaRealColumn

`GeoDaRealColumn` = function(nm, vals)
{
  nm = as(nm, "character"); 
  vals = as.numeric(vals);
  ;ans = .Call('R_swig_new_GeoDaRealColumn', nm, vals, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaRealColumn", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaRealColumn)
  ans
  
}

attr(`GeoDaRealColumn`, 'returnType') = '_p_GeoDaRealColumn'
attr(`GeoDaRealColumn`, "inputTypes") = c('character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaRealColumn`) = c("SWIGFunction", class('GeoDaRealColumn'))

# Start of delete_GeoDaRealColumn

`delete_GeoDaRealColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaRealColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaRealColumn`, 'returnType') = 'void'
attr(`delete_GeoDaRealColumn`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`delete_GeoDaRealColumn`) = c("SWIGFunction", class('delete_GeoDaRealColumn'))

# Start of accessor method for GeoDaRealColumn
setMethod('$', '_p_GeoDaRealColumn', function(x, name)

{
  accessorFuns = list('data' = GeoDaRealColumn_data_get, 'GetData' = GeoDaRealColumn_GetData, 'SetData' = GeoDaRealColumn_SetData);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GeoDaRealColumn
# Start of accessor method for GeoDaRealColumn
setMethod('$<-', '_p_GeoDaRealColumn', function(x, name, value)

{
  accessorFuns = list('data' = GeoDaRealColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GeoDaRealColumn', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = GeoDaRealColumn_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GeoDaRealColumn
setMethod('delete', '_p_GeoDaRealColumn', function(obj) {delete_GeoDaRealColumn(obj)})
# Start of new_GeoDaTable

`GeoDaTable` = function()
{
  ;ans = .Call('R_swig_new_GeoDaTable', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaTable", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDaTable)
  ans
  
}

attr(`GeoDaTable`, 'returnType') = '_p_GeoDaTable'
class(`GeoDaTable`) = c("SWIGFunction", class('GeoDaTable'))

# Start of delete_GeoDaTable

`delete_GeoDaTable` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDaTable', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDaTable`, 'returnType') = 'void'
attr(`delete_GeoDaTable`, "inputTypes") = c('_p_GeoDaTable')
class(`delete_GeoDaTable`) = c("SWIGFunction", class('delete_GeoDaTable'))

# Start of GeoDaTable_AddIntColumn

`GeoDaTable_AddIntColumn` = function(self, nm, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  vals = as.integer(vals);
  ;.Call('R_swig_GeoDaTable_AddIntColumn', self, nm, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddIntColumn`, 'returnType') = 'void'
attr(`GeoDaTable_AddIntColumn`, "inputTypes") = c('_p_GeoDaTable', 'character', 'integer')
class(`GeoDaTable_AddIntColumn`) = c("SWIGFunction", class('GeoDaTable_AddIntColumn'))

# Start of GeoDaTable_AddStringColumn

`GeoDaTable_AddStringColumn` = function(self, nm, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  if (inherits(vals, "ExternalReference")) vals = slot(vals,"ref") 
  ;.Call('R_swig_GeoDaTable_AddStringColumn', self, nm, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddStringColumn`, 'returnType') = 'void'
attr(`GeoDaTable_AddStringColumn`, "inputTypes") = c('_p_GeoDaTable', 'character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`GeoDaTable_AddStringColumn`) = c("SWIGFunction", class('GeoDaTable_AddStringColumn'))

# Start of GeoDaTable_AddRealColumn

`GeoDaTable_AddRealColumn` = function(self, nm, vals)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  nm = as(nm, "character"); 
  vals = as.numeric(vals);
  ;.Call('R_swig_GeoDaTable_AddRealColumn', self, nm, vals, PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_AddRealColumn`, 'returnType') = 'void'
attr(`GeoDaTable_AddRealColumn`, "inputTypes") = c('_p_GeoDaTable', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDaTable_AddRealColumn`) = c("SWIGFunction", class('GeoDaTable_AddRealColumn'))

# Start of GeoDaTable_GetColumn

`GeoDaTable_GetColumn__SWIG_0` = function(self, col_name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;ans = .Call('R_swig_GeoDaTable_GetColumn__SWIG_0', self, col_name, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`GeoDaTable_GetColumn__SWIG_0`, 'returnType') = '_p_GeoDaColumn'
attr(`GeoDaTable_GetColumn__SWIG_0`, "inputTypes") = c('_p_GeoDaTable', 'character')
class(`GeoDaTable_GetColumn__SWIG_0`) = c("SWIGFunction", class('GeoDaTable_GetColumn__SWIG_0'))

# Start of GeoDaTable_GetColumn

`GeoDaTable_GetColumn__SWIG_1` = function(self, idx)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  idx = as.integer(idx);
  
  if(length(idx) > 1) {
    warning("using only the first element of idx");
  };
  
  ;ans = .Call('R_swig_GeoDaTable_GetColumn__SWIG_1', self, idx, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`GeoDaTable_GetColumn__SWIG_1`, 'returnType') = '_p_GeoDaColumn'
attr(`GeoDaTable_GetColumn__SWIG_1`, "inputTypes") = c('_p_GeoDaTable', 'integer')
class(`GeoDaTable_GetColumn__SWIG_1`) = c("SWIGFunction", class('GeoDaTable_GetColumn__SWIG_1'))

`GeoDaTable_GetColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- GeoDaTable_GetColumn__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- GeoDaTable_GetColumn__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDaTable_GetColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDaTable_GetNumCols

`GeoDaTable_GetNumCols` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDaTable_GetNumCols', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDaTable_GetNumCols`, 'returnType') = 'integer'
attr(`GeoDaTable_GetNumCols`, "inputTypes") = c('_p_GeoDaTable')
class(`GeoDaTable_GetNumCols`) = c("SWIGFunction", class('GeoDaTable_GetNumCols'))

# Start of accessor method for GeoDaTable
setMethod('$', '_p_GeoDaTable', function(x, name)

{
  accessorFuns = list('AddIntColumn' = GeoDaTable_AddIntColumn, 'AddStringColumn' = GeoDaTable_AddStringColumn, 'AddRealColumn' = GeoDaTable_AddRealColumn, 'GetColumn' = GeoDaTable_GetColumn, 'GetNumCols' = GeoDaTable_GetNumCols);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for GeoDaTable
setMethod('delete', '_p_GeoDaTable', function(obj) {delete_GeoDaTable(obj)})
# Start of GeoDa_point_type_get

`GeoDa_point_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDa_point_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_point_type_get`, 'returnType') = 'character'
class(`GeoDa_point_type_get`) = c("SWIGFunction", class('GeoDa_point_type_get'))

# Start of GeoDa_polygon_type_get

`GeoDa_polygon_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDa_polygon_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_polygon_type_get`, 'returnType') = 'character'
class(`GeoDa_polygon_type_get`) = c("SWIGFunction", class('GeoDa_polygon_type_get'))

# Start of GeoDa_line_type_get

`GeoDa_line_type_get` = function(.copy = FALSE)
{
  ;ans = .Call('R_swig_GeoDa_line_type_get', as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_line_type_get`, 'returnType') = 'character'
class(`GeoDa_line_type_get`) = c("SWIGFunction", class('GeoDa_line_type_get'))

# Start of new_GeoDa

`GeoDa__SWIG_0` = function(layer_name, map_type, num_features, table, wkbs, wkb_bytes_len, pszProj4)
{
  layer_name = as(layer_name, "character"); 
  map_type = as(map_type, "character"); 
  num_features = as.integer(num_features);
  
  if(length(num_features) > 1) {
    warning("using only the first element of num_features");
  };
  
  if (inherits(table, "ExternalReference")) table = slot(table,"ref") 
  wkbs = as.integer(wkbs);
  wkb_bytes_len = as.integer(wkb_bytes_len);
  pszProj4 = as(pszProj4, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_0', layer_name, map_type, num_features, table, wkbs, wkb_bytes_len, pszProj4, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_0`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_0`, "inputTypes") = c('character', 'character', 'integer', '_p_GeoDaTable', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t', 'character')
class(`GeoDa__SWIG_0`) = c("SWIGFunction", class('GeoDa__SWIG_0'))

# Start of new_GeoDa

`GeoDa__SWIG_1` = function(table, layer_name, map_type, wkbs, wkb_bytes_len, pszProj4)
{
  if (inherits(table, "ExternalReference")) table = slot(table,"ref") 
  layer_name = as(layer_name, "character"); 
  map_type = as(map_type, "character"); 
  wkbs = as.integer(wkbs);
  wkb_bytes_len = as.integer(wkb_bytes_len);
  pszProj4 = as(pszProj4, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_1', table, layer_name, map_type, wkbs, wkb_bytes_len, pszProj4, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_1`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_1`, "inputTypes") = c('_p_GeoDaTable', 'character', 'character', 'integer', '_p_std__vectorT_int_std__allocatorT_int_t_t', 'character')
class(`GeoDa__SWIG_1`) = c("SWIGFunction", class('GeoDa__SWIG_1'))

# Start of new_GeoDa

`GeoDa__SWIG_2` = function(pDsPath, layer_name)
{
  pDsPath = as(pDsPath, "character"); 
  layer_name = as(layer_name, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_2', pDsPath, layer_name, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_2`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_2`, "inputTypes") = c('character', 'character')
class(`GeoDa__SWIG_2`) = c("SWIGFunction", class('GeoDa__SWIG_2'))

# Start of new_GeoDa

`GeoDa__SWIG_3` = function(pDsPath)
{
  pDsPath = as(pDsPath, "character"); 
  ;ans = .Call('R_swig_new_GeoDa__SWIG_3', pDsPath, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDa", ref=ans);
  
  reg.finalizer(ans@ref, delete_GeoDa)
  ans
  
}

attr(`GeoDa__SWIG_3`, 'returnType') = '_p_GeoDa'
attr(`GeoDa__SWIG_3`, "inputTypes") = c('character')
class(`GeoDa__SWIG_3`) = c("SWIGFunction", class('GeoDa__SWIG_3'))

`GeoDa` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 1) {
    if (is.character(argv[[1]])) {
      f <- GeoDa__SWIG_3; 
    }
  } else if (argc == 2) {
    if (is.character(argv[[1]]) && is.character(argv[[2]])) {
      f <- GeoDa__SWIG_2; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDaTable') || is.null(argv[[1]])) && is.character(argv[[2]]) && length(argv[[2]]) == 1 && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( is.integer(argv[[4]]) || is.numeric(argv[[4]]) ) && ( is.integer(argv[[5]]) || is.numeric(argv[[5]]) ) && is.character(argv[[6]]) && length(argv[[6]]) == 1) {
      f <- GeoDa__SWIG_1; 
    }
  } else if (argc == 7) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && is.character(argv[[2]]) && length(argv[[2]]) == 1 && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && (extends(argtypes[4], '_p_GeoDaTable') || is.null(argv[[4]])) && ( is.integer(argv[[5]]) || is.numeric(argv[[5]]) ) && ( is.integer(argv[[6]]) || is.numeric(argv[[6]]) ) && is.character(argv[[7]]) && length(argv[[7]]) == 1) {
      f <- GeoDa__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of delete_GeoDa

`delete_GeoDa` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GeoDa', self, PACKAGE='rgeoda');
  
}

attr(`delete_GeoDa`, 'returnType') = 'void'
attr(`delete_GeoDa`, "inputTypes") = c('_p_GeoDa')
class(`delete_GeoDa`) = c("SWIGFunction", class('delete_GeoDa'))

# Start of GeoDa_GetMapType

`GeoDa_GetMapType` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDa_GetMapType', self, as.logical(.copy), PACKAGE='rgeoda');
  ans = enumFromInteger(ans, "_GeoDa__MapType");
  
  ans
  
}

attr(`GeoDa_GetMapType`, 'returnType') = 'character'
attr(`GeoDa_GetMapType`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetMapType`) = c("SWIGFunction", class('GeoDa_GetMapType'))

# Start of GeoDa_GetNumObs

`GeoDa_GetNumObs` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetNumObs', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetNumObs`, 'returnType') = 'integer'
attr(`GeoDa_GetNumObs`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetNumObs`) = c("SWIGFunction", class('GeoDa_GetNumObs'))

# Start of GeoDa_GetNumCols

`GeoDa_GetNumCols` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetNumCols', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetNumCols`, 'returnType') = 'integer'
attr(`GeoDa_GetNumCols`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetNumCols`) = c("SWIGFunction", class('GeoDa_GetNumCols'))

# Start of GeoDa_GetFieldTypes

`GeoDa_GetFieldTypes` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetFieldTypes', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetFieldTypes`, 'returnType') = 'character'
attr(`GeoDa_GetFieldTypes`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetFieldTypes`) = c("SWIGFunction", class('GeoDa_GetFieldTypes'))

# Start of GeoDa_GetFieldNames

`GeoDa_GetFieldNames` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetFieldNames', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetFieldNames`, 'returnType') = 'character'
attr(`GeoDa_GetFieldNames`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetFieldNames`) = c("SWIGFunction", class('GeoDa_GetFieldNames'))

# Start of GeoDa_GetGeometryWKB

`GeoDa_GetGeometryWKB` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDa_GetGeometryWKB', self, as.logical(.copy), PACKAGE='rgeoda');
# override SWIG generate return an unkonwn type
  
  ans
  
}

attr(`GeoDa_GetGeometryWKB`, 'returnType') = '_p_std__vectorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_std__allocatorT_std__vectorT_unsigned_char_std__allocatorT_unsigned_char_t_t_t_t'
attr(`GeoDa_GetGeometryWKB`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetGeometryWKB`) = c("SWIGFunction", class('GeoDa_GetGeometryWKB'))

# Start of GeoDa_GetGeometryWKT

`GeoDa_GetGeometryWKT` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetGeometryWKT', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetGeometryWKT`, 'returnType') = 'character'
attr(`GeoDa_GetGeometryWKT`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetGeometryWKT`) = c("SWIGFunction", class('GeoDa_GetGeometryWKT'))

# Start of GeoDa_GetNumericCol

`GeoDa_GetNumericCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetNumericCol', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetNumericCol`, 'returnType') = 'numeric'
attr(`GeoDa_GetNumericCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetNumericCol`) = c("SWIGFunction", class('GeoDa_GetNumericCol'))

# Start of GeoDa_GetIntegerCol

`GeoDa_GetIntegerCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetIntegerCol', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetIntegerCol`, 'returnType') = 'integer'
attr(`GeoDa_GetIntegerCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetIntegerCol`) = c("SWIGFunction", class('GeoDa_GetIntegerCol'))

# Start of GeoDa_GetStringCol

`GeoDa_GetStringCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetStringCol', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetStringCol`, 'returnType') = 'character'
attr(`GeoDa_GetStringCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetStringCol`) = c("SWIGFunction", class('GeoDa_GetStringCol'))

# Start of GeoDa_GetUndefinesCol

`GeoDa_GetUndefinesCol` = function(self, col_name, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  col_name = as(col_name, "character"); 
  ;.Call('R_swig_GeoDa_GetUndefinesCol', self, col_name, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetUndefinesCol`, 'returnType') = 'logical'
attr(`GeoDa_GetUndefinesCol`, "inputTypes") = c('_p_GeoDa', 'character')
class(`GeoDa_GetUndefinesCol`) = c("SWIGFunction", class('GeoDa_GetUndefinesCol'))

# Start of GeoDa_GetName

`GeoDa_GetName` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GeoDa_GetName', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_GetName`, 'returnType') = 'character'
attr(`GeoDa_GetName`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_GetName`) = c("SWIGFunction", class('GeoDa_GetName'))

# Start of GeoDa_CreateContiguityWeights

`GeoDa_CreateContiguityWeights__SWIG_0` = function(self, is_queen, polyid, order, include_lower_order, precision_threshold)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  is_queen = as.logical(is_queen);
  polyid = as(polyid, "character"); 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  include_lower_order = as.logical(include_lower_order);
  
  ;ans = .Call('R_swig_GeoDa_CreateContiguityWeights__SWIG_0', self, is_queen, polyid, order, include_lower_order, precision_threshold, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateContiguityWeights__SWIG_0`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateContiguityWeights__SWIG_0`, "inputTypes") = c('_p_GeoDa', 'logical', 'character', 'integer', 'logical', 'numeric')
class(`GeoDa_CreateContiguityWeights__SWIG_0`) = c("SWIGFunction", class('GeoDa_CreateContiguityWeights__SWIG_0'))

# Start of GeoDa_CreateContiguityWeights

`GeoDa_CreateContiguityWeights__SWIG_1` = function(self, is_queen, polyid, order, include_lower_order)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  is_queen = as.logical(is_queen);
  polyid = as(polyid, "character"); 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  include_lower_order = as.logical(include_lower_order);
  ;ans = .Call('R_swig_GeoDa_CreateContiguityWeights__SWIG_1', self, is_queen, polyid, order, include_lower_order, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateContiguityWeights__SWIG_1`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateContiguityWeights__SWIG_1`, "inputTypes") = c('_p_GeoDa', 'logical', 'character', 'integer', 'logical')
class(`GeoDa_CreateContiguityWeights__SWIG_1`) = c("SWIGFunction", class('GeoDa_CreateContiguityWeights__SWIG_1'))

# Start of GeoDa_CreateContiguityWeights

`GeoDa_CreateContiguityWeights__SWIG_2` = function(self, is_queen, polyid, order)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  is_queen = as.logical(is_queen);
  polyid = as(polyid, "character"); 
  order = as.integer(order);
  
  if(length(order) > 1) {
    warning("using only the first element of order");
  };
  
  ;ans = .Call('R_swig_GeoDa_CreateContiguityWeights__SWIG_2', self, is_queen, polyid, order, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateContiguityWeights__SWIG_2`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateContiguityWeights__SWIG_2`, "inputTypes") = c('_p_GeoDa', 'logical', 'character', 'integer')
class(`GeoDa_CreateContiguityWeights__SWIG_2`) = c("SWIGFunction", class('GeoDa_CreateContiguityWeights__SWIG_2'))

# Start of GeoDa_CreateContiguityWeights

`GeoDa_CreateContiguityWeights__SWIG_3` = function(self, is_queen, polyid)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  is_queen = as.logical(is_queen);
  polyid = as(polyid, "character"); 
  ;ans = .Call('R_swig_GeoDa_CreateContiguityWeights__SWIG_3', self, is_queen, polyid, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateContiguityWeights__SWIG_3`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateContiguityWeights__SWIG_3`, "inputTypes") = c('_p_GeoDa', 'logical', 'character')
class(`GeoDa_CreateContiguityWeights__SWIG_3`) = c("SWIGFunction", class('GeoDa_CreateContiguityWeights__SWIG_3'))

# Start of GeoDa_CreateContiguityWeights

`GeoDa_CreateContiguityWeights__SWIG_4` = function(self, is_queen)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  is_queen = as.logical(is_queen);
  ;ans = .Call('R_swig_GeoDa_CreateContiguityWeights__SWIG_4', self, is_queen, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateContiguityWeights__SWIG_4`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateContiguityWeights__SWIG_4`, "inputTypes") = c('_p_GeoDa', 'logical')
class(`GeoDa_CreateContiguityWeights__SWIG_4`) = c("SWIGFunction", class('GeoDa_CreateContiguityWeights__SWIG_4'))

# Start of GeoDa_CreateContiguityWeights

`GeoDa_CreateContiguityWeights__SWIG_5` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GeoDa_CreateContiguityWeights__SWIG_5', self, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateContiguityWeights__SWIG_5`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateContiguityWeights__SWIG_5`, "inputTypes") = c('_p_GeoDa')
class(`GeoDa_CreateContiguityWeights__SWIG_5`) = c("SWIGFunction", class('GeoDa_CreateContiguityWeights__SWIG_5'))

`GeoDa_CreateContiguityWeights` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 6
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]]))) {
      f <- GeoDa_CreateContiguityWeights__SWIG_5; 
    }
  } else if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- GeoDa_CreateContiguityWeights__SWIG_4; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- GeoDa_CreateContiguityWeights__SWIG_3; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 )) {
      f <- GeoDa_CreateContiguityWeights__SWIG_2; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- GeoDa_CreateContiguityWeights__SWIG_1; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1 && ( (is.integer(argv[[4]]) || is.numeric(argv[[4]])) && length(argv[[4]]) == 1 ) && ( is.logical(argv[[5]]) && length(argv[[5]]) == 1 ) && ( is.numeric(argv[[6]]) && length(argv[[6]]) == 1 )) {
      f <- GeoDa_CreateContiguityWeights__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa_CreateContiguityWeights with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDa_CreateDistanceWeights

`GeoDa_CreateDistanceWeights__SWIG_0` = function(self, dist_thres, power, is_inverse)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  is_inverse = as.logical(is_inverse);
  ;ans = .Call('R_swig_GeoDa_CreateDistanceWeights__SWIG_0', self, dist_thres, power, is_inverse, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateDistanceWeights__SWIG_0`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateDistanceWeights__SWIG_0`, "inputTypes") = c('_p_GeoDa', 'numeric', 'numeric', 'logical')
class(`GeoDa_CreateDistanceWeights__SWIG_0`) = c("SWIGFunction", class('GeoDa_CreateDistanceWeights__SWIG_0'))

# Start of GeoDa_CreateDistanceWeights

`GeoDa_CreateDistanceWeights__SWIG_1` = function(self, dist_thres, power)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  ;ans = .Call('R_swig_GeoDa_CreateDistanceWeights__SWIG_1', self, dist_thres, power, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateDistanceWeights__SWIG_1`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateDistanceWeights__SWIG_1`, "inputTypes") = c('_p_GeoDa', 'numeric', 'numeric')
class(`GeoDa_CreateDistanceWeights__SWIG_1`) = c("SWIGFunction", class('GeoDa_CreateDistanceWeights__SWIG_1'))

# Start of GeoDa_CreateDistanceWeights

`GeoDa_CreateDistanceWeights__SWIG_2` = function(self, dist_thres)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;ans = .Call('R_swig_GeoDa_CreateDistanceWeights__SWIG_2', self, dist_thres, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaWeight", ref=ans);
  
  ans
  
}

attr(`GeoDa_CreateDistanceWeights__SWIG_2`, 'returnType') = '_p_GeoDaWeight'
attr(`GeoDa_CreateDistanceWeights__SWIG_2`, "inputTypes") = c('_p_GeoDa', 'numeric')
class(`GeoDa_CreateDistanceWeights__SWIG_2`) = c("SWIGFunction", class('GeoDa_CreateDistanceWeights__SWIG_2'))

`GeoDa_CreateDistanceWeights` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- GeoDa_CreateDistanceWeights__SWIG_2; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 )) {
      f <- GeoDa_CreateDistanceWeights__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.logical(argv[[4]]) && length(argv[[4]]) == 1 )) {
      f <- GeoDa_CreateDistanceWeights__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa_CreateDistanceWeights with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDa_LISA

`GeoDa_LISA__SWIG_0` = function(self, w, data, undefs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  undefs = as.logical(undefs);
  ;ans = .Call('R_swig_GeoDa_LISA__SWIG_0', self, w, data, undefs, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_UniLisa", ref=ans);
  
  ans
  
}

attr(`GeoDa_LISA__SWIG_0`, 'returnType') = '_p_UniLisa'
attr(`GeoDa_LISA__SWIG_0`, "inputTypes") = c('_p_GeoDa', '_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_bool_std__allocatorT_bool_t_t')
class(`GeoDa_LISA__SWIG_0`) = c("SWIGFunction", class('GeoDa_LISA__SWIG_0'))

# Start of GeoDa_LISA

`GeoDa_LISA__SWIG_1` = function(self, w, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = as.numeric(data);
  ;ans = .Call('R_swig_GeoDa_LISA__SWIG_1', self, w, data, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_UniLisa", ref=ans);
  
  ans
  
}

attr(`GeoDa_LISA__SWIG_1`, 'returnType') = '_p_UniLisa'
attr(`GeoDa_LISA__SWIG_1`, "inputTypes") = c('_p_GeoDa', '_p_GeoDaWeight', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GeoDa_LISA__SWIG_1`) = c("SWIGFunction", class('GeoDa_LISA__SWIG_1'))

`GeoDa_LISA` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 3) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.numeric(argv[[3]]) )) {
      f <- GeoDa_LISA__SWIG_1; 
    }
  } else if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && (extends(argtypes[2], '_p_GeoDaWeight') || is.null(argv[[2]])) && ( is.numeric(argv[[3]]) ) && ( is.logical(argv[[4]]) )) {
      f <- GeoDa_LISA__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa_LISA with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_0` = function(self, k, w, col_names, distance_method, control_varible, control_threshold, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  
  ;.Call('R_swig_GeoDa_SKATER__SWIG_0', self, k, w, col_names, distance_method, control_varible, control_threshold, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_0`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_0`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character', 'character', 'character', 'numeric')
class(`GeoDa_SKATER__SWIG_0`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_0'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_1` = function(self, k, w, col_names, distance_method, control_varible, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_1', self, k, w, col_names, distance_method, control_varible, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_1`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_1`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character', 'character', 'character')
class(`GeoDa_SKATER__SWIG_1`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_1'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_2` = function(self, k, w, col_names, distance_method, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  distance_method = as(distance_method, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_2', self, k, w, col_names, distance_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_2`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_2`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character', 'character')
class(`GeoDa_SKATER__SWIG_2`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_2'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_3` = function(self, k, w, col_names, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  col_names = as.character(col_names);
  ;.Call('R_swig_GeoDa_SKATER__SWIG_3', self, k, w, col_names, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_3`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_3`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'character')
class(`GeoDa_SKATER__SWIG_3`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_3'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_4` = function(self, k, w, data, distance_method, control_varible, control_threshold, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  
  ;.Call('R_swig_GeoDa_SKATER__SWIG_4', self, k, w, data, distance_method, control_varible, control_threshold, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_4`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_4`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list', 'character', 'character', 'numeric')
class(`GeoDa_SKATER__SWIG_4`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_4'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_5` = function(self, k, w, data, distance_method, control_varible, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  control_varible = as(control_varible, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_5', self, k, w, data, distance_method, control_varible, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_5`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_5`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list', 'character', 'character')
class(`GeoDa_SKATER__SWIG_5`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_5'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_6` = function(self, k, w, data, distance_method, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  distance_method = as(distance_method, "character"); 
  ;.Call('R_swig_GeoDa_SKATER__SWIG_6', self, k, w, data, distance_method, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_6`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_6`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list', 'character')
class(`GeoDa_SKATER__SWIG_6`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_6'))

# Start of GeoDa_SKATER

`GeoDa_SKATER__SWIG_7` = function(self, k, w, data, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  k = as.integer(k);
  
  if(length(k) > 1) {
    warning("using only the first element of k");
  };
  
  if (inherits(w, "ExternalReference")) w = slot(w,"ref") 
  data = lapply(data, as.numeric);
  ;.Call('R_swig_GeoDa_SKATER__SWIG_7', self, k, w, data, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`GeoDa_SKATER__SWIG_7`, 'returnType') = 'integer'
attr(`GeoDa_SKATER__SWIG_7`, "inputTypes") = c('_p_GeoDa', 'integer', '_p_GeoDaWeight', 'list')
class(`GeoDa_SKATER__SWIG_7`) = c("SWIGFunction", class('GeoDa_SKATER__SWIG_7'))

`GeoDa_SKATER` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 8
  if (argc == 4) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) )) {
      f <- GeoDa_SKATER__SWIG_7; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) )) {
      f <- GeoDa_SKATER__SWIG_3; 
    }
  } else if (argc == 5) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1) {
      f <- GeoDa_SKATER__SWIG_6; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1) {
      f <- GeoDa_SKATER__SWIG_2; 
    }
  } else if (argc == 6) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1) {
      f <- GeoDa_SKATER__SWIG_5; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1) {
      f <- GeoDa_SKATER__SWIG_1; 
    }
  } else if (argc == 7) {
    if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.list(argv[[4]]) && all(sapply(argv[[4]] , is.integer) || sapply(argv[[4]], is.numeric)) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1 && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 )) {
      f <- GeoDa_SKATER__SWIG_4; 
    }
    else if ((extends(argtypes[1], '_p_GeoDa') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && (extends(argtypes[3], '_p_GeoDaWeight') || is.null(argv[[3]])) && ( is.character(argv[[4]]) ) && is.character(argv[[5]]) && length(argv[[5]]) == 1 && is.character(argv[[6]]) && length(argv[[6]]) == 1 && ( is.numeric(argv[[7]]) && length(argv[[7]]) == 1 )) {
      f <- GeoDa_SKATER__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for GeoDa_SKATER with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of accessor method for GeoDa
setMethod('$', '_p_GeoDa', function(x, name)

{
  accessorFuns = list('GetMapType' = GeoDa_GetMapType, 'GetNumObs' = GeoDa_GetNumObs, 'GetNumCols' = GeoDa_GetNumCols, 'GetFieldTypes' = GeoDa_GetFieldTypes, 'GetFieldNames' = GeoDa_GetFieldNames, 'GetGeometryWKB' = GeoDa_GetGeometryWKB, 'GetGeometryWKT' = GeoDa_GetGeometryWKT, 'GetNumericCol' = GeoDa_GetNumericCol, 'GetIntegerCol' = GeoDa_GetIntegerCol, 'GetStringCol' = GeoDa_GetStringCol, 'GetUndefinesCol' = GeoDa_GetUndefinesCol, 'GetName' = GeoDa_GetName, 'CreateContiguityWeights' = GeoDa_CreateContiguityWeights, 'CreateDistanceWeights' = GeoDa_CreateDistanceWeights, 'LISA' = GeoDa_LISA, 'SKATER' = GeoDa_SKATER);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for GeoDa
setMethod('delete', '_p_GeoDa', function(obj) {delete_GeoDa(obj)})
# Start of test

`test` = function(.copy = FALSE)
{
  ;.Call('R_swig_test', as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`test`, 'returnType') = 'integer'
class(`test`) = c("SWIGFunction", class('test'))

# Start of ToGeoDaColumn

`ToGeoDaColumn__SWIG_0` = function(col)
{
  if (inherits(col, "ExternalReference")) col = slot(col,"ref") 
  ;ans = .Call('R_swig_ToGeoDaColumn__SWIG_0', col, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`ToGeoDaColumn__SWIG_0`, 'returnType') = '_p_GeoDaColumn'
attr(`ToGeoDaColumn__SWIG_0`, "inputTypes") = c('_p_GeoDaStringColumn')
class(`ToGeoDaColumn__SWIG_0`) = c("SWIGFunction", class('ToGeoDaColumn__SWIG_0'))

# Start of ToGeoDaColumn

`ToGeoDaColumn__SWIG_1` = function(col)
{
  if (inherits(col, "ExternalReference")) col = slot(col,"ref") 
  ;ans = .Call('R_swig_ToGeoDaColumn__SWIG_1', col, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`ToGeoDaColumn__SWIG_1`, 'returnType') = '_p_GeoDaColumn'
attr(`ToGeoDaColumn__SWIG_1`, "inputTypes") = c('_p_GeoDaIntColumn')
class(`ToGeoDaColumn__SWIG_1`) = c("SWIGFunction", class('ToGeoDaColumn__SWIG_1'))

# Start of ToGeoDaColumn

`ToGeoDaColumn__SWIG_2` = function(col)
{
  if (inherits(col, "ExternalReference")) col = slot(col,"ref") 
  ;ans = .Call('R_swig_ToGeoDaColumn__SWIG_2', col, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`ToGeoDaColumn__SWIG_2`, 'returnType') = '_p_GeoDaColumn'
attr(`ToGeoDaColumn__SWIG_2`, "inputTypes") = c('_p_GeoDaRealColumn')
class(`ToGeoDaColumn__SWIG_2`) = c("SWIGFunction", class('ToGeoDaColumn__SWIG_2'))

`ToGeoDaColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 1) {
    if ((extends(argtypes[1], '_p_GeoDaStringColumn') || is.null(argv[[1]]))) {
      f <- ToGeoDaColumn__SWIG_0; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaIntColumn') || is.null(argv[[1]]))) {
      f <- ToGeoDaColumn__SWIG_1; 
    }
    else if ((extends(argtypes[1], '_p_GeoDaRealColumn') || is.null(argv[[1]]))) {
      f <- ToGeoDaColumn__SWIG_2; 
    }
  } else {
    stop("cannot find overloaded function for ToGeoDaColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecGeoDaColumn___nonzero__

`VecGeoDaColumn___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___nonzero__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___nonzero__`, 'returnType') = 'logical'
attr(`VecGeoDaColumn___nonzero__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn___nonzero__`) = c("SWIGFunction", class('VecGeoDaColumn___nonzero__'))

# Start of VecGeoDaColumn___len__

`VecGeoDaColumn___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___len__', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___len__`, 'returnType') = 'integer'
attr(`VecGeoDaColumn___len__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn___len__`) = c("SWIGFunction", class('VecGeoDaColumn___len__'))

# Start of VecGeoDaColumn_pop

`VecGeoDaColumn_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_pop', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_pop`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn_pop`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_pop`) = c("SWIGFunction", class('VecGeoDaColumn_pop'))

# Start of VecGeoDaColumn___getslice__

`VecGeoDaColumn___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VecGeoDaColumn___getslice__', self, i, j, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn___getslice__`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn___getslice__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', 'integer')
class(`VecGeoDaColumn___getslice__`) = c("SWIGFunction", class('VecGeoDaColumn___getslice__'))

# Start of VecGeoDaColumn___setslice__

`VecGeoDaColumn___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___setslice__', self, i, j, v, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___setslice__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___setslice__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', 'integer', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn___setslice__`) = c("SWIGFunction", class('VecGeoDaColumn___setslice__'))

# Start of VecGeoDaColumn___delslice__

`VecGeoDaColumn___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VecGeoDaColumn___delslice__', self, i, j, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___delslice__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___delslice__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', 'integer')
class(`VecGeoDaColumn___delslice__`) = c("SWIGFunction", class('VecGeoDaColumn___delslice__'))

# Start of VecGeoDaColumn___delitem__

`VecGeoDaColumn___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VecGeoDaColumn___delitem__', self, i, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___delitem__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___delitem__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn___delitem__`) = c("SWIGFunction", class('VecGeoDaColumn___delitem__'))

# Start of VecGeoDaColumn___getitem__

`VecGeoDaColumn___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_VecGeoDaColumn___getitem__', self, i, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn___getitem__`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn___getitem__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn___getitem__`) = c("SWIGFunction", class('VecGeoDaColumn___getitem__'))

# Start of VecGeoDaColumn___setitem__

`VecGeoDaColumn___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn___setitem__', self, i, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn___setitem__`, 'returnType') = 'void'
attr(`VecGeoDaColumn___setitem__`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn___setitem__`) = c("SWIGFunction", class('VecGeoDaColumn___setitem__'))

# Start of VecGeoDaColumn_append

`VecGeoDaColumn_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_append', self, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_append`, 'returnType') = 'void'
attr(`VecGeoDaColumn_append`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', '_p_GeoDaColumn')
class(`VecGeoDaColumn_append`) = c("SWIGFunction", class('VecGeoDaColumn_append'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_0', PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_0`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
class(`VecGeoDaColumn__SWIG_0`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_0'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_1` = function(other)
{
  if (inherits(other, "ExternalReference")) other = slot(other,"ref") 
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_1', other, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_1`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn__SWIG_1`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn__SWIG_1`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_1'))

# Start of VecGeoDaColumn_empty

`VecGeoDaColumn_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_empty', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_empty`, 'returnType') = 'logical'
attr(`VecGeoDaColumn_empty`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_empty`) = c("SWIGFunction", class('VecGeoDaColumn_empty'))

# Start of VecGeoDaColumn_size

`VecGeoDaColumn_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_size', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_size`, 'returnType') = 'integer'
attr(`VecGeoDaColumn_size`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_size`) = c("SWIGFunction", class('VecGeoDaColumn_size'))

# Start of VecGeoDaColumn_swap

`VecGeoDaColumn_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_swap', self, v, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_swap`, 'returnType') = 'void'
attr(`VecGeoDaColumn_swap`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_swap`) = c("SWIGFunction", class('VecGeoDaColumn_swap'))

# Start of VecGeoDaColumn_clear

`VecGeoDaColumn_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_clear', self, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_clear`, 'returnType') = 'void'
attr(`VecGeoDaColumn_clear`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_clear`) = c("SWIGFunction", class('VecGeoDaColumn_clear'))

# Start of VecGeoDaColumn_get_allocator

`VecGeoDaColumn_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_get_allocator', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__allocatorT_GeoDaColumn_p_t", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_get_allocator`, 'returnType') = '_p_std__allocatorT_GeoDaColumn_p_t'
attr(`VecGeoDaColumn_get_allocator`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_get_allocator`) = c("SWIGFunction", class('VecGeoDaColumn_get_allocator'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_2', size, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_2`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn__SWIG_2`, "inputTypes") = c('integer')
class(`VecGeoDaColumn__SWIG_2`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_2'))

# Start of VecGeoDaColumn_pop_back

`VecGeoDaColumn_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_pop_back', self, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_pop_back`, 'returnType') = 'void'
attr(`VecGeoDaColumn_pop_back`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_pop_back`) = c("SWIGFunction", class('VecGeoDaColumn_pop_back'))

# Start of VecGeoDaColumn_resize

`VecGeoDaColumn_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VecGeoDaColumn_resize__SWIG_0', self, new_size, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_resize__SWIG_0`, 'returnType') = 'void'
attr(`VecGeoDaColumn_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn_resize__SWIG_0`) = c("SWIGFunction", class('VecGeoDaColumn_resize__SWIG_0'))

# Start of new_VecGeoDaColumn

`VecGeoDaColumn__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_VecGeoDaColumn__SWIG_3', size, value, PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t", ref=ans);
  
  reg.finalizer(ans@ref, delete_VecGeoDaColumn)
  ans
  
}

attr(`VecGeoDaColumn__SWIG_3`, 'returnType') = '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t'
attr(`VecGeoDaColumn__SWIG_3`, "inputTypes") = c('integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn__SWIG_3`) = c("SWIGFunction", class('VecGeoDaColumn__SWIG_3'))

`VecGeoDaColumn` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VecGeoDaColumn__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VecGeoDaColumn__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t') && length(argv[[1]]) == 1) {
      f <- VecGeoDaColumn__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_GeoDaColumn') && length(argv[[2]]) == 1) {
      f <- VecGeoDaColumn__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VecGeoDaColumn with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecGeoDaColumn_push_back

`VecGeoDaColumn_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_push_back', self, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_push_back`, 'returnType') = 'void'
attr(`VecGeoDaColumn_push_back`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', '_p_GeoDaColumn')
class(`VecGeoDaColumn_push_back`) = c("SWIGFunction", class('VecGeoDaColumn_push_back'))

# Start of VecGeoDaColumn_front

`VecGeoDaColumn_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_front', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_front`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn_front`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_front`) = c("SWIGFunction", class('VecGeoDaColumn_front'))

# Start of VecGeoDaColumn_back

`VecGeoDaColumn_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VecGeoDaColumn_back', self, as.logical(.copy), PACKAGE='rgeoda');
  ans <- if (is.null(ans)) ans
  else new("_p_GeoDaColumn", ref=ans);
  
  ans
  
}

attr(`VecGeoDaColumn_back`, 'returnType') = '_p_GeoDaColumn'
attr(`VecGeoDaColumn_back`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_back`) = c("SWIGFunction", class('VecGeoDaColumn_back'))

# Start of VecGeoDaColumn_assign

`VecGeoDaColumn_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_assign', self, n, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_assign`, 'returnType') = 'void'
attr(`VecGeoDaColumn_assign`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn_assign`) = c("SWIGFunction", class('VecGeoDaColumn_assign'))

# Start of VecGeoDaColumn_resize

`VecGeoDaColumn_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_resize__SWIG_1', self, new_size, x, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_resize__SWIG_1`, 'returnType') = 'void'
attr(`VecGeoDaColumn_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer', '_p_GeoDaColumn')
class(`VecGeoDaColumn_resize__SWIG_1`) = c("SWIGFunction", class('VecGeoDaColumn_resize__SWIG_1'))

`VecGeoDaColumn_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if ((extends(argtypes[1], '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VecGeoDaColumn_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if ((extends(argtypes[1], '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t') || is.null(argv[[1]])) && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_GeoDaColumn') && length(argv[[3]]) == 1) {
      f <- VecGeoDaColumn_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VecGeoDaColumn_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VecGeoDaColumn_reserve

`VecGeoDaColumn_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VecGeoDaColumn_reserve', self, n, PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_reserve`, 'returnType') = 'void'
attr(`VecGeoDaColumn_reserve`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', 'integer')
class(`VecGeoDaColumn_reserve`) = c("SWIGFunction", class('VecGeoDaColumn_reserve'))

# Start of VecGeoDaColumn_capacity

`VecGeoDaColumn_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VecGeoDaColumn_capacity', self, as.logical(.copy), PACKAGE='rgeoda');
  
}

attr(`VecGeoDaColumn_capacity`, 'returnType') = 'integer'
attr(`VecGeoDaColumn_capacity`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`VecGeoDaColumn_capacity`) = c("SWIGFunction", class('VecGeoDaColumn_capacity'))

# Start of delete_VecGeoDaColumn

`delete_VecGeoDaColumn` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VecGeoDaColumn', self, PACKAGE='rgeoda');
  
}

attr(`delete_VecGeoDaColumn`, 'returnType') = 'void'
attr(`delete_VecGeoDaColumn`, "inputTypes") = c('_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t')
class(`delete_VecGeoDaColumn`) = c("SWIGFunction", class('delete_VecGeoDaColumn'))

# Start of accessor method for std::vector<(p.GeoDaColumn)>
setMethod('$', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VecGeoDaColumn___nonzero__, '__len__' = VecGeoDaColumn___len__, 'pop' = VecGeoDaColumn_pop, '__getslice__' = VecGeoDaColumn___getslice__, '__setslice__' = VecGeoDaColumn___setslice__, '__delslice__' = VecGeoDaColumn___delslice__, '__delitem__' = VecGeoDaColumn___delitem__, '__getitem__' = VecGeoDaColumn___getitem__, '__setitem__' = VecGeoDaColumn___setitem__, 'append' = VecGeoDaColumn_append, 'empty' = VecGeoDaColumn_empty, 'size' = VecGeoDaColumn_size, 'swap' = VecGeoDaColumn_swap, 'clear' = VecGeoDaColumn_clear, 'get_allocator' = VecGeoDaColumn_get_allocator, 'pop_back' = VecGeoDaColumn_pop_back, 'resize' = VecGeoDaColumn_resize, 'push_back' = VecGeoDaColumn_push_back, 'front' = VecGeoDaColumn_front, 'back' = VecGeoDaColumn_back, 'assign' = VecGeoDaColumn_assign, 'reserve' = VecGeoDaColumn_reserve, 'capacity' = VecGeoDaColumn_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(p.GeoDaColumn)>
setMethod('delete', '_p_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t', function(obj) {delete_std__vectorT_GeoDaColumn_p_std__allocatorT_GeoDaColumn_p_t_t(obj)})

defineEnumeration("_GeoDaWeight__WeightType",
 .values=c("gal_type" = .Call('R_swig_GeoDaWeight_gal_type_get',FALSE, PACKAGE='rgeoda'),
"gwt_type" = .Call('R_swig_GeoDaWeight_gwt_type_get',FALSE, PACKAGE='rgeoda')))

defineEnumeration("_GeoDaColumn__FieldType",
 .values=c("integer_type" = .Call('R_swig_GeoDaColumn_integer_type_get',FALSE, PACKAGE='rgeoda'),
"string_type" = .Call('R_swig_GeoDaColumn_string_type_get',FALSE, PACKAGE='rgeoda'),
"real_type" = .Call('R_swig_GeoDaColumn_real_type_get',FALSE, PACKAGE='rgeoda')))

defineEnumeration("_GeoDa__MapType",
 .values=c("point_type" = .Call('R_swig_GeoDa_point_type_get',FALSE, PACKAGE='rgeoda'),
"polygon_type" = .Call('R_swig_GeoDa_polygon_type_get',FALSE, PACKAGE='rgeoda'),
"line_type" = .Call('R_swig_GeoDa_line_type_get',FALSE, PACKAGE='rgeoda')))


